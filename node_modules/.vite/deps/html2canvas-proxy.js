import {
  require_bytesToUuid,
  require_rng_browser,
  require_v4
} from "./chunk-34QYN56O.js";
import {
  buffer_exports,
  crypto_exports,
  events_exports,
  fs_exports,
  http_exports,
  init_buffer,
  init_crypto,
  init_events,
  init_fs,
  init_http,
  init_net,
  init_querystring,
  init_stream,
  init_url,
  init_util,
  init_zlib,
  net_exports,
  querystring_exports,
  require_express,
  require_mime_types,
  require_safer,
  require_vary,
  stream_exports,
  url_exports,
  util_exports,
  zlib_exports
} from "./chunk-2Y7QWBAQ.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-OROXOI2D.js";

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/cors/lib/index.js
var require_lib = __commonJS({
  "node_modules/cors/lib/index.js"(exports, module) {
    (function() {
      "use strict";
      var assign = require_object_assign();
      var vary = require_vary();
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString(options.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options) {
        var maxAge = options.maxAge && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          if (options.preflightContinue) {
            next();
          } else {
            res.statusCode = options.optionsSuccessStatus || defaults.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function(err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      module.exports = middlewareWrapper;
    })();
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/punycode/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q2, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q2 = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q2 < t) {
                  break;
                }
                qMinusT = q2 - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        "version": "1.4.1",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/tough-cookie/lib/pubsuffix.js
var require_pubsuffix = __commonJS({
  "node_modules/tough-cookie/lib/pubsuffix.js"(exports, module) {
    "use strict";
    var punycode = require_punycode();
    module.exports.getPublicSuffix = function getPublicSuffix(domain) {
      if (!domain) {
        return null;
      }
      if (domain.match(/^\./)) {
        return null;
      }
      var asciiDomain = punycode.toASCII(domain);
      var converted = false;
      if (asciiDomain !== domain) {
        domain = asciiDomain;
        converted = true;
      }
      if (index[domain]) {
        return null;
      }
      domain = domain.toLowerCase();
      var parts = domain.split(".").reverse();
      var suffix = "";
      var suffixLen = 0;
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        var starstr = "*" + suffix;
        var partstr = part + suffix;
        if (index[starstr]) {
          suffixLen = i + 1;
          if (index[partstr] === false) {
            suffixLen--;
          }
        } else if (index[partstr]) {
          suffixLen = i + 1;
        }
        suffix = "." + partstr;
      }
      if (index["*" + suffix]) {
        return null;
      }
      suffixLen = suffixLen || 1;
      if (parts.length > suffixLen) {
        var publicSuffix = parts.slice(0, suffixLen + 1).reverse().join(".");
        return converted ? punycode.toUnicode(publicSuffix) : publicSuffix;
      }
      return null;
    };
    var index = module.exports.index = Object.freeze({ "ac": true, "com.ac": true, "edu.ac": true, "gov.ac": true, "net.ac": true, "mil.ac": true, "org.ac": true, "ad": true, "nom.ad": true, "ae": true, "co.ae": true, "net.ae": true, "org.ae": true, "sch.ae": true, "ac.ae": true, "gov.ae": true, "mil.ae": true, "aero": true, "accident-investigation.aero": true, "accident-prevention.aero": true, "aerobatic.aero": true, "aeroclub.aero": true, "aerodrome.aero": true, "agents.aero": true, "aircraft.aero": true, "airline.aero": true, "airport.aero": true, "air-surveillance.aero": true, "airtraffic.aero": true, "air-traffic-control.aero": true, "ambulance.aero": true, "amusement.aero": true, "association.aero": true, "author.aero": true, "ballooning.aero": true, "broker.aero": true, "caa.aero": true, "cargo.aero": true, "catering.aero": true, "certification.aero": true, "championship.aero": true, "charter.aero": true, "civilaviation.aero": true, "club.aero": true, "conference.aero": true, "consultant.aero": true, "consulting.aero": true, "control.aero": true, "council.aero": true, "crew.aero": true, "design.aero": true, "dgca.aero": true, "educator.aero": true, "emergency.aero": true, "engine.aero": true, "engineer.aero": true, "entertainment.aero": true, "equipment.aero": true, "exchange.aero": true, "express.aero": true, "federation.aero": true, "flight.aero": true, "freight.aero": true, "fuel.aero": true, "gliding.aero": true, "government.aero": true, "groundhandling.aero": true, "group.aero": true, "hanggliding.aero": true, "homebuilt.aero": true, "insurance.aero": true, "journal.aero": true, "journalist.aero": true, "leasing.aero": true, "logistics.aero": true, "magazine.aero": true, "maintenance.aero": true, "media.aero": true, "microlight.aero": true, "modelling.aero": true, "navigation.aero": true, "parachuting.aero": true, "paragliding.aero": true, "passenger-association.aero": true, "pilot.aero": true, "press.aero": true, "production.aero": true, "recreation.aero": true, "repbody.aero": true, "res.aero": true, "research.aero": true, "rotorcraft.aero": true, "safety.aero": true, "scientist.aero": true, "services.aero": true, "show.aero": true, "skydiving.aero": true, "software.aero": true, "student.aero": true, "trader.aero": true, "trading.aero": true, "trainer.aero": true, "union.aero": true, "workinggroup.aero": true, "works.aero": true, "af": true, "gov.af": true, "com.af": true, "org.af": true, "net.af": true, "edu.af": true, "ag": true, "com.ag": true, "org.ag": true, "net.ag": true, "co.ag": true, "nom.ag": true, "ai": true, "off.ai": true, "com.ai": true, "net.ai": true, "org.ai": true, "al": true, "com.al": true, "edu.al": true, "gov.al": true, "mil.al": true, "net.al": true, "org.al": true, "am": true, "ao": true, "ed.ao": true, "gv.ao": true, "og.ao": true, "co.ao": true, "pb.ao": true, "it.ao": true, "aq": true, "ar": true, "com.ar": true, "edu.ar": true, "gob.ar": true, "gov.ar": true, "int.ar": true, "mil.ar": true, "musica.ar": true, "net.ar": true, "org.ar": true, "tur.ar": true, "arpa": true, "e164.arpa": true, "in-addr.arpa": true, "ip6.arpa": true, "iris.arpa": true, "uri.arpa": true, "urn.arpa": true, "as": true, "gov.as": true, "asia": true, "at": true, "ac.at": true, "co.at": true, "gv.at": true, "or.at": true, "au": true, "com.au": true, "net.au": true, "org.au": true, "edu.au": true, "gov.au": true, "asn.au": true, "id.au": true, "info.au": true, "conf.au": true, "oz.au": true, "act.au": true, "nsw.au": true, "nt.au": true, "qld.au": true, "sa.au": true, "tas.au": true, "vic.au": true, "wa.au": true, "act.edu.au": true, "nsw.edu.au": true, "nt.edu.au": true, "qld.edu.au": true, "sa.edu.au": true, "tas.edu.au": true, "vic.edu.au": true, "wa.edu.au": true, "qld.gov.au": true, "sa.gov.au": true, "tas.gov.au": true, "vic.gov.au": true, "wa.gov.au": true, "aw": true, "com.aw": true, "ax": true, "az": true, "com.az": true, "net.az": true, "int.az": true, "gov.az": true, "org.az": true, "edu.az": true, "info.az": true, "pp.az": true, "mil.az": true, "name.az": true, "pro.az": true, "biz.az": true, "ba": true, "com.ba": true, "edu.ba": true, "gov.ba": true, "mil.ba": true, "net.ba": true, "org.ba": true, "bb": true, "biz.bb": true, "co.bb": true, "com.bb": true, "edu.bb": true, "gov.bb": true, "info.bb": true, "net.bb": true, "org.bb": true, "store.bb": true, "tv.bb": true, "*.bd": true, "be": true, "ac.be": true, "bf": true, "gov.bf": true, "bg": true, "a.bg": true, "b.bg": true, "c.bg": true, "d.bg": true, "e.bg": true, "f.bg": true, "g.bg": true, "h.bg": true, "i.bg": true, "j.bg": true, "k.bg": true, "l.bg": true, "m.bg": true, "n.bg": true, "o.bg": true, "p.bg": true, "q.bg": true, "r.bg": true, "s.bg": true, "t.bg": true, "u.bg": true, "v.bg": true, "w.bg": true, "x.bg": true, "y.bg": true, "z.bg": true, "0.bg": true, "1.bg": true, "2.bg": true, "3.bg": true, "4.bg": true, "5.bg": true, "6.bg": true, "7.bg": true, "8.bg": true, "9.bg": true, "bh": true, "com.bh": true, "edu.bh": true, "net.bh": true, "org.bh": true, "gov.bh": true, "bi": true, "co.bi": true, "com.bi": true, "edu.bi": true, "or.bi": true, "org.bi": true, "biz": true, "bj": true, "asso.bj": true, "barreau.bj": true, "gouv.bj": true, "bm": true, "com.bm": true, "edu.bm": true, "gov.bm": true, "net.bm": true, "org.bm": true, "*.bn": true, "bo": true, "com.bo": true, "edu.bo": true, "gob.bo": true, "int.bo": true, "org.bo": true, "net.bo": true, "mil.bo": true, "tv.bo": true, "web.bo": true, "academia.bo": true, "agro.bo": true, "arte.bo": true, "blog.bo": true, "bolivia.bo": true, "ciencia.bo": true, "cooperativa.bo": true, "democracia.bo": true, "deporte.bo": true, "ecologia.bo": true, "economia.bo": true, "empresa.bo": true, "indigena.bo": true, "industria.bo": true, "info.bo": true, "medicina.bo": true, "movimiento.bo": true, "musica.bo": true, "natural.bo": true, "nombre.bo": true, "noticias.bo": true, "patria.bo": true, "politica.bo": true, "profesional.bo": true, "plurinacional.bo": true, "pueblo.bo": true, "revista.bo": true, "salud.bo": true, "tecnologia.bo": true, "tksat.bo": true, "transporte.bo": true, "wiki.bo": true, "br": true, "9guacu.br": true, "abc.br": true, "adm.br": true, "adv.br": true, "agr.br": true, "aju.br": true, "am.br": true, "anani.br": true, "aparecida.br": true, "arq.br": true, "art.br": true, "ato.br": true, "b.br": true, "belem.br": true, "bhz.br": true, "bio.br": true, "blog.br": true, "bmd.br": true, "boavista.br": true, "bsb.br": true, "campinagrande.br": true, "campinas.br": true, "caxias.br": true, "cim.br": true, "cng.br": true, "cnt.br": true, "com.br": true, "contagem.br": true, "coop.br": true, "cri.br": true, "cuiaba.br": true, "curitiba.br": true, "def.br": true, "ecn.br": true, "eco.br": true, "edu.br": true, "emp.br": true, "eng.br": true, "esp.br": true, "etc.br": true, "eti.br": true, "far.br": true, "feira.br": true, "flog.br": true, "floripa.br": true, "fm.br": true, "fnd.br": true, "fortal.br": true, "fot.br": true, "foz.br": true, "fst.br": true, "g12.br": true, "ggf.br": true, "goiania.br": true, "gov.br": true, "ac.gov.br": true, "al.gov.br": true, "am.gov.br": true, "ap.gov.br": true, "ba.gov.br": true, "ce.gov.br": true, "df.gov.br": true, "es.gov.br": true, "go.gov.br": true, "ma.gov.br": true, "mg.gov.br": true, "ms.gov.br": true, "mt.gov.br": true, "pa.gov.br": true, "pb.gov.br": true, "pe.gov.br": true, "pi.gov.br": true, "pr.gov.br": true, "rj.gov.br": true, "rn.gov.br": true, "ro.gov.br": true, "rr.gov.br": true, "rs.gov.br": true, "sc.gov.br": true, "se.gov.br": true, "sp.gov.br": true, "to.gov.br": true, "gru.br": true, "imb.br": true, "ind.br": true, "inf.br": true, "jab.br": true, "jampa.br": true, "jdf.br": true, "joinville.br": true, "jor.br": true, "jus.br": true, "leg.br": true, "lel.br": true, "londrina.br": true, "macapa.br": true, "maceio.br": true, "manaus.br": true, "maringa.br": true, "mat.br": true, "med.br": true, "mil.br": true, "morena.br": true, "mp.br": true, "mus.br": true, "natal.br": true, "net.br": true, "niteroi.br": true, "*.nom.br": true, "not.br": true, "ntr.br": true, "odo.br": true, "org.br": true, "osasco.br": true, "palmas.br": true, "poa.br": true, "ppg.br": true, "pro.br": true, "psc.br": true, "psi.br": true, "pvh.br": true, "qsl.br": true, "radio.br": true, "rec.br": true, "recife.br": true, "ribeirao.br": true, "rio.br": true, "riobranco.br": true, "riopreto.br": true, "salvador.br": true, "sampa.br": true, "santamaria.br": true, "santoandre.br": true, "saobernardo.br": true, "saogonca.br": true, "sjc.br": true, "slg.br": true, "slz.br": true, "sorocaba.br": true, "srv.br": true, "taxi.br": true, "teo.br": true, "the.br": true, "tmp.br": true, "trd.br": true, "tur.br": true, "tv.br": true, "udi.br": true, "vet.br": true, "vix.br": true, "vlog.br": true, "wiki.br": true, "zlg.br": true, "bs": true, "com.bs": true, "net.bs": true, "org.bs": true, "edu.bs": true, "gov.bs": true, "bt": true, "com.bt": true, "edu.bt": true, "gov.bt": true, "net.bt": true, "org.bt": true, "bv": true, "bw": true, "co.bw": true, "org.bw": true, "by": true, "gov.by": true, "mil.by": true, "com.by": true, "of.by": true, "bz": true, "com.bz": true, "net.bz": true, "org.bz": true, "edu.bz": true, "gov.bz": true, "ca": true, "ab.ca": true, "bc.ca": true, "mb.ca": true, "nb.ca": true, "nf.ca": true, "nl.ca": true, "ns.ca": true, "nt.ca": true, "nu.ca": true, "on.ca": true, "pe.ca": true, "qc.ca": true, "sk.ca": true, "yk.ca": true, "gc.ca": true, "cat": true, "cc": true, "cd": true, "gov.cd": true, "cf": true, "cg": true, "ch": true, "ci": true, "org.ci": true, "or.ci": true, "com.ci": true, "co.ci": true, "edu.ci": true, "ed.ci": true, "ac.ci": true, "net.ci": true, "go.ci": true, "asso.ci": true, "xn--aroport-bya.ci": true, "int.ci": true, "presse.ci": true, "md.ci": true, "gouv.ci": true, "*.ck": true, "www.ck": false, "cl": true, "gov.cl": true, "gob.cl": true, "co.cl": true, "mil.cl": true, "cm": true, "co.cm": true, "com.cm": true, "gov.cm": true, "net.cm": true, "cn": true, "ac.cn": true, "com.cn": true, "edu.cn": true, "gov.cn": true, "net.cn": true, "org.cn": true, "mil.cn": true, "xn--55qx5d.cn": true, "xn--io0a7i.cn": true, "xn--od0alg.cn": true, "ah.cn": true, "bj.cn": true, "cq.cn": true, "fj.cn": true, "gd.cn": true, "gs.cn": true, "gz.cn": true, "gx.cn": true, "ha.cn": true, "hb.cn": true, "he.cn": true, "hi.cn": true, "hl.cn": true, "hn.cn": true, "jl.cn": true, "js.cn": true, "jx.cn": true, "ln.cn": true, "nm.cn": true, "nx.cn": true, "qh.cn": true, "sc.cn": true, "sd.cn": true, "sh.cn": true, "sn.cn": true, "sx.cn": true, "tj.cn": true, "xj.cn": true, "xz.cn": true, "yn.cn": true, "zj.cn": true, "hk.cn": true, "mo.cn": true, "tw.cn": true, "co": true, "arts.co": true, "com.co": true, "edu.co": true, "firm.co": true, "gov.co": true, "info.co": true, "int.co": true, "mil.co": true, "net.co": true, "nom.co": true, "org.co": true, "rec.co": true, "web.co": true, "com": true, "coop": true, "cr": true, "ac.cr": true, "co.cr": true, "ed.cr": true, "fi.cr": true, "go.cr": true, "or.cr": true, "sa.cr": true, "cu": true, "com.cu": true, "edu.cu": true, "org.cu": true, "net.cu": true, "gov.cu": true, "inf.cu": true, "cv": true, "cw": true, "com.cw": true, "edu.cw": true, "net.cw": true, "org.cw": true, "cx": true, "gov.cx": true, "cy": true, "ac.cy": true, "biz.cy": true, "com.cy": true, "ekloges.cy": true, "gov.cy": true, "ltd.cy": true, "name.cy": true, "net.cy": true, "org.cy": true, "parliament.cy": true, "press.cy": true, "pro.cy": true, "tm.cy": true, "cz": true, "de": true, "dj": true, "dk": true, "dm": true, "com.dm": true, "net.dm": true, "org.dm": true, "edu.dm": true, "gov.dm": true, "do": true, "art.do": true, "com.do": true, "edu.do": true, "gob.do": true, "gov.do": true, "mil.do": true, "net.do": true, "org.do": true, "sld.do": true, "web.do": true, "dz": true, "com.dz": true, "org.dz": true, "net.dz": true, "gov.dz": true, "edu.dz": true, "asso.dz": true, "pol.dz": true, "art.dz": true, "ec": true, "com.ec": true, "info.ec": true, "net.ec": true, "fin.ec": true, "k12.ec": true, "med.ec": true, "pro.ec": true, "org.ec": true, "edu.ec": true, "gov.ec": true, "gob.ec": true, "mil.ec": true, "edu": true, "ee": true, "edu.ee": true, "gov.ee": true, "riik.ee": true, "lib.ee": true, "med.ee": true, "com.ee": true, "pri.ee": true, "aip.ee": true, "org.ee": true, "fie.ee": true, "eg": true, "com.eg": true, "edu.eg": true, "eun.eg": true, "gov.eg": true, "mil.eg": true, "name.eg": true, "net.eg": true, "org.eg": true, "sci.eg": true, "*.er": true, "es": true, "com.es": true, "nom.es": true, "org.es": true, "gob.es": true, "edu.es": true, "et": true, "com.et": true, "gov.et": true, "org.et": true, "edu.et": true, "biz.et": true, "name.et": true, "info.et": true, "net.et": true, "eu": true, "fi": true, "aland.fi": true, "*.fj": true, "*.fk": true, "fm": true, "fo": true, "fr": true, "com.fr": true, "asso.fr": true, "nom.fr": true, "prd.fr": true, "presse.fr": true, "tm.fr": true, "aeroport.fr": true, "assedic.fr": true, "avocat.fr": true, "avoues.fr": true, "cci.fr": true, "chambagri.fr": true, "chirurgiens-dentistes.fr": true, "experts-comptables.fr": true, "geometre-expert.fr": true, "gouv.fr": true, "greta.fr": true, "huissier-justice.fr": true, "medecin.fr": true, "notaires.fr": true, "pharmacien.fr": true, "port.fr": true, "veterinaire.fr": true, "ga": true, "gb": true, "gd": true, "ge": true, "com.ge": true, "edu.ge": true, "gov.ge": true, "org.ge": true, "mil.ge": true, "net.ge": true, "pvt.ge": true, "gf": true, "gg": true, "co.gg": true, "net.gg": true, "org.gg": true, "gh": true, "com.gh": true, "edu.gh": true, "gov.gh": true, "org.gh": true, "mil.gh": true, "gi": true, "com.gi": true, "ltd.gi": true, "gov.gi": true, "mod.gi": true, "edu.gi": true, "org.gi": true, "gl": true, "co.gl": true, "com.gl": true, "edu.gl": true, "net.gl": true, "org.gl": true, "gm": true, "gn": true, "ac.gn": true, "com.gn": true, "edu.gn": true, "gov.gn": true, "org.gn": true, "net.gn": true, "gov": true, "gp": true, "com.gp": true, "net.gp": true, "mobi.gp": true, "edu.gp": true, "org.gp": true, "asso.gp": true, "gq": true, "gr": true, "com.gr": true, "edu.gr": true, "net.gr": true, "org.gr": true, "gov.gr": true, "gs": true, "gt": true, "com.gt": true, "edu.gt": true, "gob.gt": true, "ind.gt": true, "mil.gt": true, "net.gt": true, "org.gt": true, "*.gu": true, "gw": true, "gy": true, "co.gy": true, "com.gy": true, "edu.gy": true, "gov.gy": true, "net.gy": true, "org.gy": true, "hk": true, "com.hk": true, "edu.hk": true, "gov.hk": true, "idv.hk": true, "net.hk": true, "org.hk": true, "xn--55qx5d.hk": true, "xn--wcvs22d.hk": true, "xn--lcvr32d.hk": true, "xn--mxtq1m.hk": true, "xn--gmqw5a.hk": true, "xn--ciqpn.hk": true, "xn--gmq050i.hk": true, "xn--zf0avx.hk": true, "xn--io0a7i.hk": true, "xn--mk0axi.hk": true, "xn--od0alg.hk": true, "xn--od0aq3b.hk": true, "xn--tn0ag.hk": true, "xn--uc0atv.hk": true, "xn--uc0ay4a.hk": true, "hm": true, "hn": true, "com.hn": true, "edu.hn": true, "org.hn": true, "net.hn": true, "mil.hn": true, "gob.hn": true, "hr": true, "iz.hr": true, "from.hr": true, "name.hr": true, "com.hr": true, "ht": true, "com.ht": true, "shop.ht": true, "firm.ht": true, "info.ht": true, "adult.ht": true, "net.ht": true, "pro.ht": true, "org.ht": true, "med.ht": true, "art.ht": true, "coop.ht": true, "pol.ht": true, "asso.ht": true, "edu.ht": true, "rel.ht": true, "gouv.ht": true, "perso.ht": true, "hu": true, "co.hu": true, "info.hu": true, "org.hu": true, "priv.hu": true, "sport.hu": true, "tm.hu": true, "2000.hu": true, "agrar.hu": true, "bolt.hu": true, "casino.hu": true, "city.hu": true, "erotica.hu": true, "erotika.hu": true, "film.hu": true, "forum.hu": true, "games.hu": true, "hotel.hu": true, "ingatlan.hu": true, "jogasz.hu": true, "konyvelo.hu": true, "lakas.hu": true, "media.hu": true, "news.hu": true, "reklam.hu": true, "sex.hu": true, "shop.hu": true, "suli.hu": true, "szex.hu": true, "tozsde.hu": true, "utazas.hu": true, "video.hu": true, "id": true, "ac.id": true, "biz.id": true, "co.id": true, "desa.id": true, "go.id": true, "mil.id": true, "my.id": true, "net.id": true, "or.id": true, "sch.id": true, "web.id": true, "ie": true, "gov.ie": true, "il": true, "ac.il": true, "co.il": true, "gov.il": true, "idf.il": true, "k12.il": true, "muni.il": true, "net.il": true, "org.il": true, "im": true, "ac.im": true, "co.im": true, "com.im": true, "ltd.co.im": true, "net.im": true, "org.im": true, "plc.co.im": true, "tt.im": true, "tv.im": true, "in": true, "co.in": true, "firm.in": true, "net.in": true, "org.in": true, "gen.in": true, "ind.in": true, "nic.in": true, "ac.in": true, "edu.in": true, "res.in": true, "gov.in": true, "mil.in": true, "info": true, "int": true, "eu.int": true, "io": true, "com.io": true, "iq": true, "gov.iq": true, "edu.iq": true, "mil.iq": true, "com.iq": true, "org.iq": true, "net.iq": true, "ir": true, "ac.ir": true, "co.ir": true, "gov.ir": true, "id.ir": true, "net.ir": true, "org.ir": true, "sch.ir": true, "xn--mgba3a4f16a.ir": true, "xn--mgba3a4fra.ir": true, "is": true, "net.is": true, "com.is": true, "edu.is": true, "gov.is": true, "org.is": true, "int.is": true, "it": true, "gov.it": true, "edu.it": true, "abr.it": true, "abruzzo.it": true, "aosta-valley.it": true, "aostavalley.it": true, "bas.it": true, "basilicata.it": true, "cal.it": true, "calabria.it": true, "cam.it": true, "campania.it": true, "emilia-romagna.it": true, "emiliaromagna.it": true, "emr.it": true, "friuli-v-giulia.it": true, "friuli-ve-giulia.it": true, "friuli-vegiulia.it": true, "friuli-venezia-giulia.it": true, "friuli-veneziagiulia.it": true, "friuli-vgiulia.it": true, "friuliv-giulia.it": true, "friulive-giulia.it": true, "friulivegiulia.it": true, "friulivenezia-giulia.it": true, "friuliveneziagiulia.it": true, "friulivgiulia.it": true, "fvg.it": true, "laz.it": true, "lazio.it": true, "lig.it": true, "liguria.it": true, "lom.it": true, "lombardia.it": true, "lombardy.it": true, "lucania.it": true, "mar.it": true, "marche.it": true, "mol.it": true, "molise.it": true, "piedmont.it": true, "piemonte.it": true, "pmn.it": true, "pug.it": true, "puglia.it": true, "sar.it": true, "sardegna.it": true, "sardinia.it": true, "sic.it": true, "sicilia.it": true, "sicily.it": true, "taa.it": true, "tos.it": true, "toscana.it": true, "trentino-a-adige.it": true, "trentino-aadige.it": true, "trentino-alto-adige.it": true, "trentino-altoadige.it": true, "trentino-s-tirol.it": true, "trentino-stirol.it": true, "trentino-sud-tirol.it": true, "trentino-sudtirol.it": true, "trentino-sued-tirol.it": true, "trentino-suedtirol.it": true, "trentinoa-adige.it": true, "trentinoaadige.it": true, "trentinoalto-adige.it": true, "trentinoaltoadige.it": true, "trentinos-tirol.it": true, "trentinostirol.it": true, "trentinosud-tirol.it": true, "trentinosudtirol.it": true, "trentinosued-tirol.it": true, "trentinosuedtirol.it": true, "tuscany.it": true, "umb.it": true, "umbria.it": true, "val-d-aosta.it": true, "val-daosta.it": true, "vald-aosta.it": true, "valdaosta.it": true, "valle-aosta.it": true, "valle-d-aosta.it": true, "valle-daosta.it": true, "valleaosta.it": true, "valled-aosta.it": true, "valledaosta.it": true, "vallee-aoste.it": true, "valleeaoste.it": true, "vao.it": true, "vda.it": true, "ven.it": true, "veneto.it": true, "ag.it": true, "agrigento.it": true, "al.it": true, "alessandria.it": true, "alto-adige.it": true, "altoadige.it": true, "an.it": true, "ancona.it": true, "andria-barletta-trani.it": true, "andria-trani-barletta.it": true, "andriabarlettatrani.it": true, "andriatranibarletta.it": true, "ao.it": true, "aosta.it": true, "aoste.it": true, "ap.it": true, "aq.it": true, "aquila.it": true, "ar.it": true, "arezzo.it": true, "ascoli-piceno.it": true, "ascolipiceno.it": true, "asti.it": true, "at.it": true, "av.it": true, "avellino.it": true, "ba.it": true, "balsan.it": true, "bari.it": true, "barletta-trani-andria.it": true, "barlettatraniandria.it": true, "belluno.it": true, "benevento.it": true, "bergamo.it": true, "bg.it": true, "bi.it": true, "biella.it": true, "bl.it": true, "bn.it": true, "bo.it": true, "bologna.it": true, "bolzano.it": true, "bozen.it": true, "br.it": true, "brescia.it": true, "brindisi.it": true, "bs.it": true, "bt.it": true, "bz.it": true, "ca.it": true, "cagliari.it": true, "caltanissetta.it": true, "campidano-medio.it": true, "campidanomedio.it": true, "campobasso.it": true, "carbonia-iglesias.it": true, "carboniaiglesias.it": true, "carrara-massa.it": true, "carraramassa.it": true, "caserta.it": true, "catania.it": true, "catanzaro.it": true, "cb.it": true, "ce.it": true, "cesena-forli.it": true, "cesenaforli.it": true, "ch.it": true, "chieti.it": true, "ci.it": true, "cl.it": true, "cn.it": true, "co.it": true, "como.it": true, "cosenza.it": true, "cr.it": true, "cremona.it": true, "crotone.it": true, "cs.it": true, "ct.it": true, "cuneo.it": true, "cz.it": true, "dell-ogliastra.it": true, "dellogliastra.it": true, "en.it": true, "enna.it": true, "fc.it": true, "fe.it": true, "fermo.it": true, "ferrara.it": true, "fg.it": true, "fi.it": true, "firenze.it": true, "florence.it": true, "fm.it": true, "foggia.it": true, "forli-cesena.it": true, "forlicesena.it": true, "fr.it": true, "frosinone.it": true, "ge.it": true, "genoa.it": true, "genova.it": true, "go.it": true, "gorizia.it": true, "gr.it": true, "grosseto.it": true, "iglesias-carbonia.it": true, "iglesiascarbonia.it": true, "im.it": true, "imperia.it": true, "is.it": true, "isernia.it": true, "kr.it": true, "la-spezia.it": true, "laquila.it": true, "laspezia.it": true, "latina.it": true, "lc.it": true, "le.it": true, "lecce.it": true, "lecco.it": true, "li.it": true, "livorno.it": true, "lo.it": true, "lodi.it": true, "lt.it": true, "lu.it": true, "lucca.it": true, "macerata.it": true, "mantova.it": true, "massa-carrara.it": true, "massacarrara.it": true, "matera.it": true, "mb.it": true, "mc.it": true, "me.it": true, "medio-campidano.it": true, "mediocampidano.it": true, "messina.it": true, "mi.it": true, "milan.it": true, "milano.it": true, "mn.it": true, "mo.it": true, "modena.it": true, "monza-brianza.it": true, "monza-e-della-brianza.it": true, "monza.it": true, "monzabrianza.it": true, "monzaebrianza.it": true, "monzaedellabrianza.it": true, "ms.it": true, "mt.it": true, "na.it": true, "naples.it": true, "napoli.it": true, "no.it": true, "novara.it": true, "nu.it": true, "nuoro.it": true, "og.it": true, "ogliastra.it": true, "olbia-tempio.it": true, "olbiatempio.it": true, "or.it": true, "oristano.it": true, "ot.it": true, "pa.it": true, "padova.it": true, "padua.it": true, "palermo.it": true, "parma.it": true, "pavia.it": true, "pc.it": true, "pd.it": true, "pe.it": true, "perugia.it": true, "pesaro-urbino.it": true, "pesarourbino.it": true, "pescara.it": true, "pg.it": true, "pi.it": true, "piacenza.it": true, "pisa.it": true, "pistoia.it": true, "pn.it": true, "po.it": true, "pordenone.it": true, "potenza.it": true, "pr.it": true, "prato.it": true, "pt.it": true, "pu.it": true, "pv.it": true, "pz.it": true, "ra.it": true, "ragusa.it": true, "ravenna.it": true, "rc.it": true, "re.it": true, "reggio-calabria.it": true, "reggio-emilia.it": true, "reggiocalabria.it": true, "reggioemilia.it": true, "rg.it": true, "ri.it": true, "rieti.it": true, "rimini.it": true, "rm.it": true, "rn.it": true, "ro.it": true, "roma.it": true, "rome.it": true, "rovigo.it": true, "sa.it": true, "salerno.it": true, "sassari.it": true, "savona.it": true, "si.it": true, "siena.it": true, "siracusa.it": true, "so.it": true, "sondrio.it": true, "sp.it": true, "sr.it": true, "ss.it": true, "suedtirol.it": true, "sv.it": true, "ta.it": true, "taranto.it": true, "te.it": true, "tempio-olbia.it": true, "tempioolbia.it": true, "teramo.it": true, "terni.it": true, "tn.it": true, "to.it": true, "torino.it": true, "tp.it": true, "tr.it": true, "trani-andria-barletta.it": true, "trani-barletta-andria.it": true, "traniandriabarletta.it": true, "tranibarlettaandria.it": true, "trapani.it": true, "trentino.it": true, "trento.it": true, "treviso.it": true, "trieste.it": true, "ts.it": true, "turin.it": true, "tv.it": true, "ud.it": true, "udine.it": true, "urbino-pesaro.it": true, "urbinopesaro.it": true, "va.it": true, "varese.it": true, "vb.it": true, "vc.it": true, "ve.it": true, "venezia.it": true, "venice.it": true, "verbania.it": true, "vercelli.it": true, "verona.it": true, "vi.it": true, "vibo-valentia.it": true, "vibovalentia.it": true, "vicenza.it": true, "viterbo.it": true, "vr.it": true, "vs.it": true, "vt.it": true, "vv.it": true, "je": true, "co.je": true, "net.je": true, "org.je": true, "*.jm": true, "jo": true, "com.jo": true, "org.jo": true, "net.jo": true, "edu.jo": true, "sch.jo": true, "gov.jo": true, "mil.jo": true, "name.jo": true, "jobs": true, "jp": true, "ac.jp": true, "ad.jp": true, "co.jp": true, "ed.jp": true, "go.jp": true, "gr.jp": true, "lg.jp": true, "ne.jp": true, "or.jp": true, "aichi.jp": true, "akita.jp": true, "aomori.jp": true, "chiba.jp": true, "ehime.jp": true, "fukui.jp": true, "fukuoka.jp": true, "fukushima.jp": true, "gifu.jp": true, "gunma.jp": true, "hiroshima.jp": true, "hokkaido.jp": true, "hyogo.jp": true, "ibaraki.jp": true, "ishikawa.jp": true, "iwate.jp": true, "kagawa.jp": true, "kagoshima.jp": true, "kanagawa.jp": true, "kochi.jp": true, "kumamoto.jp": true, "kyoto.jp": true, "mie.jp": true, "miyagi.jp": true, "miyazaki.jp": true, "nagano.jp": true, "nagasaki.jp": true, "nara.jp": true, "niigata.jp": true, "oita.jp": true, "okayama.jp": true, "okinawa.jp": true, "osaka.jp": true, "saga.jp": true, "saitama.jp": true, "shiga.jp": true, "shimane.jp": true, "shizuoka.jp": true, "tochigi.jp": true, "tokushima.jp": true, "tokyo.jp": true, "tottori.jp": true, "toyama.jp": true, "wakayama.jp": true, "yamagata.jp": true, "yamaguchi.jp": true, "yamanashi.jp": true, "xn--4pvxs.jp": true, "xn--vgu402c.jp": true, "xn--c3s14m.jp": true, "xn--f6qx53a.jp": true, "xn--8pvr4u.jp": true, "xn--uist22h.jp": true, "xn--djrs72d6uy.jp": true, "xn--mkru45i.jp": true, "xn--0trq7p7nn.jp": true, "xn--8ltr62k.jp": true, "xn--2m4a15e.jp": true, "xn--efvn9s.jp": true, "xn--32vp30h.jp": true, "xn--4it797k.jp": true, "xn--1lqs71d.jp": true, "xn--5rtp49c.jp": true, "xn--5js045d.jp": true, "xn--ehqz56n.jp": true, "xn--1lqs03n.jp": true, "xn--qqqt11m.jp": true, "xn--kbrq7o.jp": true, "xn--pssu33l.jp": true, "xn--ntsq17g.jp": true, "xn--uisz3g.jp": true, "xn--6btw5a.jp": true, "xn--1ctwo.jp": true, "xn--6orx2r.jp": true, "xn--rht61e.jp": true, "xn--rht27z.jp": true, "xn--djty4k.jp": true, "xn--nit225k.jp": true, "xn--rht3d.jp": true, "xn--klty5x.jp": true, "xn--kltx9a.jp": true, "xn--kltp7d.jp": true, "xn--uuwu58a.jp": true, "xn--zbx025d.jp": true, "xn--ntso0iqx3a.jp": true, "xn--elqq16h.jp": true, "xn--4it168d.jp": true, "xn--klt787d.jp": true, "xn--rny31h.jp": true, "xn--7t0a264c.jp": true, "xn--5rtq34k.jp": true, "xn--k7yn95e.jp": true, "xn--tor131o.jp": true, "xn--d5qv7z876c.jp": true, "*.kawasaki.jp": true, "*.kitakyushu.jp": true, "*.kobe.jp": true, "*.nagoya.jp": true, "*.sapporo.jp": true, "*.sendai.jp": true, "*.yokohama.jp": true, "city.kawasaki.jp": false, "city.kitakyushu.jp": false, "city.kobe.jp": false, "city.nagoya.jp": false, "city.sapporo.jp": false, "city.sendai.jp": false, "city.yokohama.jp": false, "aisai.aichi.jp": true, "ama.aichi.jp": true, "anjo.aichi.jp": true, "asuke.aichi.jp": true, "chiryu.aichi.jp": true, "chita.aichi.jp": true, "fuso.aichi.jp": true, "gamagori.aichi.jp": true, "handa.aichi.jp": true, "hazu.aichi.jp": true, "hekinan.aichi.jp": true, "higashiura.aichi.jp": true, "ichinomiya.aichi.jp": true, "inazawa.aichi.jp": true, "inuyama.aichi.jp": true, "isshiki.aichi.jp": true, "iwakura.aichi.jp": true, "kanie.aichi.jp": true, "kariya.aichi.jp": true, "kasugai.aichi.jp": true, "kira.aichi.jp": true, "kiyosu.aichi.jp": true, "komaki.aichi.jp": true, "konan.aichi.jp": true, "kota.aichi.jp": true, "mihama.aichi.jp": true, "miyoshi.aichi.jp": true, "nishio.aichi.jp": true, "nisshin.aichi.jp": true, "obu.aichi.jp": true, "oguchi.aichi.jp": true, "oharu.aichi.jp": true, "okazaki.aichi.jp": true, "owariasahi.aichi.jp": true, "seto.aichi.jp": true, "shikatsu.aichi.jp": true, "shinshiro.aichi.jp": true, "shitara.aichi.jp": true, "tahara.aichi.jp": true, "takahama.aichi.jp": true, "tobishima.aichi.jp": true, "toei.aichi.jp": true, "togo.aichi.jp": true, "tokai.aichi.jp": true, "tokoname.aichi.jp": true, "toyoake.aichi.jp": true, "toyohashi.aichi.jp": true, "toyokawa.aichi.jp": true, "toyone.aichi.jp": true, "toyota.aichi.jp": true, "tsushima.aichi.jp": true, "yatomi.aichi.jp": true, "akita.akita.jp": true, "daisen.akita.jp": true, "fujisato.akita.jp": true, "gojome.akita.jp": true, "hachirogata.akita.jp": true, "happou.akita.jp": true, "higashinaruse.akita.jp": true, "honjo.akita.jp": true, "honjyo.akita.jp": true, "ikawa.akita.jp": true, "kamikoani.akita.jp": true, "kamioka.akita.jp": true, "katagami.akita.jp": true, "kazuno.akita.jp": true, "kitaakita.akita.jp": true, "kosaka.akita.jp": true, "kyowa.akita.jp": true, "misato.akita.jp": true, "mitane.akita.jp": true, "moriyoshi.akita.jp": true, "nikaho.akita.jp": true, "noshiro.akita.jp": true, "odate.akita.jp": true, "oga.akita.jp": true, "ogata.akita.jp": true, "semboku.akita.jp": true, "yokote.akita.jp": true, "yurihonjo.akita.jp": true, "aomori.aomori.jp": true, "gonohe.aomori.jp": true, "hachinohe.aomori.jp": true, "hashikami.aomori.jp": true, "hiranai.aomori.jp": true, "hirosaki.aomori.jp": true, "itayanagi.aomori.jp": true, "kuroishi.aomori.jp": true, "misawa.aomori.jp": true, "mutsu.aomori.jp": true, "nakadomari.aomori.jp": true, "noheji.aomori.jp": true, "oirase.aomori.jp": true, "owani.aomori.jp": true, "rokunohe.aomori.jp": true, "sannohe.aomori.jp": true, "shichinohe.aomori.jp": true, "shingo.aomori.jp": true, "takko.aomori.jp": true, "towada.aomori.jp": true, "tsugaru.aomori.jp": true, "tsuruta.aomori.jp": true, "abiko.chiba.jp": true, "asahi.chiba.jp": true, "chonan.chiba.jp": true, "chosei.chiba.jp": true, "choshi.chiba.jp": true, "chuo.chiba.jp": true, "funabashi.chiba.jp": true, "futtsu.chiba.jp": true, "hanamigawa.chiba.jp": true, "ichihara.chiba.jp": true, "ichikawa.chiba.jp": true, "ichinomiya.chiba.jp": true, "inzai.chiba.jp": true, "isumi.chiba.jp": true, "kamagaya.chiba.jp": true, "kamogawa.chiba.jp": true, "kashiwa.chiba.jp": true, "katori.chiba.jp": true, "katsuura.chiba.jp": true, "kimitsu.chiba.jp": true, "kisarazu.chiba.jp": true, "kozaki.chiba.jp": true, "kujukuri.chiba.jp": true, "kyonan.chiba.jp": true, "matsudo.chiba.jp": true, "midori.chiba.jp": true, "mihama.chiba.jp": true, "minamiboso.chiba.jp": true, "mobara.chiba.jp": true, "mutsuzawa.chiba.jp": true, "nagara.chiba.jp": true, "nagareyama.chiba.jp": true, "narashino.chiba.jp": true, "narita.chiba.jp": true, "noda.chiba.jp": true, "oamishirasato.chiba.jp": true, "omigawa.chiba.jp": true, "onjuku.chiba.jp": true, "otaki.chiba.jp": true, "sakae.chiba.jp": true, "sakura.chiba.jp": true, "shimofusa.chiba.jp": true, "shirako.chiba.jp": true, "shiroi.chiba.jp": true, "shisui.chiba.jp": true, "sodegaura.chiba.jp": true, "sosa.chiba.jp": true, "tako.chiba.jp": true, "tateyama.chiba.jp": true, "togane.chiba.jp": true, "tohnosho.chiba.jp": true, "tomisato.chiba.jp": true, "urayasu.chiba.jp": true, "yachimata.chiba.jp": true, "yachiyo.chiba.jp": true, "yokaichiba.chiba.jp": true, "yokoshibahikari.chiba.jp": true, "yotsukaido.chiba.jp": true, "ainan.ehime.jp": true, "honai.ehime.jp": true, "ikata.ehime.jp": true, "imabari.ehime.jp": true, "iyo.ehime.jp": true, "kamijima.ehime.jp": true, "kihoku.ehime.jp": true, "kumakogen.ehime.jp": true, "masaki.ehime.jp": true, "matsuno.ehime.jp": true, "matsuyama.ehime.jp": true, "namikata.ehime.jp": true, "niihama.ehime.jp": true, "ozu.ehime.jp": true, "saijo.ehime.jp": true, "seiyo.ehime.jp": true, "shikokuchuo.ehime.jp": true, "tobe.ehime.jp": true, "toon.ehime.jp": true, "uchiko.ehime.jp": true, "uwajima.ehime.jp": true, "yawatahama.ehime.jp": true, "echizen.fukui.jp": true, "eiheiji.fukui.jp": true, "fukui.fukui.jp": true, "ikeda.fukui.jp": true, "katsuyama.fukui.jp": true, "mihama.fukui.jp": true, "minamiechizen.fukui.jp": true, "obama.fukui.jp": true, "ohi.fukui.jp": true, "ono.fukui.jp": true, "sabae.fukui.jp": true, "sakai.fukui.jp": true, "takahama.fukui.jp": true, "tsuruga.fukui.jp": true, "wakasa.fukui.jp": true, "ashiya.fukuoka.jp": true, "buzen.fukuoka.jp": true, "chikugo.fukuoka.jp": true, "chikuho.fukuoka.jp": true, "chikujo.fukuoka.jp": true, "chikushino.fukuoka.jp": true, "chikuzen.fukuoka.jp": true, "chuo.fukuoka.jp": true, "dazaifu.fukuoka.jp": true, "fukuchi.fukuoka.jp": true, "hakata.fukuoka.jp": true, "higashi.fukuoka.jp": true, "hirokawa.fukuoka.jp": true, "hisayama.fukuoka.jp": true, "iizuka.fukuoka.jp": true, "inatsuki.fukuoka.jp": true, "kaho.fukuoka.jp": true, "kasuga.fukuoka.jp": true, "kasuya.fukuoka.jp": true, "kawara.fukuoka.jp": true, "keisen.fukuoka.jp": true, "koga.fukuoka.jp": true, "kurate.fukuoka.jp": true, "kurogi.fukuoka.jp": true, "kurume.fukuoka.jp": true, "minami.fukuoka.jp": true, "miyako.fukuoka.jp": true, "miyama.fukuoka.jp": true, "miyawaka.fukuoka.jp": true, "mizumaki.fukuoka.jp": true, "munakata.fukuoka.jp": true, "nakagawa.fukuoka.jp": true, "nakama.fukuoka.jp": true, "nishi.fukuoka.jp": true, "nogata.fukuoka.jp": true, "ogori.fukuoka.jp": true, "okagaki.fukuoka.jp": true, "okawa.fukuoka.jp": true, "oki.fukuoka.jp": true, "omuta.fukuoka.jp": true, "onga.fukuoka.jp": true, "onojo.fukuoka.jp": true, "oto.fukuoka.jp": true, "saigawa.fukuoka.jp": true, "sasaguri.fukuoka.jp": true, "shingu.fukuoka.jp": true, "shinyoshitomi.fukuoka.jp": true, "shonai.fukuoka.jp": true, "soeda.fukuoka.jp": true, "sue.fukuoka.jp": true, "tachiarai.fukuoka.jp": true, "tagawa.fukuoka.jp": true, "takata.fukuoka.jp": true, "toho.fukuoka.jp": true, "toyotsu.fukuoka.jp": true, "tsuiki.fukuoka.jp": true, "ukiha.fukuoka.jp": true, "umi.fukuoka.jp": true, "usui.fukuoka.jp": true, "yamada.fukuoka.jp": true, "yame.fukuoka.jp": true, "yanagawa.fukuoka.jp": true, "yukuhashi.fukuoka.jp": true, "aizubange.fukushima.jp": true, "aizumisato.fukushima.jp": true, "aizuwakamatsu.fukushima.jp": true, "asakawa.fukushima.jp": true, "bandai.fukushima.jp": true, "date.fukushima.jp": true, "fukushima.fukushima.jp": true, "furudono.fukushima.jp": true, "futaba.fukushima.jp": true, "hanawa.fukushima.jp": true, "higashi.fukushima.jp": true, "hirata.fukushima.jp": true, "hirono.fukushima.jp": true, "iitate.fukushima.jp": true, "inawashiro.fukushima.jp": true, "ishikawa.fukushima.jp": true, "iwaki.fukushima.jp": true, "izumizaki.fukushima.jp": true, "kagamiishi.fukushima.jp": true, "kaneyama.fukushima.jp": true, "kawamata.fukushima.jp": true, "kitakata.fukushima.jp": true, "kitashiobara.fukushima.jp": true, "koori.fukushima.jp": true, "koriyama.fukushima.jp": true, "kunimi.fukushima.jp": true, "miharu.fukushima.jp": true, "mishima.fukushima.jp": true, "namie.fukushima.jp": true, "nango.fukushima.jp": true, "nishiaizu.fukushima.jp": true, "nishigo.fukushima.jp": true, "okuma.fukushima.jp": true, "omotego.fukushima.jp": true, "ono.fukushima.jp": true, "otama.fukushima.jp": true, "samegawa.fukushima.jp": true, "shimogo.fukushima.jp": true, "shirakawa.fukushima.jp": true, "showa.fukushima.jp": true, "soma.fukushima.jp": true, "sukagawa.fukushima.jp": true, "taishin.fukushima.jp": true, "tamakawa.fukushima.jp": true, "tanagura.fukushima.jp": true, "tenei.fukushima.jp": true, "yabuki.fukushima.jp": true, "yamato.fukushima.jp": true, "yamatsuri.fukushima.jp": true, "yanaizu.fukushima.jp": true, "yugawa.fukushima.jp": true, "anpachi.gifu.jp": true, "ena.gifu.jp": true, "gifu.gifu.jp": true, "ginan.gifu.jp": true, "godo.gifu.jp": true, "gujo.gifu.jp": true, "hashima.gifu.jp": true, "hichiso.gifu.jp": true, "hida.gifu.jp": true, "higashishirakawa.gifu.jp": true, "ibigawa.gifu.jp": true, "ikeda.gifu.jp": true, "kakamigahara.gifu.jp": true, "kani.gifu.jp": true, "kasahara.gifu.jp": true, "kasamatsu.gifu.jp": true, "kawaue.gifu.jp": true, "kitagata.gifu.jp": true, "mino.gifu.jp": true, "minokamo.gifu.jp": true, "mitake.gifu.jp": true, "mizunami.gifu.jp": true, "motosu.gifu.jp": true, "nakatsugawa.gifu.jp": true, "ogaki.gifu.jp": true, "sakahogi.gifu.jp": true, "seki.gifu.jp": true, "sekigahara.gifu.jp": true, "shirakawa.gifu.jp": true, "tajimi.gifu.jp": true, "takayama.gifu.jp": true, "tarui.gifu.jp": true, "toki.gifu.jp": true, "tomika.gifu.jp": true, "wanouchi.gifu.jp": true, "yamagata.gifu.jp": true, "yaotsu.gifu.jp": true, "yoro.gifu.jp": true, "annaka.gunma.jp": true, "chiyoda.gunma.jp": true, "fujioka.gunma.jp": true, "higashiagatsuma.gunma.jp": true, "isesaki.gunma.jp": true, "itakura.gunma.jp": true, "kanna.gunma.jp": true, "kanra.gunma.jp": true, "katashina.gunma.jp": true, "kawaba.gunma.jp": true, "kiryu.gunma.jp": true, "kusatsu.gunma.jp": true, "maebashi.gunma.jp": true, "meiwa.gunma.jp": true, "midori.gunma.jp": true, "minakami.gunma.jp": true, "naganohara.gunma.jp": true, "nakanojo.gunma.jp": true, "nanmoku.gunma.jp": true, "numata.gunma.jp": true, "oizumi.gunma.jp": true, "ora.gunma.jp": true, "ota.gunma.jp": true, "shibukawa.gunma.jp": true, "shimonita.gunma.jp": true, "shinto.gunma.jp": true, "showa.gunma.jp": true, "takasaki.gunma.jp": true, "takayama.gunma.jp": true, "tamamura.gunma.jp": true, "tatebayashi.gunma.jp": true, "tomioka.gunma.jp": true, "tsukiyono.gunma.jp": true, "tsumagoi.gunma.jp": true, "ueno.gunma.jp": true, "yoshioka.gunma.jp": true, "asaminami.hiroshima.jp": true, "daiwa.hiroshima.jp": true, "etajima.hiroshima.jp": true, "fuchu.hiroshima.jp": true, "fukuyama.hiroshima.jp": true, "hatsukaichi.hiroshima.jp": true, "higashihiroshima.hiroshima.jp": true, "hongo.hiroshima.jp": true, "jinsekikogen.hiroshima.jp": true, "kaita.hiroshima.jp": true, "kui.hiroshima.jp": true, "kumano.hiroshima.jp": true, "kure.hiroshima.jp": true, "mihara.hiroshima.jp": true, "miyoshi.hiroshima.jp": true, "naka.hiroshima.jp": true, "onomichi.hiroshima.jp": true, "osakikamijima.hiroshima.jp": true, "otake.hiroshima.jp": true, "saka.hiroshima.jp": true, "sera.hiroshima.jp": true, "seranishi.hiroshima.jp": true, "shinichi.hiroshima.jp": true, "shobara.hiroshima.jp": true, "takehara.hiroshima.jp": true, "abashiri.hokkaido.jp": true, "abira.hokkaido.jp": true, "aibetsu.hokkaido.jp": true, "akabira.hokkaido.jp": true, "akkeshi.hokkaido.jp": true, "asahikawa.hokkaido.jp": true, "ashibetsu.hokkaido.jp": true, "ashoro.hokkaido.jp": true, "assabu.hokkaido.jp": true, "atsuma.hokkaido.jp": true, "bibai.hokkaido.jp": true, "biei.hokkaido.jp": true, "bifuka.hokkaido.jp": true, "bihoro.hokkaido.jp": true, "biratori.hokkaido.jp": true, "chippubetsu.hokkaido.jp": true, "chitose.hokkaido.jp": true, "date.hokkaido.jp": true, "ebetsu.hokkaido.jp": true, "embetsu.hokkaido.jp": true, "eniwa.hokkaido.jp": true, "erimo.hokkaido.jp": true, "esan.hokkaido.jp": true, "esashi.hokkaido.jp": true, "fukagawa.hokkaido.jp": true, "fukushima.hokkaido.jp": true, "furano.hokkaido.jp": true, "furubira.hokkaido.jp": true, "haboro.hokkaido.jp": true, "hakodate.hokkaido.jp": true, "hamatonbetsu.hokkaido.jp": true, "hidaka.hokkaido.jp": true, "higashikagura.hokkaido.jp": true, "higashikawa.hokkaido.jp": true, "hiroo.hokkaido.jp": true, "hokuryu.hokkaido.jp": true, "hokuto.hokkaido.jp": true, "honbetsu.hokkaido.jp": true, "horokanai.hokkaido.jp": true, "horonobe.hokkaido.jp": true, "ikeda.hokkaido.jp": true, "imakane.hokkaido.jp": true, "ishikari.hokkaido.jp": true, "iwamizawa.hokkaido.jp": true, "iwanai.hokkaido.jp": true, "kamifurano.hokkaido.jp": true, "kamikawa.hokkaido.jp": true, "kamishihoro.hokkaido.jp": true, "kamisunagawa.hokkaido.jp": true, "kamoenai.hokkaido.jp": true, "kayabe.hokkaido.jp": true, "kembuchi.hokkaido.jp": true, "kikonai.hokkaido.jp": true, "kimobetsu.hokkaido.jp": true, "kitahiroshima.hokkaido.jp": true, "kitami.hokkaido.jp": true, "kiyosato.hokkaido.jp": true, "koshimizu.hokkaido.jp": true, "kunneppu.hokkaido.jp": true, "kuriyama.hokkaido.jp": true, "kuromatsunai.hokkaido.jp": true, "kushiro.hokkaido.jp": true, "kutchan.hokkaido.jp": true, "kyowa.hokkaido.jp": true, "mashike.hokkaido.jp": true, "matsumae.hokkaido.jp": true, "mikasa.hokkaido.jp": true, "minamifurano.hokkaido.jp": true, "mombetsu.hokkaido.jp": true, "moseushi.hokkaido.jp": true, "mukawa.hokkaido.jp": true, "muroran.hokkaido.jp": true, "naie.hokkaido.jp": true, "nakagawa.hokkaido.jp": true, "nakasatsunai.hokkaido.jp": true, "nakatombetsu.hokkaido.jp": true, "nanae.hokkaido.jp": true, "nanporo.hokkaido.jp": true, "nayoro.hokkaido.jp": true, "nemuro.hokkaido.jp": true, "niikappu.hokkaido.jp": true, "niki.hokkaido.jp": true, "nishiokoppe.hokkaido.jp": true, "noboribetsu.hokkaido.jp": true, "numata.hokkaido.jp": true, "obihiro.hokkaido.jp": true, "obira.hokkaido.jp": true, "oketo.hokkaido.jp": true, "okoppe.hokkaido.jp": true, "otaru.hokkaido.jp": true, "otobe.hokkaido.jp": true, "otofuke.hokkaido.jp": true, "otoineppu.hokkaido.jp": true, "oumu.hokkaido.jp": true, "ozora.hokkaido.jp": true, "pippu.hokkaido.jp": true, "rankoshi.hokkaido.jp": true, "rebun.hokkaido.jp": true, "rikubetsu.hokkaido.jp": true, "rishiri.hokkaido.jp": true, "rishirifuji.hokkaido.jp": true, "saroma.hokkaido.jp": true, "sarufutsu.hokkaido.jp": true, "shakotan.hokkaido.jp": true, "shari.hokkaido.jp": true, "shibecha.hokkaido.jp": true, "shibetsu.hokkaido.jp": true, "shikabe.hokkaido.jp": true, "shikaoi.hokkaido.jp": true, "shimamaki.hokkaido.jp": true, "shimizu.hokkaido.jp": true, "shimokawa.hokkaido.jp": true, "shinshinotsu.hokkaido.jp": true, "shintoku.hokkaido.jp": true, "shiranuka.hokkaido.jp": true, "shiraoi.hokkaido.jp": true, "shiriuchi.hokkaido.jp": true, "sobetsu.hokkaido.jp": true, "sunagawa.hokkaido.jp": true, "taiki.hokkaido.jp": true, "takasu.hokkaido.jp": true, "takikawa.hokkaido.jp": true, "takinoue.hokkaido.jp": true, "teshikaga.hokkaido.jp": true, "tobetsu.hokkaido.jp": true, "tohma.hokkaido.jp": true, "tomakomai.hokkaido.jp": true, "tomari.hokkaido.jp": true, "toya.hokkaido.jp": true, "toyako.hokkaido.jp": true, "toyotomi.hokkaido.jp": true, "toyoura.hokkaido.jp": true, "tsubetsu.hokkaido.jp": true, "tsukigata.hokkaido.jp": true, "urakawa.hokkaido.jp": true, "urausu.hokkaido.jp": true, "uryu.hokkaido.jp": true, "utashinai.hokkaido.jp": true, "wakkanai.hokkaido.jp": true, "wassamu.hokkaido.jp": true, "yakumo.hokkaido.jp": true, "yoichi.hokkaido.jp": true, "aioi.hyogo.jp": true, "akashi.hyogo.jp": true, "ako.hyogo.jp": true, "amagasaki.hyogo.jp": true, "aogaki.hyogo.jp": true, "asago.hyogo.jp": true, "ashiya.hyogo.jp": true, "awaji.hyogo.jp": true, "fukusaki.hyogo.jp": true, "goshiki.hyogo.jp": true, "harima.hyogo.jp": true, "himeji.hyogo.jp": true, "ichikawa.hyogo.jp": true, "inagawa.hyogo.jp": true, "itami.hyogo.jp": true, "kakogawa.hyogo.jp": true, "kamigori.hyogo.jp": true, "kamikawa.hyogo.jp": true, "kasai.hyogo.jp": true, "kasuga.hyogo.jp": true, "kawanishi.hyogo.jp": true, "miki.hyogo.jp": true, "minamiawaji.hyogo.jp": true, "nishinomiya.hyogo.jp": true, "nishiwaki.hyogo.jp": true, "ono.hyogo.jp": true, "sanda.hyogo.jp": true, "sannan.hyogo.jp": true, "sasayama.hyogo.jp": true, "sayo.hyogo.jp": true, "shingu.hyogo.jp": true, "shinonsen.hyogo.jp": true, "shiso.hyogo.jp": true, "sumoto.hyogo.jp": true, "taishi.hyogo.jp": true, "taka.hyogo.jp": true, "takarazuka.hyogo.jp": true, "takasago.hyogo.jp": true, "takino.hyogo.jp": true, "tamba.hyogo.jp": true, "tatsuno.hyogo.jp": true, "toyooka.hyogo.jp": true, "yabu.hyogo.jp": true, "yashiro.hyogo.jp": true, "yoka.hyogo.jp": true, "yokawa.hyogo.jp": true, "ami.ibaraki.jp": true, "asahi.ibaraki.jp": true, "bando.ibaraki.jp": true, "chikusei.ibaraki.jp": true, "daigo.ibaraki.jp": true, "fujishiro.ibaraki.jp": true, "hitachi.ibaraki.jp": true, "hitachinaka.ibaraki.jp": true, "hitachiomiya.ibaraki.jp": true, "hitachiota.ibaraki.jp": true, "ibaraki.ibaraki.jp": true, "ina.ibaraki.jp": true, "inashiki.ibaraki.jp": true, "itako.ibaraki.jp": true, "iwama.ibaraki.jp": true, "joso.ibaraki.jp": true, "kamisu.ibaraki.jp": true, "kasama.ibaraki.jp": true, "kashima.ibaraki.jp": true, "kasumigaura.ibaraki.jp": true, "koga.ibaraki.jp": true, "miho.ibaraki.jp": true, "mito.ibaraki.jp": true, "moriya.ibaraki.jp": true, "naka.ibaraki.jp": true, "namegata.ibaraki.jp": true, "oarai.ibaraki.jp": true, "ogawa.ibaraki.jp": true, "omitama.ibaraki.jp": true, "ryugasaki.ibaraki.jp": true, "sakai.ibaraki.jp": true, "sakuragawa.ibaraki.jp": true, "shimodate.ibaraki.jp": true, "shimotsuma.ibaraki.jp": true, "shirosato.ibaraki.jp": true, "sowa.ibaraki.jp": true, "suifu.ibaraki.jp": true, "takahagi.ibaraki.jp": true, "tamatsukuri.ibaraki.jp": true, "tokai.ibaraki.jp": true, "tomobe.ibaraki.jp": true, "tone.ibaraki.jp": true, "toride.ibaraki.jp": true, "tsuchiura.ibaraki.jp": true, "tsukuba.ibaraki.jp": true, "uchihara.ibaraki.jp": true, "ushiku.ibaraki.jp": true, "yachiyo.ibaraki.jp": true, "yamagata.ibaraki.jp": true, "yawara.ibaraki.jp": true, "yuki.ibaraki.jp": true, "anamizu.ishikawa.jp": true, "hakui.ishikawa.jp": true, "hakusan.ishikawa.jp": true, "kaga.ishikawa.jp": true, "kahoku.ishikawa.jp": true, "kanazawa.ishikawa.jp": true, "kawakita.ishikawa.jp": true, "komatsu.ishikawa.jp": true, "nakanoto.ishikawa.jp": true, "nanao.ishikawa.jp": true, "nomi.ishikawa.jp": true, "nonoichi.ishikawa.jp": true, "noto.ishikawa.jp": true, "shika.ishikawa.jp": true, "suzu.ishikawa.jp": true, "tsubata.ishikawa.jp": true, "tsurugi.ishikawa.jp": true, "uchinada.ishikawa.jp": true, "wajima.ishikawa.jp": true, "fudai.iwate.jp": true, "fujisawa.iwate.jp": true, "hanamaki.iwate.jp": true, "hiraizumi.iwate.jp": true, "hirono.iwate.jp": true, "ichinohe.iwate.jp": true, "ichinoseki.iwate.jp": true, "iwaizumi.iwate.jp": true, "iwate.iwate.jp": true, "joboji.iwate.jp": true, "kamaishi.iwate.jp": true, "kanegasaki.iwate.jp": true, "karumai.iwate.jp": true, "kawai.iwate.jp": true, "kitakami.iwate.jp": true, "kuji.iwate.jp": true, "kunohe.iwate.jp": true, "kuzumaki.iwate.jp": true, "miyako.iwate.jp": true, "mizusawa.iwate.jp": true, "morioka.iwate.jp": true, "ninohe.iwate.jp": true, "noda.iwate.jp": true, "ofunato.iwate.jp": true, "oshu.iwate.jp": true, "otsuchi.iwate.jp": true, "rikuzentakata.iwate.jp": true, "shiwa.iwate.jp": true, "shizukuishi.iwate.jp": true, "sumita.iwate.jp": true, "tanohata.iwate.jp": true, "tono.iwate.jp": true, "yahaba.iwate.jp": true, "yamada.iwate.jp": true, "ayagawa.kagawa.jp": true, "higashikagawa.kagawa.jp": true, "kanonji.kagawa.jp": true, "kotohira.kagawa.jp": true, "manno.kagawa.jp": true, "marugame.kagawa.jp": true, "mitoyo.kagawa.jp": true, "naoshima.kagawa.jp": true, "sanuki.kagawa.jp": true, "tadotsu.kagawa.jp": true, "takamatsu.kagawa.jp": true, "tonosho.kagawa.jp": true, "uchinomi.kagawa.jp": true, "utazu.kagawa.jp": true, "zentsuji.kagawa.jp": true, "akune.kagoshima.jp": true, "amami.kagoshima.jp": true, "hioki.kagoshima.jp": true, "isa.kagoshima.jp": true, "isen.kagoshima.jp": true, "izumi.kagoshima.jp": true, "kagoshima.kagoshima.jp": true, "kanoya.kagoshima.jp": true, "kawanabe.kagoshima.jp": true, "kinko.kagoshima.jp": true, "kouyama.kagoshima.jp": true, "makurazaki.kagoshima.jp": true, "matsumoto.kagoshima.jp": true, "minamitane.kagoshima.jp": true, "nakatane.kagoshima.jp": true, "nishinoomote.kagoshima.jp": true, "satsumasendai.kagoshima.jp": true, "soo.kagoshima.jp": true, "tarumizu.kagoshima.jp": true, "yusui.kagoshima.jp": true, "aikawa.kanagawa.jp": true, "atsugi.kanagawa.jp": true, "ayase.kanagawa.jp": true, "chigasaki.kanagawa.jp": true, "ebina.kanagawa.jp": true, "fujisawa.kanagawa.jp": true, "hadano.kanagawa.jp": true, "hakone.kanagawa.jp": true, "hiratsuka.kanagawa.jp": true, "isehara.kanagawa.jp": true, "kaisei.kanagawa.jp": true, "kamakura.kanagawa.jp": true, "kiyokawa.kanagawa.jp": true, "matsuda.kanagawa.jp": true, "minamiashigara.kanagawa.jp": true, "miura.kanagawa.jp": true, "nakai.kanagawa.jp": true, "ninomiya.kanagawa.jp": true, "odawara.kanagawa.jp": true, "oi.kanagawa.jp": true, "oiso.kanagawa.jp": true, "sagamihara.kanagawa.jp": true, "samukawa.kanagawa.jp": true, "tsukui.kanagawa.jp": true, "yamakita.kanagawa.jp": true, "yamato.kanagawa.jp": true, "yokosuka.kanagawa.jp": true, "yugawara.kanagawa.jp": true, "zama.kanagawa.jp": true, "zushi.kanagawa.jp": true, "aki.kochi.jp": true, "geisei.kochi.jp": true, "hidaka.kochi.jp": true, "higashitsuno.kochi.jp": true, "ino.kochi.jp": true, "kagami.kochi.jp": true, "kami.kochi.jp": true, "kitagawa.kochi.jp": true, "kochi.kochi.jp": true, "mihara.kochi.jp": true, "motoyama.kochi.jp": true, "muroto.kochi.jp": true, "nahari.kochi.jp": true, "nakamura.kochi.jp": true, "nankoku.kochi.jp": true, "nishitosa.kochi.jp": true, "niyodogawa.kochi.jp": true, "ochi.kochi.jp": true, "okawa.kochi.jp": true, "otoyo.kochi.jp": true, "otsuki.kochi.jp": true, "sakawa.kochi.jp": true, "sukumo.kochi.jp": true, "susaki.kochi.jp": true, "tosa.kochi.jp": true, "tosashimizu.kochi.jp": true, "toyo.kochi.jp": true, "tsuno.kochi.jp": true, "umaji.kochi.jp": true, "yasuda.kochi.jp": true, "yusuhara.kochi.jp": true, "amakusa.kumamoto.jp": true, "arao.kumamoto.jp": true, "aso.kumamoto.jp": true, "choyo.kumamoto.jp": true, "gyokuto.kumamoto.jp": true, "kamiamakusa.kumamoto.jp": true, "kikuchi.kumamoto.jp": true, "kumamoto.kumamoto.jp": true, "mashiki.kumamoto.jp": true, "mifune.kumamoto.jp": true, "minamata.kumamoto.jp": true, "minamioguni.kumamoto.jp": true, "nagasu.kumamoto.jp": true, "nishihara.kumamoto.jp": true, "oguni.kumamoto.jp": true, "ozu.kumamoto.jp": true, "sumoto.kumamoto.jp": true, "takamori.kumamoto.jp": true, "uki.kumamoto.jp": true, "uto.kumamoto.jp": true, "yamaga.kumamoto.jp": true, "yamato.kumamoto.jp": true, "yatsushiro.kumamoto.jp": true, "ayabe.kyoto.jp": true, "fukuchiyama.kyoto.jp": true, "higashiyama.kyoto.jp": true, "ide.kyoto.jp": true, "ine.kyoto.jp": true, "joyo.kyoto.jp": true, "kameoka.kyoto.jp": true, "kamo.kyoto.jp": true, "kita.kyoto.jp": true, "kizu.kyoto.jp": true, "kumiyama.kyoto.jp": true, "kyotamba.kyoto.jp": true, "kyotanabe.kyoto.jp": true, "kyotango.kyoto.jp": true, "maizuru.kyoto.jp": true, "minami.kyoto.jp": true, "minamiyamashiro.kyoto.jp": true, "miyazu.kyoto.jp": true, "muko.kyoto.jp": true, "nagaokakyo.kyoto.jp": true, "nakagyo.kyoto.jp": true, "nantan.kyoto.jp": true, "oyamazaki.kyoto.jp": true, "sakyo.kyoto.jp": true, "seika.kyoto.jp": true, "tanabe.kyoto.jp": true, "uji.kyoto.jp": true, "ujitawara.kyoto.jp": true, "wazuka.kyoto.jp": true, "yamashina.kyoto.jp": true, "yawata.kyoto.jp": true, "asahi.mie.jp": true, "inabe.mie.jp": true, "ise.mie.jp": true, "kameyama.mie.jp": true, "kawagoe.mie.jp": true, "kiho.mie.jp": true, "kisosaki.mie.jp": true, "kiwa.mie.jp": true, "komono.mie.jp": true, "kumano.mie.jp": true, "kuwana.mie.jp": true, "matsusaka.mie.jp": true, "meiwa.mie.jp": true, "mihama.mie.jp": true, "minamiise.mie.jp": true, "misugi.mie.jp": true, "miyama.mie.jp": true, "nabari.mie.jp": true, "shima.mie.jp": true, "suzuka.mie.jp": true, "tado.mie.jp": true, "taiki.mie.jp": true, "taki.mie.jp": true, "tamaki.mie.jp": true, "toba.mie.jp": true, "tsu.mie.jp": true, "udono.mie.jp": true, "ureshino.mie.jp": true, "watarai.mie.jp": true, "yokkaichi.mie.jp": true, "furukawa.miyagi.jp": true, "higashimatsushima.miyagi.jp": true, "ishinomaki.miyagi.jp": true, "iwanuma.miyagi.jp": true, "kakuda.miyagi.jp": true, "kami.miyagi.jp": true, "kawasaki.miyagi.jp": true, "marumori.miyagi.jp": true, "matsushima.miyagi.jp": true, "minamisanriku.miyagi.jp": true, "misato.miyagi.jp": true, "murata.miyagi.jp": true, "natori.miyagi.jp": true, "ogawara.miyagi.jp": true, "ohira.miyagi.jp": true, "onagawa.miyagi.jp": true, "osaki.miyagi.jp": true, "rifu.miyagi.jp": true, "semine.miyagi.jp": true, "shibata.miyagi.jp": true, "shichikashuku.miyagi.jp": true, "shikama.miyagi.jp": true, "shiogama.miyagi.jp": true, "shiroishi.miyagi.jp": true, "tagajo.miyagi.jp": true, "taiwa.miyagi.jp": true, "tome.miyagi.jp": true, "tomiya.miyagi.jp": true, "wakuya.miyagi.jp": true, "watari.miyagi.jp": true, "yamamoto.miyagi.jp": true, "zao.miyagi.jp": true, "aya.miyazaki.jp": true, "ebino.miyazaki.jp": true, "gokase.miyazaki.jp": true, "hyuga.miyazaki.jp": true, "kadogawa.miyazaki.jp": true, "kawaminami.miyazaki.jp": true, "kijo.miyazaki.jp": true, "kitagawa.miyazaki.jp": true, "kitakata.miyazaki.jp": true, "kitaura.miyazaki.jp": true, "kobayashi.miyazaki.jp": true, "kunitomi.miyazaki.jp": true, "kushima.miyazaki.jp": true, "mimata.miyazaki.jp": true, "miyakonojo.miyazaki.jp": true, "miyazaki.miyazaki.jp": true, "morotsuka.miyazaki.jp": true, "nichinan.miyazaki.jp": true, "nishimera.miyazaki.jp": true, "nobeoka.miyazaki.jp": true, "saito.miyazaki.jp": true, "shiiba.miyazaki.jp": true, "shintomi.miyazaki.jp": true, "takaharu.miyazaki.jp": true, "takanabe.miyazaki.jp": true, "takazaki.miyazaki.jp": true, "tsuno.miyazaki.jp": true, "achi.nagano.jp": true, "agematsu.nagano.jp": true, "anan.nagano.jp": true, "aoki.nagano.jp": true, "asahi.nagano.jp": true, "azumino.nagano.jp": true, "chikuhoku.nagano.jp": true, "chikuma.nagano.jp": true, "chino.nagano.jp": true, "fujimi.nagano.jp": true, "hakuba.nagano.jp": true, "hara.nagano.jp": true, "hiraya.nagano.jp": true, "iida.nagano.jp": true, "iijima.nagano.jp": true, "iiyama.nagano.jp": true, "iizuna.nagano.jp": true, "ikeda.nagano.jp": true, "ikusaka.nagano.jp": true, "ina.nagano.jp": true, "karuizawa.nagano.jp": true, "kawakami.nagano.jp": true, "kiso.nagano.jp": true, "kisofukushima.nagano.jp": true, "kitaaiki.nagano.jp": true, "komagane.nagano.jp": true, "komoro.nagano.jp": true, "matsukawa.nagano.jp": true, "matsumoto.nagano.jp": true, "miasa.nagano.jp": true, "minamiaiki.nagano.jp": true, "minamimaki.nagano.jp": true, "minamiminowa.nagano.jp": true, "minowa.nagano.jp": true, "miyada.nagano.jp": true, "miyota.nagano.jp": true, "mochizuki.nagano.jp": true, "nagano.nagano.jp": true, "nagawa.nagano.jp": true, "nagiso.nagano.jp": true, "nakagawa.nagano.jp": true, "nakano.nagano.jp": true, "nozawaonsen.nagano.jp": true, "obuse.nagano.jp": true, "ogawa.nagano.jp": true, "okaya.nagano.jp": true, "omachi.nagano.jp": true, "omi.nagano.jp": true, "ookuwa.nagano.jp": true, "ooshika.nagano.jp": true, "otaki.nagano.jp": true, "otari.nagano.jp": true, "sakae.nagano.jp": true, "sakaki.nagano.jp": true, "saku.nagano.jp": true, "sakuho.nagano.jp": true, "shimosuwa.nagano.jp": true, "shinanomachi.nagano.jp": true, "shiojiri.nagano.jp": true, "suwa.nagano.jp": true, "suzaka.nagano.jp": true, "takagi.nagano.jp": true, "takamori.nagano.jp": true, "takayama.nagano.jp": true, "tateshina.nagano.jp": true, "tatsuno.nagano.jp": true, "togakushi.nagano.jp": true, "togura.nagano.jp": true, "tomi.nagano.jp": true, "ueda.nagano.jp": true, "wada.nagano.jp": true, "yamagata.nagano.jp": true, "yamanouchi.nagano.jp": true, "yasaka.nagano.jp": true, "yasuoka.nagano.jp": true, "chijiwa.nagasaki.jp": true, "futsu.nagasaki.jp": true, "goto.nagasaki.jp": true, "hasami.nagasaki.jp": true, "hirado.nagasaki.jp": true, "iki.nagasaki.jp": true, "isahaya.nagasaki.jp": true, "kawatana.nagasaki.jp": true, "kuchinotsu.nagasaki.jp": true, "matsuura.nagasaki.jp": true, "nagasaki.nagasaki.jp": true, "obama.nagasaki.jp": true, "omura.nagasaki.jp": true, "oseto.nagasaki.jp": true, "saikai.nagasaki.jp": true, "sasebo.nagasaki.jp": true, "seihi.nagasaki.jp": true, "shimabara.nagasaki.jp": true, "shinkamigoto.nagasaki.jp": true, "togitsu.nagasaki.jp": true, "tsushima.nagasaki.jp": true, "unzen.nagasaki.jp": true, "ando.nara.jp": true, "gose.nara.jp": true, "heguri.nara.jp": true, "higashiyoshino.nara.jp": true, "ikaruga.nara.jp": true, "ikoma.nara.jp": true, "kamikitayama.nara.jp": true, "kanmaki.nara.jp": true, "kashiba.nara.jp": true, "kashihara.nara.jp": true, "katsuragi.nara.jp": true, "kawai.nara.jp": true, "kawakami.nara.jp": true, "kawanishi.nara.jp": true, "koryo.nara.jp": true, "kurotaki.nara.jp": true, "mitsue.nara.jp": true, "miyake.nara.jp": true, "nara.nara.jp": true, "nosegawa.nara.jp": true, "oji.nara.jp": true, "ouda.nara.jp": true, "oyodo.nara.jp": true, "sakurai.nara.jp": true, "sango.nara.jp": true, "shimoichi.nara.jp": true, "shimokitayama.nara.jp": true, "shinjo.nara.jp": true, "soni.nara.jp": true, "takatori.nara.jp": true, "tawaramoto.nara.jp": true, "tenkawa.nara.jp": true, "tenri.nara.jp": true, "uda.nara.jp": true, "yamatokoriyama.nara.jp": true, "yamatotakada.nara.jp": true, "yamazoe.nara.jp": true, "yoshino.nara.jp": true, "aga.niigata.jp": true, "agano.niigata.jp": true, "gosen.niigata.jp": true, "itoigawa.niigata.jp": true, "izumozaki.niigata.jp": true, "joetsu.niigata.jp": true, "kamo.niigata.jp": true, "kariwa.niigata.jp": true, "kashiwazaki.niigata.jp": true, "minamiuonuma.niigata.jp": true, "mitsuke.niigata.jp": true, "muika.niigata.jp": true, "murakami.niigata.jp": true, "myoko.niigata.jp": true, "nagaoka.niigata.jp": true, "niigata.niigata.jp": true, "ojiya.niigata.jp": true, "omi.niigata.jp": true, "sado.niigata.jp": true, "sanjo.niigata.jp": true, "seiro.niigata.jp": true, "seirou.niigata.jp": true, "sekikawa.niigata.jp": true, "shibata.niigata.jp": true, "tagami.niigata.jp": true, "tainai.niigata.jp": true, "tochio.niigata.jp": true, "tokamachi.niigata.jp": true, "tsubame.niigata.jp": true, "tsunan.niigata.jp": true, "uonuma.niigata.jp": true, "yahiko.niigata.jp": true, "yoita.niigata.jp": true, "yuzawa.niigata.jp": true, "beppu.oita.jp": true, "bungoono.oita.jp": true, "bungotakada.oita.jp": true, "hasama.oita.jp": true, "hiji.oita.jp": true, "himeshima.oita.jp": true, "hita.oita.jp": true, "kamitsue.oita.jp": true, "kokonoe.oita.jp": true, "kuju.oita.jp": true, "kunisaki.oita.jp": true, "kusu.oita.jp": true, "oita.oita.jp": true, "saiki.oita.jp": true, "taketa.oita.jp": true, "tsukumi.oita.jp": true, "usa.oita.jp": true, "usuki.oita.jp": true, "yufu.oita.jp": true, "akaiwa.okayama.jp": true, "asakuchi.okayama.jp": true, "bizen.okayama.jp": true, "hayashima.okayama.jp": true, "ibara.okayama.jp": true, "kagamino.okayama.jp": true, "kasaoka.okayama.jp": true, "kibichuo.okayama.jp": true, "kumenan.okayama.jp": true, "kurashiki.okayama.jp": true, "maniwa.okayama.jp": true, "misaki.okayama.jp": true, "nagi.okayama.jp": true, "niimi.okayama.jp": true, "nishiawakura.okayama.jp": true, "okayama.okayama.jp": true, "satosho.okayama.jp": true, "setouchi.okayama.jp": true, "shinjo.okayama.jp": true, "shoo.okayama.jp": true, "soja.okayama.jp": true, "takahashi.okayama.jp": true, "tamano.okayama.jp": true, "tsuyama.okayama.jp": true, "wake.okayama.jp": true, "yakage.okayama.jp": true, "aguni.okinawa.jp": true, "ginowan.okinawa.jp": true, "ginoza.okinawa.jp": true, "gushikami.okinawa.jp": true, "haebaru.okinawa.jp": true, "higashi.okinawa.jp": true, "hirara.okinawa.jp": true, "iheya.okinawa.jp": true, "ishigaki.okinawa.jp": true, "ishikawa.okinawa.jp": true, "itoman.okinawa.jp": true, "izena.okinawa.jp": true, "kadena.okinawa.jp": true, "kin.okinawa.jp": true, "kitadaito.okinawa.jp": true, "kitanakagusuku.okinawa.jp": true, "kumejima.okinawa.jp": true, "kunigami.okinawa.jp": true, "minamidaito.okinawa.jp": true, "motobu.okinawa.jp": true, "nago.okinawa.jp": true, "naha.okinawa.jp": true, "nakagusuku.okinawa.jp": true, "nakijin.okinawa.jp": true, "nanjo.okinawa.jp": true, "nishihara.okinawa.jp": true, "ogimi.okinawa.jp": true, "okinawa.okinawa.jp": true, "onna.okinawa.jp": true, "shimoji.okinawa.jp": true, "taketomi.okinawa.jp": true, "tarama.okinawa.jp": true, "tokashiki.okinawa.jp": true, "tomigusuku.okinawa.jp": true, "tonaki.okinawa.jp": true, "urasoe.okinawa.jp": true, "uruma.okinawa.jp": true, "yaese.okinawa.jp": true, "yomitan.okinawa.jp": true, "yonabaru.okinawa.jp": true, "yonaguni.okinawa.jp": true, "zamami.okinawa.jp": true, "abeno.osaka.jp": true, "chihayaakasaka.osaka.jp": true, "chuo.osaka.jp": true, "daito.osaka.jp": true, "fujiidera.osaka.jp": true, "habikino.osaka.jp": true, "hannan.osaka.jp": true, "higashiosaka.osaka.jp": true, "higashisumiyoshi.osaka.jp": true, "higashiyodogawa.osaka.jp": true, "hirakata.osaka.jp": true, "ibaraki.osaka.jp": true, "ikeda.osaka.jp": true, "izumi.osaka.jp": true, "izumiotsu.osaka.jp": true, "izumisano.osaka.jp": true, "kadoma.osaka.jp": true, "kaizuka.osaka.jp": true, "kanan.osaka.jp": true, "kashiwara.osaka.jp": true, "katano.osaka.jp": true, "kawachinagano.osaka.jp": true, "kishiwada.osaka.jp": true, "kita.osaka.jp": true, "kumatori.osaka.jp": true, "matsubara.osaka.jp": true, "minato.osaka.jp": true, "minoh.osaka.jp": true, "misaki.osaka.jp": true, "moriguchi.osaka.jp": true, "neyagawa.osaka.jp": true, "nishi.osaka.jp": true, "nose.osaka.jp": true, "osakasayama.osaka.jp": true, "sakai.osaka.jp": true, "sayama.osaka.jp": true, "sennan.osaka.jp": true, "settsu.osaka.jp": true, "shijonawate.osaka.jp": true, "shimamoto.osaka.jp": true, "suita.osaka.jp": true, "tadaoka.osaka.jp": true, "taishi.osaka.jp": true, "tajiri.osaka.jp": true, "takaishi.osaka.jp": true, "takatsuki.osaka.jp": true, "tondabayashi.osaka.jp": true, "toyonaka.osaka.jp": true, "toyono.osaka.jp": true, "yao.osaka.jp": true, "ariake.saga.jp": true, "arita.saga.jp": true, "fukudomi.saga.jp": true, "genkai.saga.jp": true, "hamatama.saga.jp": true, "hizen.saga.jp": true, "imari.saga.jp": true, "kamimine.saga.jp": true, "kanzaki.saga.jp": true, "karatsu.saga.jp": true, "kashima.saga.jp": true, "kitagata.saga.jp": true, "kitahata.saga.jp": true, "kiyama.saga.jp": true, "kouhoku.saga.jp": true, "kyuragi.saga.jp": true, "nishiarita.saga.jp": true, "ogi.saga.jp": true, "omachi.saga.jp": true, "ouchi.saga.jp": true, "saga.saga.jp": true, "shiroishi.saga.jp": true, "taku.saga.jp": true, "tara.saga.jp": true, "tosu.saga.jp": true, "yoshinogari.saga.jp": true, "arakawa.saitama.jp": true, "asaka.saitama.jp": true, "chichibu.saitama.jp": true, "fujimi.saitama.jp": true, "fujimino.saitama.jp": true, "fukaya.saitama.jp": true, "hanno.saitama.jp": true, "hanyu.saitama.jp": true, "hasuda.saitama.jp": true, "hatogaya.saitama.jp": true, "hatoyama.saitama.jp": true, "hidaka.saitama.jp": true, "higashichichibu.saitama.jp": true, "higashimatsuyama.saitama.jp": true, "honjo.saitama.jp": true, "ina.saitama.jp": true, "iruma.saitama.jp": true, "iwatsuki.saitama.jp": true, "kamiizumi.saitama.jp": true, "kamikawa.saitama.jp": true, "kamisato.saitama.jp": true, "kasukabe.saitama.jp": true, "kawagoe.saitama.jp": true, "kawaguchi.saitama.jp": true, "kawajima.saitama.jp": true, "kazo.saitama.jp": true, "kitamoto.saitama.jp": true, "koshigaya.saitama.jp": true, "kounosu.saitama.jp": true, "kuki.saitama.jp": true, "kumagaya.saitama.jp": true, "matsubushi.saitama.jp": true, "minano.saitama.jp": true, "misato.saitama.jp": true, "miyashiro.saitama.jp": true, "miyoshi.saitama.jp": true, "moroyama.saitama.jp": true, "nagatoro.saitama.jp": true, "namegawa.saitama.jp": true, "niiza.saitama.jp": true, "ogano.saitama.jp": true, "ogawa.saitama.jp": true, "ogose.saitama.jp": true, "okegawa.saitama.jp": true, "omiya.saitama.jp": true, "otaki.saitama.jp": true, "ranzan.saitama.jp": true, "ryokami.saitama.jp": true, "saitama.saitama.jp": true, "sakado.saitama.jp": true, "satte.saitama.jp": true, "sayama.saitama.jp": true, "shiki.saitama.jp": true, "shiraoka.saitama.jp": true, "soka.saitama.jp": true, "sugito.saitama.jp": true, "toda.saitama.jp": true, "tokigawa.saitama.jp": true, "tokorozawa.saitama.jp": true, "tsurugashima.saitama.jp": true, "urawa.saitama.jp": true, "warabi.saitama.jp": true, "yashio.saitama.jp": true, "yokoze.saitama.jp": true, "yono.saitama.jp": true, "yorii.saitama.jp": true, "yoshida.saitama.jp": true, "yoshikawa.saitama.jp": true, "yoshimi.saitama.jp": true, "aisho.shiga.jp": true, "gamo.shiga.jp": true, "higashiomi.shiga.jp": true, "hikone.shiga.jp": true, "koka.shiga.jp": true, "konan.shiga.jp": true, "kosei.shiga.jp": true, "koto.shiga.jp": true, "kusatsu.shiga.jp": true, "maibara.shiga.jp": true, "moriyama.shiga.jp": true, "nagahama.shiga.jp": true, "nishiazai.shiga.jp": true, "notogawa.shiga.jp": true, "omihachiman.shiga.jp": true, "otsu.shiga.jp": true, "ritto.shiga.jp": true, "ryuoh.shiga.jp": true, "takashima.shiga.jp": true, "takatsuki.shiga.jp": true, "torahime.shiga.jp": true, "toyosato.shiga.jp": true, "yasu.shiga.jp": true, "akagi.shimane.jp": true, "ama.shimane.jp": true, "gotsu.shimane.jp": true, "hamada.shimane.jp": true, "higashiizumo.shimane.jp": true, "hikawa.shimane.jp": true, "hikimi.shimane.jp": true, "izumo.shimane.jp": true, "kakinoki.shimane.jp": true, "masuda.shimane.jp": true, "matsue.shimane.jp": true, "misato.shimane.jp": true, "nishinoshima.shimane.jp": true, "ohda.shimane.jp": true, "okinoshima.shimane.jp": true, "okuizumo.shimane.jp": true, "shimane.shimane.jp": true, "tamayu.shimane.jp": true, "tsuwano.shimane.jp": true, "unnan.shimane.jp": true, "yakumo.shimane.jp": true, "yasugi.shimane.jp": true, "yatsuka.shimane.jp": true, "arai.shizuoka.jp": true, "atami.shizuoka.jp": true, "fuji.shizuoka.jp": true, "fujieda.shizuoka.jp": true, "fujikawa.shizuoka.jp": true, "fujinomiya.shizuoka.jp": true, "fukuroi.shizuoka.jp": true, "gotemba.shizuoka.jp": true, "haibara.shizuoka.jp": true, "hamamatsu.shizuoka.jp": true, "higashiizu.shizuoka.jp": true, "ito.shizuoka.jp": true, "iwata.shizuoka.jp": true, "izu.shizuoka.jp": true, "izunokuni.shizuoka.jp": true, "kakegawa.shizuoka.jp": true, "kannami.shizuoka.jp": true, "kawanehon.shizuoka.jp": true, "kawazu.shizuoka.jp": true, "kikugawa.shizuoka.jp": true, "kosai.shizuoka.jp": true, "makinohara.shizuoka.jp": true, "matsuzaki.shizuoka.jp": true, "minamiizu.shizuoka.jp": true, "mishima.shizuoka.jp": true, "morimachi.shizuoka.jp": true, "nishiizu.shizuoka.jp": true, "numazu.shizuoka.jp": true, "omaezaki.shizuoka.jp": true, "shimada.shizuoka.jp": true, "shimizu.shizuoka.jp": true, "shimoda.shizuoka.jp": true, "shizuoka.shizuoka.jp": true, "susono.shizuoka.jp": true, "yaizu.shizuoka.jp": true, "yoshida.shizuoka.jp": true, "ashikaga.tochigi.jp": true, "bato.tochigi.jp": true, "haga.tochigi.jp": true, "ichikai.tochigi.jp": true, "iwafune.tochigi.jp": true, "kaminokawa.tochigi.jp": true, "kanuma.tochigi.jp": true, "karasuyama.tochigi.jp": true, "kuroiso.tochigi.jp": true, "mashiko.tochigi.jp": true, "mibu.tochigi.jp": true, "moka.tochigi.jp": true, "motegi.tochigi.jp": true, "nasu.tochigi.jp": true, "nasushiobara.tochigi.jp": true, "nikko.tochigi.jp": true, "nishikata.tochigi.jp": true, "nogi.tochigi.jp": true, "ohira.tochigi.jp": true, "ohtawara.tochigi.jp": true, "oyama.tochigi.jp": true, "sakura.tochigi.jp": true, "sano.tochigi.jp": true, "shimotsuke.tochigi.jp": true, "shioya.tochigi.jp": true, "takanezawa.tochigi.jp": true, "tochigi.tochigi.jp": true, "tsuga.tochigi.jp": true, "ujiie.tochigi.jp": true, "utsunomiya.tochigi.jp": true, "yaita.tochigi.jp": true, "aizumi.tokushima.jp": true, "anan.tokushima.jp": true, "ichiba.tokushima.jp": true, "itano.tokushima.jp": true, "kainan.tokushima.jp": true, "komatsushima.tokushima.jp": true, "matsushige.tokushima.jp": true, "mima.tokushima.jp": true, "minami.tokushima.jp": true, "miyoshi.tokushima.jp": true, "mugi.tokushima.jp": true, "nakagawa.tokushima.jp": true, "naruto.tokushima.jp": true, "sanagochi.tokushima.jp": true, "shishikui.tokushima.jp": true, "tokushima.tokushima.jp": true, "wajiki.tokushima.jp": true, "adachi.tokyo.jp": true, "akiruno.tokyo.jp": true, "akishima.tokyo.jp": true, "aogashima.tokyo.jp": true, "arakawa.tokyo.jp": true, "bunkyo.tokyo.jp": true, "chiyoda.tokyo.jp": true, "chofu.tokyo.jp": true, "chuo.tokyo.jp": true, "edogawa.tokyo.jp": true, "fuchu.tokyo.jp": true, "fussa.tokyo.jp": true, "hachijo.tokyo.jp": true, "hachioji.tokyo.jp": true, "hamura.tokyo.jp": true, "higashikurume.tokyo.jp": true, "higashimurayama.tokyo.jp": true, "higashiyamato.tokyo.jp": true, "hino.tokyo.jp": true, "hinode.tokyo.jp": true, "hinohara.tokyo.jp": true, "inagi.tokyo.jp": true, "itabashi.tokyo.jp": true, "katsushika.tokyo.jp": true, "kita.tokyo.jp": true, "kiyose.tokyo.jp": true, "kodaira.tokyo.jp": true, "koganei.tokyo.jp": true, "kokubunji.tokyo.jp": true, "komae.tokyo.jp": true, "koto.tokyo.jp": true, "kouzushima.tokyo.jp": true, "kunitachi.tokyo.jp": true, "machida.tokyo.jp": true, "meguro.tokyo.jp": true, "minato.tokyo.jp": true, "mitaka.tokyo.jp": true, "mizuho.tokyo.jp": true, "musashimurayama.tokyo.jp": true, "musashino.tokyo.jp": true, "nakano.tokyo.jp": true, "nerima.tokyo.jp": true, "ogasawara.tokyo.jp": true, "okutama.tokyo.jp": true, "ome.tokyo.jp": true, "oshima.tokyo.jp": true, "ota.tokyo.jp": true, "setagaya.tokyo.jp": true, "shibuya.tokyo.jp": true, "shinagawa.tokyo.jp": true, "shinjuku.tokyo.jp": true, "suginami.tokyo.jp": true, "sumida.tokyo.jp": true, "tachikawa.tokyo.jp": true, "taito.tokyo.jp": true, "tama.tokyo.jp": true, "toshima.tokyo.jp": true, "chizu.tottori.jp": true, "hino.tottori.jp": true, "kawahara.tottori.jp": true, "koge.tottori.jp": true, "kotoura.tottori.jp": true, "misasa.tottori.jp": true, "nanbu.tottori.jp": true, "nichinan.tottori.jp": true, "sakaiminato.tottori.jp": true, "tottori.tottori.jp": true, "wakasa.tottori.jp": true, "yazu.tottori.jp": true, "yonago.tottori.jp": true, "asahi.toyama.jp": true, "fuchu.toyama.jp": true, "fukumitsu.toyama.jp": true, "funahashi.toyama.jp": true, "himi.toyama.jp": true, "imizu.toyama.jp": true, "inami.toyama.jp": true, "johana.toyama.jp": true, "kamiichi.toyama.jp": true, "kurobe.toyama.jp": true, "nakaniikawa.toyama.jp": true, "namerikawa.toyama.jp": true, "nanto.toyama.jp": true, "nyuzen.toyama.jp": true, "oyabe.toyama.jp": true, "taira.toyama.jp": true, "takaoka.toyama.jp": true, "tateyama.toyama.jp": true, "toga.toyama.jp": true, "tonami.toyama.jp": true, "toyama.toyama.jp": true, "unazuki.toyama.jp": true, "uozu.toyama.jp": true, "yamada.toyama.jp": true, "arida.wakayama.jp": true, "aridagawa.wakayama.jp": true, "gobo.wakayama.jp": true, "hashimoto.wakayama.jp": true, "hidaka.wakayama.jp": true, "hirogawa.wakayama.jp": true, "inami.wakayama.jp": true, "iwade.wakayama.jp": true, "kainan.wakayama.jp": true, "kamitonda.wakayama.jp": true, "katsuragi.wakayama.jp": true, "kimino.wakayama.jp": true, "kinokawa.wakayama.jp": true, "kitayama.wakayama.jp": true, "koya.wakayama.jp": true, "koza.wakayama.jp": true, "kozagawa.wakayama.jp": true, "kudoyama.wakayama.jp": true, "kushimoto.wakayama.jp": true, "mihama.wakayama.jp": true, "misato.wakayama.jp": true, "nachikatsuura.wakayama.jp": true, "shingu.wakayama.jp": true, "shirahama.wakayama.jp": true, "taiji.wakayama.jp": true, "tanabe.wakayama.jp": true, "wakayama.wakayama.jp": true, "yuasa.wakayama.jp": true, "yura.wakayama.jp": true, "asahi.yamagata.jp": true, "funagata.yamagata.jp": true, "higashine.yamagata.jp": true, "iide.yamagata.jp": true, "kahoku.yamagata.jp": true, "kaminoyama.yamagata.jp": true, "kaneyama.yamagata.jp": true, "kawanishi.yamagata.jp": true, "mamurogawa.yamagata.jp": true, "mikawa.yamagata.jp": true, "murayama.yamagata.jp": true, "nagai.yamagata.jp": true, "nakayama.yamagata.jp": true, "nanyo.yamagata.jp": true, "nishikawa.yamagata.jp": true, "obanazawa.yamagata.jp": true, "oe.yamagata.jp": true, "oguni.yamagata.jp": true, "ohkura.yamagata.jp": true, "oishida.yamagata.jp": true, "sagae.yamagata.jp": true, "sakata.yamagata.jp": true, "sakegawa.yamagata.jp": true, "shinjo.yamagata.jp": true, "shirataka.yamagata.jp": true, "shonai.yamagata.jp": true, "takahata.yamagata.jp": true, "tendo.yamagata.jp": true, "tozawa.yamagata.jp": true, "tsuruoka.yamagata.jp": true, "yamagata.yamagata.jp": true, "yamanobe.yamagata.jp": true, "yonezawa.yamagata.jp": true, "yuza.yamagata.jp": true, "abu.yamaguchi.jp": true, "hagi.yamaguchi.jp": true, "hikari.yamaguchi.jp": true, "hofu.yamaguchi.jp": true, "iwakuni.yamaguchi.jp": true, "kudamatsu.yamaguchi.jp": true, "mitou.yamaguchi.jp": true, "nagato.yamaguchi.jp": true, "oshima.yamaguchi.jp": true, "shimonoseki.yamaguchi.jp": true, "shunan.yamaguchi.jp": true, "tabuse.yamaguchi.jp": true, "tokuyama.yamaguchi.jp": true, "toyota.yamaguchi.jp": true, "ube.yamaguchi.jp": true, "yuu.yamaguchi.jp": true, "chuo.yamanashi.jp": true, "doshi.yamanashi.jp": true, "fuefuki.yamanashi.jp": true, "fujikawa.yamanashi.jp": true, "fujikawaguchiko.yamanashi.jp": true, "fujiyoshida.yamanashi.jp": true, "hayakawa.yamanashi.jp": true, "hokuto.yamanashi.jp": true, "ichikawamisato.yamanashi.jp": true, "kai.yamanashi.jp": true, "kofu.yamanashi.jp": true, "koshu.yamanashi.jp": true, "kosuge.yamanashi.jp": true, "minami-alps.yamanashi.jp": true, "minobu.yamanashi.jp": true, "nakamichi.yamanashi.jp": true, "nanbu.yamanashi.jp": true, "narusawa.yamanashi.jp": true, "nirasaki.yamanashi.jp": true, "nishikatsura.yamanashi.jp": true, "oshino.yamanashi.jp": true, "otsuki.yamanashi.jp": true, "showa.yamanashi.jp": true, "tabayama.yamanashi.jp": true, "tsuru.yamanashi.jp": true, "uenohara.yamanashi.jp": true, "yamanakako.yamanashi.jp": true, "yamanashi.yamanashi.jp": true, "ke": true, "ac.ke": true, "co.ke": true, "go.ke": true, "info.ke": true, "me.ke": true, "mobi.ke": true, "ne.ke": true, "or.ke": true, "sc.ke": true, "kg": true, "org.kg": true, "net.kg": true, "com.kg": true, "edu.kg": true, "gov.kg": true, "mil.kg": true, "*.kh": true, "ki": true, "edu.ki": true, "biz.ki": true, "net.ki": true, "org.ki": true, "gov.ki": true, "info.ki": true, "com.ki": true, "km": true, "org.km": true, "nom.km": true, "gov.km": true, "prd.km": true, "tm.km": true, "edu.km": true, "mil.km": true, "ass.km": true, "com.km": true, "coop.km": true, "asso.km": true, "presse.km": true, "medecin.km": true, "notaires.km": true, "pharmaciens.km": true, "veterinaire.km": true, "gouv.km": true, "kn": true, "net.kn": true, "org.kn": true, "edu.kn": true, "gov.kn": true, "kp": true, "com.kp": true, "edu.kp": true, "gov.kp": true, "org.kp": true, "rep.kp": true, "tra.kp": true, "kr": true, "ac.kr": true, "co.kr": true, "es.kr": true, "go.kr": true, "hs.kr": true, "kg.kr": true, "mil.kr": true, "ms.kr": true, "ne.kr": true, "or.kr": true, "pe.kr": true, "re.kr": true, "sc.kr": true, "busan.kr": true, "chungbuk.kr": true, "chungnam.kr": true, "daegu.kr": true, "daejeon.kr": true, "gangwon.kr": true, "gwangju.kr": true, "gyeongbuk.kr": true, "gyeonggi.kr": true, "gyeongnam.kr": true, "incheon.kr": true, "jeju.kr": true, "jeonbuk.kr": true, "jeonnam.kr": true, "seoul.kr": true, "ulsan.kr": true, "*.kw": true, "ky": true, "edu.ky": true, "gov.ky": true, "com.ky": true, "org.ky": true, "net.ky": true, "kz": true, "org.kz": true, "edu.kz": true, "net.kz": true, "gov.kz": true, "mil.kz": true, "com.kz": true, "la": true, "int.la": true, "net.la": true, "info.la": true, "edu.la": true, "gov.la": true, "per.la": true, "com.la": true, "org.la": true, "lb": true, "com.lb": true, "edu.lb": true, "gov.lb": true, "net.lb": true, "org.lb": true, "lc": true, "com.lc": true, "net.lc": true, "co.lc": true, "org.lc": true, "edu.lc": true, "gov.lc": true, "li": true, "lk": true, "gov.lk": true, "sch.lk": true, "net.lk": true, "int.lk": true, "com.lk": true, "org.lk": true, "edu.lk": true, "ngo.lk": true, "soc.lk": true, "web.lk": true, "ltd.lk": true, "assn.lk": true, "grp.lk": true, "hotel.lk": true, "ac.lk": true, "lr": true, "com.lr": true, "edu.lr": true, "gov.lr": true, "org.lr": true, "net.lr": true, "ls": true, "co.ls": true, "org.ls": true, "lt": true, "gov.lt": true, "lu": true, "lv": true, "com.lv": true, "edu.lv": true, "gov.lv": true, "org.lv": true, "mil.lv": true, "id.lv": true, "net.lv": true, "asn.lv": true, "conf.lv": true, "ly": true, "com.ly": true, "net.ly": true, "gov.ly": true, "plc.ly": true, "edu.ly": true, "sch.ly": true, "med.ly": true, "org.ly": true, "id.ly": true, "ma": true, "co.ma": true, "net.ma": true, "gov.ma": true, "org.ma": true, "ac.ma": true, "press.ma": true, "mc": true, "tm.mc": true, "asso.mc": true, "md": true, "me": true, "co.me": true, "net.me": true, "org.me": true, "edu.me": true, "ac.me": true, "gov.me": true, "its.me": true, "priv.me": true, "mg": true, "org.mg": true, "nom.mg": true, "gov.mg": true, "prd.mg": true, "tm.mg": true, "edu.mg": true, "mil.mg": true, "com.mg": true, "co.mg": true, "mh": true, "mil": true, "mk": true, "com.mk": true, "org.mk": true, "net.mk": true, "edu.mk": true, "gov.mk": true, "inf.mk": true, "name.mk": true, "ml": true, "com.ml": true, "edu.ml": true, "gouv.ml": true, "gov.ml": true, "net.ml": true, "org.ml": true, "presse.ml": true, "*.mm": true, "mn": true, "gov.mn": true, "edu.mn": true, "org.mn": true, "mo": true, "com.mo": true, "net.mo": true, "org.mo": true, "edu.mo": true, "gov.mo": true, "mobi": true, "mp": true, "mq": true, "mr": true, "gov.mr": true, "ms": true, "com.ms": true, "edu.ms": true, "gov.ms": true, "net.ms": true, "org.ms": true, "mt": true, "com.mt": true, "edu.mt": true, "net.mt": true, "org.mt": true, "mu": true, "com.mu": true, "net.mu": true, "org.mu": true, "gov.mu": true, "ac.mu": true, "co.mu": true, "or.mu": true, "museum": true, "academy.museum": true, "agriculture.museum": true, "air.museum": true, "airguard.museum": true, "alabama.museum": true, "alaska.museum": true, "amber.museum": true, "ambulance.museum": true, "american.museum": true, "americana.museum": true, "americanantiques.museum": true, "americanart.museum": true, "amsterdam.museum": true, "and.museum": true, "annefrank.museum": true, "anthro.museum": true, "anthropology.museum": true, "antiques.museum": true, "aquarium.museum": true, "arboretum.museum": true, "archaeological.museum": true, "archaeology.museum": true, "architecture.museum": true, "art.museum": true, "artanddesign.museum": true, "artcenter.museum": true, "artdeco.museum": true, "arteducation.museum": true, "artgallery.museum": true, "arts.museum": true, "artsandcrafts.museum": true, "asmatart.museum": true, "assassination.museum": true, "assisi.museum": true, "association.museum": true, "astronomy.museum": true, "atlanta.museum": true, "austin.museum": true, "australia.museum": true, "automotive.museum": true, "aviation.museum": true, "axis.museum": true, "badajoz.museum": true, "baghdad.museum": true, "bahn.museum": true, "bale.museum": true, "baltimore.museum": true, "barcelona.museum": true, "baseball.museum": true, "basel.museum": true, "baths.museum": true, "bauern.museum": true, "beauxarts.museum": true, "beeldengeluid.museum": true, "bellevue.museum": true, "bergbau.museum": true, "berkeley.museum": true, "berlin.museum": true, "bern.museum": true, "bible.museum": true, "bilbao.museum": true, "bill.museum": true, "birdart.museum": true, "birthplace.museum": true, "bonn.museum": true, "boston.museum": true, "botanical.museum": true, "botanicalgarden.museum": true, "botanicgarden.museum": true, "botany.museum": true, "brandywinevalley.museum": true, "brasil.museum": true, "bristol.museum": true, "british.museum": true, "britishcolumbia.museum": true, "broadcast.museum": true, "brunel.museum": true, "brussel.museum": true, "brussels.museum": true, "bruxelles.museum": true, "building.museum": true, "burghof.museum": true, "bus.museum": true, "bushey.museum": true, "cadaques.museum": true, "california.museum": true, "cambridge.museum": true, "can.museum": true, "canada.museum": true, "capebreton.museum": true, "carrier.museum": true, "cartoonart.museum": true, "casadelamoneda.museum": true, "castle.museum": true, "castres.museum": true, "celtic.museum": true, "center.museum": true, "chattanooga.museum": true, "cheltenham.museum": true, "chesapeakebay.museum": true, "chicago.museum": true, "children.museum": true, "childrens.museum": true, "childrensgarden.museum": true, "chiropractic.museum": true, "chocolate.museum": true, "christiansburg.museum": true, "cincinnati.museum": true, "cinema.museum": true, "circus.museum": true, "civilisation.museum": true, "civilization.museum": true, "civilwar.museum": true, "clinton.museum": true, "clock.museum": true, "coal.museum": true, "coastaldefence.museum": true, "cody.museum": true, "coldwar.museum": true, "collection.museum": true, "colonialwilliamsburg.museum": true, "coloradoplateau.museum": true, "columbia.museum": true, "columbus.museum": true, "communication.museum": true, "communications.museum": true, "community.museum": true, "computer.museum": true, "computerhistory.museum": true, "xn--comunicaes-v6a2o.museum": true, "contemporary.museum": true, "contemporaryart.museum": true, "convent.museum": true, "copenhagen.museum": true, "corporation.museum": true, "xn--correios-e-telecomunicaes-ghc29a.museum": true, "corvette.museum": true, "costume.museum": true, "countryestate.museum": true, "county.museum": true, "crafts.museum": true, "cranbrook.museum": true, "creation.museum": true, "cultural.museum": true, "culturalcenter.museum": true, "culture.museum": true, "cyber.museum": true, "cymru.museum": true, "dali.museum": true, "dallas.museum": true, "database.museum": true, "ddr.museum": true, "decorativearts.museum": true, "delaware.museum": true, "delmenhorst.museum": true, "denmark.museum": true, "depot.museum": true, "design.museum": true, "detroit.museum": true, "dinosaur.museum": true, "discovery.museum": true, "dolls.museum": true, "donostia.museum": true, "durham.museum": true, "eastafrica.museum": true, "eastcoast.museum": true, "education.museum": true, "educational.museum": true, "egyptian.museum": true, "eisenbahn.museum": true, "elburg.museum": true, "elvendrell.museum": true, "embroidery.museum": true, "encyclopedic.museum": true, "england.museum": true, "entomology.museum": true, "environment.museum": true, "environmentalconservation.museum": true, "epilepsy.museum": true, "essex.museum": true, "estate.museum": true, "ethnology.museum": true, "exeter.museum": true, "exhibition.museum": true, "family.museum": true, "farm.museum": true, "farmequipment.museum": true, "farmers.museum": true, "farmstead.museum": true, "field.museum": true, "figueres.museum": true, "filatelia.museum": true, "film.museum": true, "fineart.museum": true, "finearts.museum": true, "finland.museum": true, "flanders.museum": true, "florida.museum": true, "force.museum": true, "fortmissoula.museum": true, "fortworth.museum": true, "foundation.museum": true, "francaise.museum": true, "frankfurt.museum": true, "franziskaner.museum": true, "freemasonry.museum": true, "freiburg.museum": true, "fribourg.museum": true, "frog.museum": true, "fundacio.museum": true, "furniture.museum": true, "gallery.museum": true, "garden.museum": true, "gateway.museum": true, "geelvinck.museum": true, "gemological.museum": true, "geology.museum": true, "georgia.museum": true, "giessen.museum": true, "glas.museum": true, "glass.museum": true, "gorge.museum": true, "grandrapids.museum": true, "graz.museum": true, "guernsey.museum": true, "halloffame.museum": true, "hamburg.museum": true, "handson.museum": true, "harvestcelebration.museum": true, "hawaii.museum": true, "health.museum": true, "heimatunduhren.museum": true, "hellas.museum": true, "helsinki.museum": true, "hembygdsforbund.museum": true, "heritage.museum": true, "histoire.museum": true, "historical.museum": true, "historicalsociety.museum": true, "historichouses.museum": true, "historisch.museum": true, "historisches.museum": true, "history.museum": true, "historyofscience.museum": true, "horology.museum": true, "house.museum": true, "humanities.museum": true, "illustration.museum": true, "imageandsound.museum": true, "indian.museum": true, "indiana.museum": true, "indianapolis.museum": true, "indianmarket.museum": true, "intelligence.museum": true, "interactive.museum": true, "iraq.museum": true, "iron.museum": true, "isleofman.museum": true, "jamison.museum": true, "jefferson.museum": true, "jerusalem.museum": true, "jewelry.museum": true, "jewish.museum": true, "jewishart.museum": true, "jfk.museum": true, "journalism.museum": true, "judaica.museum": true, "judygarland.museum": true, "juedisches.museum": true, "juif.museum": true, "karate.museum": true, "karikatur.museum": true, "kids.museum": true, "koebenhavn.museum": true, "koeln.museum": true, "kunst.museum": true, "kunstsammlung.museum": true, "kunstunddesign.museum": true, "labor.museum": true, "labour.museum": true, "lajolla.museum": true, "lancashire.museum": true, "landes.museum": true, "lans.museum": true, "xn--lns-qla.museum": true, "larsson.museum": true, "lewismiller.museum": true, "lincoln.museum": true, "linz.museum": true, "living.museum": true, "livinghistory.museum": true, "localhistory.museum": true, "london.museum": true, "losangeles.museum": true, "louvre.museum": true, "loyalist.museum": true, "lucerne.museum": true, "luxembourg.museum": true, "luzern.museum": true, "mad.museum": true, "madrid.museum": true, "mallorca.museum": true, "manchester.museum": true, "mansion.museum": true, "mansions.museum": true, "manx.museum": true, "marburg.museum": true, "maritime.museum": true, "maritimo.museum": true, "maryland.museum": true, "marylhurst.museum": true, "media.museum": true, "medical.museum": true, "medizinhistorisches.museum": true, "meeres.museum": true, "memorial.museum": true, "mesaverde.museum": true, "michigan.museum": true, "midatlantic.museum": true, "military.museum": true, "mill.museum": true, "miners.museum": true, "mining.museum": true, "minnesota.museum": true, "missile.museum": true, "missoula.museum": true, "modern.museum": true, "moma.museum": true, "money.museum": true, "monmouth.museum": true, "monticello.museum": true, "montreal.museum": true, "moscow.museum": true, "motorcycle.museum": true, "muenchen.museum": true, "muenster.museum": true, "mulhouse.museum": true, "muncie.museum": true, "museet.museum": true, "museumcenter.museum": true, "museumvereniging.museum": true, "music.museum": true, "national.museum": true, "nationalfirearms.museum": true, "nationalheritage.museum": true, "nativeamerican.museum": true, "naturalhistory.museum": true, "naturalhistorymuseum.museum": true, "naturalsciences.museum": true, "nature.museum": true, "naturhistorisches.museum": true, "natuurwetenschappen.museum": true, "naumburg.museum": true, "naval.museum": true, "nebraska.museum": true, "neues.museum": true, "newhampshire.museum": true, "newjersey.museum": true, "newmexico.museum": true, "newport.museum": true, "newspaper.museum": true, "newyork.museum": true, "niepce.museum": true, "norfolk.museum": true, "north.museum": true, "nrw.museum": true, "nuernberg.museum": true, "nuremberg.museum": true, "nyc.museum": true, "nyny.museum": true, "oceanographic.museum": true, "oceanographique.museum": true, "omaha.museum": true, "online.museum": true, "ontario.museum": true, "openair.museum": true, "oregon.museum": true, "oregontrail.museum": true, "otago.museum": true, "oxford.museum": true, "pacific.museum": true, "paderborn.museum": true, "palace.museum": true, "paleo.museum": true, "palmsprings.museum": true, "panama.museum": true, "paris.museum": true, "pasadena.museum": true, "pharmacy.museum": true, "philadelphia.museum": true, "philadelphiaarea.museum": true, "philately.museum": true, "phoenix.museum": true, "photography.museum": true, "pilots.museum": true, "pittsburgh.museum": true, "planetarium.museum": true, "plantation.museum": true, "plants.museum": true, "plaza.museum": true, "portal.museum": true, "portland.museum": true, "portlligat.museum": true, "posts-and-telecommunications.museum": true, "preservation.museum": true, "presidio.museum": true, "press.museum": true, "project.museum": true, "public.museum": true, "pubol.museum": true, "quebec.museum": true, "railroad.museum": true, "railway.museum": true, "research.museum": true, "resistance.museum": true, "riodejaneiro.museum": true, "rochester.museum": true, "rockart.museum": true, "roma.museum": true, "russia.museum": true, "saintlouis.museum": true, "salem.museum": true, "salvadordali.museum": true, "salzburg.museum": true, "sandiego.museum": true, "sanfrancisco.museum": true, "santabarbara.museum": true, "santacruz.museum": true, "santafe.museum": true, "saskatchewan.museum": true, "satx.museum": true, "savannahga.museum": true, "schlesisches.museum": true, "schoenbrunn.museum": true, "schokoladen.museum": true, "school.museum": true, "schweiz.museum": true, "science.museum": true, "scienceandhistory.museum": true, "scienceandindustry.museum": true, "sciencecenter.museum": true, "sciencecenters.museum": true, "science-fiction.museum": true, "sciencehistory.museum": true, "sciences.museum": true, "sciencesnaturelles.museum": true, "scotland.museum": true, "seaport.museum": true, "settlement.museum": true, "settlers.museum": true, "shell.museum": true, "sherbrooke.museum": true, "sibenik.museum": true, "silk.museum": true, "ski.museum": true, "skole.museum": true, "society.museum": true, "sologne.museum": true, "soundandvision.museum": true, "southcarolina.museum": true, "southwest.museum": true, "space.museum": true, "spy.museum": true, "square.museum": true, "stadt.museum": true, "stalbans.museum": true, "starnberg.museum": true, "state.museum": true, "stateofdelaware.museum": true, "station.museum": true, "steam.museum": true, "steiermark.museum": true, "stjohn.museum": true, "stockholm.museum": true, "stpetersburg.museum": true, "stuttgart.museum": true, "suisse.museum": true, "surgeonshall.museum": true, "surrey.museum": true, "svizzera.museum": true, "sweden.museum": true, "sydney.museum": true, "tank.museum": true, "tcm.museum": true, "technology.museum": true, "telekommunikation.museum": true, "television.museum": true, "texas.museum": true, "textile.museum": true, "theater.museum": true, "time.museum": true, "timekeeping.museum": true, "topology.museum": true, "torino.museum": true, "touch.museum": true, "town.museum": true, "transport.museum": true, "tree.museum": true, "trolley.museum": true, "trust.museum": true, "trustee.museum": true, "uhren.museum": true, "ulm.museum": true, "undersea.museum": true, "university.museum": true, "usa.museum": true, "usantiques.museum": true, "usarts.museum": true, "uscountryestate.museum": true, "usculture.museum": true, "usdecorativearts.museum": true, "usgarden.museum": true, "ushistory.museum": true, "ushuaia.museum": true, "uslivinghistory.museum": true, "utah.museum": true, "uvic.museum": true, "valley.museum": true, "vantaa.museum": true, "versailles.museum": true, "viking.museum": true, "village.museum": true, "virginia.museum": true, "virtual.museum": true, "virtuel.museum": true, "vlaanderen.museum": true, "volkenkunde.museum": true, "wales.museum": true, "wallonie.museum": true, "war.museum": true, "washingtondc.museum": true, "watchandclock.museum": true, "watch-and-clock.museum": true, "western.museum": true, "westfalen.museum": true, "whaling.museum": true, "wildlife.museum": true, "williamsburg.museum": true, "windmill.museum": true, "workshop.museum": true, "york.museum": true, "yorkshire.museum": true, "yosemite.museum": true, "youth.museum": true, "zoological.museum": true, "zoology.museum": true, "xn--9dbhblg6di.museum": true, "xn--h1aegh.museum": true, "mv": true, "aero.mv": true, "biz.mv": true, "com.mv": true, "coop.mv": true, "edu.mv": true, "gov.mv": true, "info.mv": true, "int.mv": true, "mil.mv": true, "museum.mv": true, "name.mv": true, "net.mv": true, "org.mv": true, "pro.mv": true, "mw": true, "ac.mw": true, "biz.mw": true, "co.mw": true, "com.mw": true, "coop.mw": true, "edu.mw": true, "gov.mw": true, "int.mw": true, "museum.mw": true, "net.mw": true, "org.mw": true, "mx": true, "com.mx": true, "org.mx": true, "gob.mx": true, "edu.mx": true, "net.mx": true, "my": true, "com.my": true, "net.my": true, "org.my": true, "gov.my": true, "edu.my": true, "mil.my": true, "name.my": true, "mz": true, "ac.mz": true, "adv.mz": true, "co.mz": true, "edu.mz": true, "gov.mz": true, "mil.mz": true, "net.mz": true, "org.mz": true, "na": true, "info.na": true, "pro.na": true, "name.na": true, "school.na": true, "or.na": true, "dr.na": true, "us.na": true, "mx.na": true, "ca.na": true, "in.na": true, "cc.na": true, "tv.na": true, "ws.na": true, "mobi.na": true, "co.na": true, "com.na": true, "org.na": true, "name": true, "nc": true, "asso.nc": true, "nom.nc": true, "ne": true, "net": true, "nf": true, "com.nf": true, "net.nf": true, "per.nf": true, "rec.nf": true, "web.nf": true, "arts.nf": true, "firm.nf": true, "info.nf": true, "other.nf": true, "store.nf": true, "ng": true, "com.ng": true, "edu.ng": true, "gov.ng": true, "i.ng": true, "mil.ng": true, "mobi.ng": true, "name.ng": true, "net.ng": true, "org.ng": true, "sch.ng": true, "ni": true, "ac.ni": true, "biz.ni": true, "co.ni": true, "com.ni": true, "edu.ni": true, "gob.ni": true, "in.ni": true, "info.ni": true, "int.ni": true, "mil.ni": true, "net.ni": true, "nom.ni": true, "org.ni": true, "web.ni": true, "nl": true, "bv.nl": true, "no": true, "fhs.no": true, "vgs.no": true, "fylkesbibl.no": true, "folkebibl.no": true, "museum.no": true, "idrett.no": true, "priv.no": true, "mil.no": true, "stat.no": true, "dep.no": true, "kommune.no": true, "herad.no": true, "aa.no": true, "ah.no": true, "bu.no": true, "fm.no": true, "hl.no": true, "hm.no": true, "jan-mayen.no": true, "mr.no": true, "nl.no": true, "nt.no": true, "of.no": true, "ol.no": true, "oslo.no": true, "rl.no": true, "sf.no": true, "st.no": true, "svalbard.no": true, "tm.no": true, "tr.no": true, "va.no": true, "vf.no": true, "gs.aa.no": true, "gs.ah.no": true, "gs.bu.no": true, "gs.fm.no": true, "gs.hl.no": true, "gs.hm.no": true, "gs.jan-mayen.no": true, "gs.mr.no": true, "gs.nl.no": true, "gs.nt.no": true, "gs.of.no": true, "gs.ol.no": true, "gs.oslo.no": true, "gs.rl.no": true, "gs.sf.no": true, "gs.st.no": true, "gs.svalbard.no": true, "gs.tm.no": true, "gs.tr.no": true, "gs.va.no": true, "gs.vf.no": true, "akrehamn.no": true, "xn--krehamn-dxa.no": true, "algard.no": true, "xn--lgrd-poac.no": true, "arna.no": true, "brumunddal.no": true, "bryne.no": true, "bronnoysund.no": true, "xn--brnnysund-m8ac.no": true, "drobak.no": true, "xn--drbak-wua.no": true, "egersund.no": true, "fetsund.no": true, "floro.no": true, "xn--flor-jra.no": true, "fredrikstad.no": true, "hokksund.no": true, "honefoss.no": true, "xn--hnefoss-q1a.no": true, "jessheim.no": true, "jorpeland.no": true, "xn--jrpeland-54a.no": true, "kirkenes.no": true, "kopervik.no": true, "krokstadelva.no": true, "langevag.no": true, "xn--langevg-jxa.no": true, "leirvik.no": true, "mjondalen.no": true, "xn--mjndalen-64a.no": true, "mo-i-rana.no": true, "mosjoen.no": true, "xn--mosjen-eya.no": true, "nesoddtangen.no": true, "orkanger.no": true, "osoyro.no": true, "xn--osyro-wua.no": true, "raholt.no": true, "xn--rholt-mra.no": true, "sandnessjoen.no": true, "xn--sandnessjen-ogb.no": true, "skedsmokorset.no": true, "slattum.no": true, "spjelkavik.no": true, "stathelle.no": true, "stavern.no": true, "stjordalshalsen.no": true, "xn--stjrdalshalsen-sqb.no": true, "tananger.no": true, "tranby.no": true, "vossevangen.no": true, "afjord.no": true, "xn--fjord-lra.no": true, "agdenes.no": true, "al.no": true, "xn--l-1fa.no": true, "alesund.no": true, "xn--lesund-hua.no": true, "alstahaug.no": true, "alta.no": true, "xn--lt-liac.no": true, "alaheadju.no": true, "xn--laheadju-7ya.no": true, "alvdal.no": true, "amli.no": true, "xn--mli-tla.no": true, "amot.no": true, "xn--mot-tla.no": true, "andebu.no": true, "andoy.no": true, "xn--andy-ira.no": true, "andasuolo.no": true, "ardal.no": true, "xn--rdal-poa.no": true, "aremark.no": true, "arendal.no": true, "xn--s-1fa.no": true, "aseral.no": true, "xn--seral-lra.no": true, "asker.no": true, "askim.no": true, "askvoll.no": true, "askoy.no": true, "xn--asky-ira.no": true, "asnes.no": true, "xn--snes-poa.no": true, "audnedaln.no": true, "aukra.no": true, "aure.no": true, "aurland.no": true, "aurskog-holand.no": true, "xn--aurskog-hland-jnb.no": true, "austevoll.no": true, "austrheim.no": true, "averoy.no": true, "xn--avery-yua.no": true, "balestrand.no": true, "ballangen.no": true, "balat.no": true, "xn--blt-elab.no": true, "balsfjord.no": true, "bahccavuotna.no": true, "xn--bhccavuotna-k7a.no": true, "bamble.no": true, "bardu.no": true, "beardu.no": true, "beiarn.no": true, "bajddar.no": true, "xn--bjddar-pta.no": true, "baidar.no": true, "xn--bidr-5nac.no": true, "berg.no": true, "bergen.no": true, "berlevag.no": true, "xn--berlevg-jxa.no": true, "bearalvahki.no": true, "xn--bearalvhki-y4a.no": true, "bindal.no": true, "birkenes.no": true, "bjarkoy.no": true, "xn--bjarky-fya.no": true, "bjerkreim.no": true, "bjugn.no": true, "bodo.no": true, "xn--bod-2na.no": true, "badaddja.no": true, "xn--bdddj-mrabd.no": true, "budejju.no": true, "bokn.no": true, "bremanger.no": true, "bronnoy.no": true, "xn--brnny-wuac.no": true, "bygland.no": true, "bykle.no": true, "barum.no": true, "xn--brum-voa.no": true, "bo.telemark.no": true, "xn--b-5ga.telemark.no": true, "bo.nordland.no": true, "xn--b-5ga.nordland.no": true, "bievat.no": true, "xn--bievt-0qa.no": true, "bomlo.no": true, "xn--bmlo-gra.no": true, "batsfjord.no": true, "xn--btsfjord-9za.no": true, "bahcavuotna.no": true, "xn--bhcavuotna-s4a.no": true, "dovre.no": true, "drammen.no": true, "drangedal.no": true, "dyroy.no": true, "xn--dyry-ira.no": true, "donna.no": true, "xn--dnna-gra.no": true, "eid.no": true, "eidfjord.no": true, "eidsberg.no": true, "eidskog.no": true, "eidsvoll.no": true, "eigersund.no": true, "elverum.no": true, "enebakk.no": true, "engerdal.no": true, "etne.no": true, "etnedal.no": true, "evenes.no": true, "evenassi.no": true, "xn--eveni-0qa01ga.no": true, "evje-og-hornnes.no": true, "farsund.no": true, "fauske.no": true, "fuossko.no": true, "fuoisku.no": true, "fedje.no": true, "fet.no": true, "finnoy.no": true, "xn--finny-yua.no": true, "fitjar.no": true, "fjaler.no": true, "fjell.no": true, "flakstad.no": true, "flatanger.no": true, "flekkefjord.no": true, "flesberg.no": true, "flora.no": true, "fla.no": true, "xn--fl-zia.no": true, "folldal.no": true, "forsand.no": true, "fosnes.no": true, "frei.no": true, "frogn.no": true, "froland.no": true, "frosta.no": true, "frana.no": true, "xn--frna-woa.no": true, "froya.no": true, "xn--frya-hra.no": true, "fusa.no": true, "fyresdal.no": true, "forde.no": true, "xn--frde-gra.no": true, "gamvik.no": true, "gangaviika.no": true, "xn--ggaviika-8ya47h.no": true, "gaular.no": true, "gausdal.no": true, "gildeskal.no": true, "xn--gildeskl-g0a.no": true, "giske.no": true, "gjemnes.no": true, "gjerdrum.no": true, "gjerstad.no": true, "gjesdal.no": true, "gjovik.no": true, "xn--gjvik-wua.no": true, "gloppen.no": true, "gol.no": true, "gran.no": true, "grane.no": true, "granvin.no": true, "gratangen.no": true, "grimstad.no": true, "grong.no": true, "kraanghke.no": true, "xn--kranghke-b0a.no": true, "grue.no": true, "gulen.no": true, "hadsel.no": true, "halden.no": true, "halsa.no": true, "hamar.no": true, "hamaroy.no": true, "habmer.no": true, "xn--hbmer-xqa.no": true, "hapmir.no": true, "xn--hpmir-xqa.no": true, "hammerfest.no": true, "hammarfeasta.no": true, "xn--hmmrfeasta-s4ac.no": true, "haram.no": true, "hareid.no": true, "harstad.no": true, "hasvik.no": true, "aknoluokta.no": true, "xn--koluokta-7ya57h.no": true, "hattfjelldal.no": true, "aarborte.no": true, "haugesund.no": true, "hemne.no": true, "hemnes.no": true, "hemsedal.no": true, "heroy.more-og-romsdal.no": true, "xn--hery-ira.xn--mre-og-romsdal-qqb.no": true, "heroy.nordland.no": true, "xn--hery-ira.nordland.no": true, "hitra.no": true, "hjartdal.no": true, "hjelmeland.no": true, "hobol.no": true, "xn--hobl-ira.no": true, "hof.no": true, "hol.no": true, "hole.no": true, "holmestrand.no": true, "holtalen.no": true, "xn--holtlen-hxa.no": true, "hornindal.no": true, "horten.no": true, "hurdal.no": true, "hurum.no": true, "hvaler.no": true, "hyllestad.no": true, "hagebostad.no": true, "xn--hgebostad-g3a.no": true, "hoyanger.no": true, "xn--hyanger-q1a.no": true, "hoylandet.no": true, "xn--hylandet-54a.no": true, "ha.no": true, "xn--h-2fa.no": true, "ibestad.no": true, "inderoy.no": true, "xn--indery-fya.no": true, "iveland.no": true, "jevnaker.no": true, "jondal.no": true, "jolster.no": true, "xn--jlster-bya.no": true, "karasjok.no": true, "karasjohka.no": true, "xn--krjohka-hwab49j.no": true, "karlsoy.no": true, "galsa.no": true, "xn--gls-elac.no": true, "karmoy.no": true, "xn--karmy-yua.no": true, "kautokeino.no": true, "guovdageaidnu.no": true, "klepp.no": true, "klabu.no": true, "xn--klbu-woa.no": true, "kongsberg.no": true, "kongsvinger.no": true, "kragero.no": true, "xn--krager-gya.no": true, "kristiansand.no": true, "kristiansund.no": true, "krodsherad.no": true, "xn--krdsherad-m8a.no": true, "kvalsund.no": true, "rahkkeravju.no": true, "xn--rhkkervju-01af.no": true, "kvam.no": true, "kvinesdal.no": true, "kvinnherad.no": true, "kviteseid.no": true, "kvitsoy.no": true, "xn--kvitsy-fya.no": true, "kvafjord.no": true, "xn--kvfjord-nxa.no": true, "giehtavuoatna.no": true, "kvanangen.no": true, "xn--kvnangen-k0a.no": true, "navuotna.no": true, "xn--nvuotna-hwa.no": true, "kafjord.no": true, "xn--kfjord-iua.no": true, "gaivuotna.no": true, "xn--givuotna-8ya.no": true, "larvik.no": true, "lavangen.no": true, "lavagis.no": true, "loabat.no": true, "xn--loabt-0qa.no": true, "lebesby.no": true, "davvesiida.no": true, "leikanger.no": true, "leirfjord.no": true, "leka.no": true, "leksvik.no": true, "lenvik.no": true, "leangaviika.no": true, "xn--leagaviika-52b.no": true, "lesja.no": true, "levanger.no": true, "lier.no": true, "lierne.no": true, "lillehammer.no": true, "lillesand.no": true, "lindesnes.no": true, "lindas.no": true, "xn--linds-pra.no": true, "lom.no": true, "loppa.no": true, "lahppi.no": true, "xn--lhppi-xqa.no": true, "lund.no": true, "lunner.no": true, "luroy.no": true, "xn--lury-ira.no": true, "luster.no": true, "lyngdal.no": true, "lyngen.no": true, "ivgu.no": true, "lardal.no": true, "lerdal.no": true, "xn--lrdal-sra.no": true, "lodingen.no": true, "xn--ldingen-q1a.no": true, "lorenskog.no": true, "xn--lrenskog-54a.no": true, "loten.no": true, "xn--lten-gra.no": true, "malvik.no": true, "masoy.no": true, "xn--msy-ula0h.no": true, "muosat.no": true, "xn--muost-0qa.no": true, "mandal.no": true, "marker.no": true, "marnardal.no": true, "masfjorden.no": true, "meland.no": true, "meldal.no": true, "melhus.no": true, "meloy.no": true, "xn--mely-ira.no": true, "meraker.no": true, "xn--merker-kua.no": true, "moareke.no": true, "xn--moreke-jua.no": true, "midsund.no": true, "midtre-gauldal.no": true, "modalen.no": true, "modum.no": true, "molde.no": true, "moskenes.no": true, "moss.no": true, "mosvik.no": true, "malselv.no": true, "xn--mlselv-iua.no": true, "malatvuopmi.no": true, "xn--mlatvuopmi-s4a.no": true, "namdalseid.no": true, "aejrie.no": true, "namsos.no": true, "namsskogan.no": true, "naamesjevuemie.no": true, "xn--nmesjevuemie-tcba.no": true, "laakesvuemie.no": true, "nannestad.no": true, "narvik.no": true, "narviika.no": true, "naustdal.no": true, "nedre-eiker.no": true, "nes.akershus.no": true, "nes.buskerud.no": true, "nesna.no": true, "nesodden.no": true, "nesseby.no": true, "unjarga.no": true, "xn--unjrga-rta.no": true, "nesset.no": true, "nissedal.no": true, "nittedal.no": true, "nord-aurdal.no": true, "nord-fron.no": true, "nord-odal.no": true, "norddal.no": true, "nordkapp.no": true, "davvenjarga.no": true, "xn--davvenjrga-y4a.no": true, "nordre-land.no": true, "nordreisa.no": true, "raisa.no": true, "xn--risa-5na.no": true, "nore-og-uvdal.no": true, "notodden.no": true, "naroy.no": true, "xn--nry-yla5g.no": true, "notteroy.no": true, "xn--nttery-byae.no": true, "odda.no": true, "oksnes.no": true, "xn--ksnes-uua.no": true, "oppdal.no": true, "oppegard.no": true, "xn--oppegrd-ixa.no": true, "orkdal.no": true, "orland.no": true, "xn--rland-uua.no": true, "orskog.no": true, "xn--rskog-uua.no": true, "orsta.no": true, "xn--rsta-fra.no": true, "os.hedmark.no": true, "os.hordaland.no": true, "osen.no": true, "osteroy.no": true, "xn--ostery-fya.no": true, "ostre-toten.no": true, "xn--stre-toten-zcb.no": true, "overhalla.no": true, "ovre-eiker.no": true, "xn--vre-eiker-k8a.no": true, "oyer.no": true, "xn--yer-zna.no": true, "oygarden.no": true, "xn--ygarden-p1a.no": true, "oystre-slidre.no": true, "xn--ystre-slidre-ujb.no": true, "porsanger.no": true, "porsangu.no": true, "xn--porsgu-sta26f.no": true, "porsgrunn.no": true, "radoy.no": true, "xn--rady-ira.no": true, "rakkestad.no": true, "rana.no": true, "ruovat.no": true, "randaberg.no": true, "rauma.no": true, "rendalen.no": true, "rennebu.no": true, "rennesoy.no": true, "xn--rennesy-v1a.no": true, "rindal.no": true, "ringebu.no": true, "ringerike.no": true, "ringsaker.no": true, "rissa.no": true, "risor.no": true, "xn--risr-ira.no": true, "roan.no": true, "rollag.no": true, "rygge.no": true, "ralingen.no": true, "xn--rlingen-mxa.no": true, "rodoy.no": true, "xn--rdy-0nab.no": true, "romskog.no": true, "xn--rmskog-bya.no": true, "roros.no": true, "xn--rros-gra.no": true, "rost.no": true, "xn--rst-0na.no": true, "royken.no": true, "xn--ryken-vua.no": true, "royrvik.no": true, "xn--ryrvik-bya.no": true, "rade.no": true, "xn--rde-ula.no": true, "salangen.no": true, "siellak.no": true, "saltdal.no": true, "salat.no": true, "xn--slt-elab.no": true, "xn--slat-5na.no": true, "samnanger.no": true, "sande.more-og-romsdal.no": true, "sande.xn--mre-og-romsdal-qqb.no": true, "sande.vestfold.no": true, "sandefjord.no": true, "sandnes.no": true, "sandoy.no": true, "xn--sandy-yua.no": true, "sarpsborg.no": true, "sauda.no": true, "sauherad.no": true, "sel.no": true, "selbu.no": true, "selje.no": true, "seljord.no": true, "sigdal.no": true, "siljan.no": true, "sirdal.no": true, "skaun.no": true, "skedsmo.no": true, "ski.no": true, "skien.no": true, "skiptvet.no": true, "skjervoy.no": true, "xn--skjervy-v1a.no": true, "skierva.no": true, "xn--skierv-uta.no": true, "skjak.no": true, "xn--skjk-soa.no": true, "skodje.no": true, "skanland.no": true, "xn--sknland-fxa.no": true, "skanit.no": true, "xn--sknit-yqa.no": true, "smola.no": true, "xn--smla-hra.no": true, "snillfjord.no": true, "snasa.no": true, "xn--snsa-roa.no": true, "snoasa.no": true, "snaase.no": true, "xn--snase-nra.no": true, "sogndal.no": true, "sokndal.no": true, "sola.no": true, "solund.no": true, "songdalen.no": true, "sortland.no": true, "spydeberg.no": true, "stange.no": true, "stavanger.no": true, "steigen.no": true, "steinkjer.no": true, "stjordal.no": true, "xn--stjrdal-s1a.no": true, "stokke.no": true, "stor-elvdal.no": true, "stord.no": true, "stordal.no": true, "storfjord.no": true, "omasvuotna.no": true, "strand.no": true, "stranda.no": true, "stryn.no": true, "sula.no": true, "suldal.no": true, "sund.no": true, "sunndal.no": true, "surnadal.no": true, "sveio.no": true, "svelvik.no": true, "sykkylven.no": true, "sogne.no": true, "xn--sgne-gra.no": true, "somna.no": true, "xn--smna-gra.no": true, "sondre-land.no": true, "xn--sndre-land-0cb.no": true, "sor-aurdal.no": true, "xn--sr-aurdal-l8a.no": true, "sor-fron.no": true, "xn--sr-fron-q1a.no": true, "sor-odal.no": true, "xn--sr-odal-q1a.no": true, "sor-varanger.no": true, "xn--sr-varanger-ggb.no": true, "matta-varjjat.no": true, "xn--mtta-vrjjat-k7af.no": true, "sorfold.no": true, "xn--srfold-bya.no": true, "sorreisa.no": true, "xn--srreisa-q1a.no": true, "sorum.no": true, "xn--srum-gra.no": true, "tana.no": true, "deatnu.no": true, "time.no": true, "tingvoll.no": true, "tinn.no": true, "tjeldsund.no": true, "dielddanuorri.no": true, "tjome.no": true, "xn--tjme-hra.no": true, "tokke.no": true, "tolga.no": true, "torsken.no": true, "tranoy.no": true, "xn--trany-yua.no": true, "tromso.no": true, "xn--troms-zua.no": true, "tromsa.no": true, "romsa.no": true, "trondheim.no": true, "troandin.no": true, "trysil.no": true, "trana.no": true, "xn--trna-woa.no": true, "trogstad.no": true, "xn--trgstad-r1a.no": true, "tvedestrand.no": true, "tydal.no": true, "tynset.no": true, "tysfjord.no": true, "divtasvuodna.no": true, "divttasvuotna.no": true, "tysnes.no": true, "tysvar.no": true, "xn--tysvr-vra.no": true, "tonsberg.no": true, "xn--tnsberg-q1a.no": true, "ullensaker.no": true, "ullensvang.no": true, "ulvik.no": true, "utsira.no": true, "vadso.no": true, "xn--vads-jra.no": true, "cahcesuolo.no": true, "xn--hcesuolo-7ya35b.no": true, "vaksdal.no": true, "valle.no": true, "vang.no": true, "vanylven.no": true, "vardo.no": true, "xn--vard-jra.no": true, "varggat.no": true, "xn--vrggt-xqad.no": true, "vefsn.no": true, "vaapste.no": true, "vega.no": true, "vegarshei.no": true, "xn--vegrshei-c0a.no": true, "vennesla.no": true, "verdal.no": true, "verran.no": true, "vestby.no": true, "vestnes.no": true, "vestre-slidre.no": true, "vestre-toten.no": true, "vestvagoy.no": true, "xn--vestvgy-ixa6o.no": true, "vevelstad.no": true, "vik.no": true, "vikna.no": true, "vindafjord.no": true, "volda.no": true, "voss.no": true, "varoy.no": true, "xn--vry-yla5g.no": true, "vagan.no": true, "xn--vgan-qoa.no": true, "voagat.no": true, "vagsoy.no": true, "xn--vgsy-qoa0j.no": true, "vaga.no": true, "xn--vg-yiab.no": true, "valer.ostfold.no": true, "xn--vler-qoa.xn--stfold-9xa.no": true, "valer.hedmark.no": true, "xn--vler-qoa.hedmark.no": true, "*.np": true, "nr": true, "biz.nr": true, "info.nr": true, "gov.nr": true, "edu.nr": true, "org.nr": true, "net.nr": true, "com.nr": true, "nu": true, "nz": true, "ac.nz": true, "co.nz": true, "cri.nz": true, "geek.nz": true, "gen.nz": true, "govt.nz": true, "health.nz": true, "iwi.nz": true, "kiwi.nz": true, "maori.nz": true, "mil.nz": true, "xn--mori-qsa.nz": true, "net.nz": true, "org.nz": true, "parliament.nz": true, "school.nz": true, "om": true, "co.om": true, "com.om": true, "edu.om": true, "gov.om": true, "med.om": true, "museum.om": true, "net.om": true, "org.om": true, "pro.om": true, "onion": true, "org": true, "pa": true, "ac.pa": true, "gob.pa": true, "com.pa": true, "org.pa": true, "sld.pa": true, "edu.pa": true, "net.pa": true, "ing.pa": true, "abo.pa": true, "med.pa": true, "nom.pa": true, "pe": true, "edu.pe": true, "gob.pe": true, "nom.pe": true, "mil.pe": true, "org.pe": true, "com.pe": true, "net.pe": true, "pf": true, "com.pf": true, "org.pf": true, "edu.pf": true, "*.pg": true, "ph": true, "com.ph": true, "net.ph": true, "org.ph": true, "gov.ph": true, "edu.ph": true, "ngo.ph": true, "mil.ph": true, "i.ph": true, "pk": true, "com.pk": true, "net.pk": true, "edu.pk": true, "org.pk": true, "fam.pk": true, "biz.pk": true, "web.pk": true, "gov.pk": true, "gob.pk": true, "gok.pk": true, "gon.pk": true, "gop.pk": true, "gos.pk": true, "info.pk": true, "pl": true, "com.pl": true, "net.pl": true, "org.pl": true, "aid.pl": true, "agro.pl": true, "atm.pl": true, "auto.pl": true, "biz.pl": true, "edu.pl": true, "gmina.pl": true, "gsm.pl": true, "info.pl": true, "mail.pl": true, "miasta.pl": true, "media.pl": true, "mil.pl": true, "nieruchomosci.pl": true, "nom.pl": true, "pc.pl": true, "powiat.pl": true, "priv.pl": true, "realestate.pl": true, "rel.pl": true, "sex.pl": true, "shop.pl": true, "sklep.pl": true, "sos.pl": true, "szkola.pl": true, "targi.pl": true, "tm.pl": true, "tourism.pl": true, "travel.pl": true, "turystyka.pl": true, "gov.pl": true, "ap.gov.pl": true, "ic.gov.pl": true, "is.gov.pl": true, "us.gov.pl": true, "kmpsp.gov.pl": true, "kppsp.gov.pl": true, "kwpsp.gov.pl": true, "psp.gov.pl": true, "wskr.gov.pl": true, "kwp.gov.pl": true, "mw.gov.pl": true, "ug.gov.pl": true, "um.gov.pl": true, "umig.gov.pl": true, "ugim.gov.pl": true, "upow.gov.pl": true, "uw.gov.pl": true, "starostwo.gov.pl": true, "pa.gov.pl": true, "po.gov.pl": true, "psse.gov.pl": true, "pup.gov.pl": true, "rzgw.gov.pl": true, "sa.gov.pl": true, "so.gov.pl": true, "sr.gov.pl": true, "wsa.gov.pl": true, "sko.gov.pl": true, "uzs.gov.pl": true, "wiih.gov.pl": true, "winb.gov.pl": true, "pinb.gov.pl": true, "wios.gov.pl": true, "witd.gov.pl": true, "wzmiuw.gov.pl": true, "piw.gov.pl": true, "wiw.gov.pl": true, "griw.gov.pl": true, "wif.gov.pl": true, "oum.gov.pl": true, "sdn.gov.pl": true, "zp.gov.pl": true, "uppo.gov.pl": true, "mup.gov.pl": true, "wuoz.gov.pl": true, "konsulat.gov.pl": true, "oirm.gov.pl": true, "augustow.pl": true, "babia-gora.pl": true, "bedzin.pl": true, "beskidy.pl": true, "bialowieza.pl": true, "bialystok.pl": true, "bielawa.pl": true, "bieszczady.pl": true, "boleslawiec.pl": true, "bydgoszcz.pl": true, "bytom.pl": true, "cieszyn.pl": true, "czeladz.pl": true, "czest.pl": true, "dlugoleka.pl": true, "elblag.pl": true, "elk.pl": true, "glogow.pl": true, "gniezno.pl": true, "gorlice.pl": true, "grajewo.pl": true, "ilawa.pl": true, "jaworzno.pl": true, "jelenia-gora.pl": true, "jgora.pl": true, "kalisz.pl": true, "kazimierz-dolny.pl": true, "karpacz.pl": true, "kartuzy.pl": true, "kaszuby.pl": true, "katowice.pl": true, "kepno.pl": true, "ketrzyn.pl": true, "klodzko.pl": true, "kobierzyce.pl": true, "kolobrzeg.pl": true, "konin.pl": true, "konskowola.pl": true, "kutno.pl": true, "lapy.pl": true, "lebork.pl": true, "legnica.pl": true, "lezajsk.pl": true, "limanowa.pl": true, "lomza.pl": true, "lowicz.pl": true, "lubin.pl": true, "lukow.pl": true, "malbork.pl": true, "malopolska.pl": true, "mazowsze.pl": true, "mazury.pl": true, "mielec.pl": true, "mielno.pl": true, "mragowo.pl": true, "naklo.pl": true, "nowaruda.pl": true, "nysa.pl": true, "olawa.pl": true, "olecko.pl": true, "olkusz.pl": true, "olsztyn.pl": true, "opoczno.pl": true, "opole.pl": true, "ostroda.pl": true, "ostroleka.pl": true, "ostrowiec.pl": true, "ostrowwlkp.pl": true, "pila.pl": true, "pisz.pl": true, "podhale.pl": true, "podlasie.pl": true, "polkowice.pl": true, "pomorze.pl": true, "pomorskie.pl": true, "prochowice.pl": true, "pruszkow.pl": true, "przeworsk.pl": true, "pulawy.pl": true, "radom.pl": true, "rawa-maz.pl": true, "rybnik.pl": true, "rzeszow.pl": true, "sanok.pl": true, "sejny.pl": true, "slask.pl": true, "slupsk.pl": true, "sosnowiec.pl": true, "stalowa-wola.pl": true, "skoczow.pl": true, "starachowice.pl": true, "stargard.pl": true, "suwalki.pl": true, "swidnica.pl": true, "swiebodzin.pl": true, "swinoujscie.pl": true, "szczecin.pl": true, "szczytno.pl": true, "tarnobrzeg.pl": true, "tgory.pl": true, "turek.pl": true, "tychy.pl": true, "ustka.pl": true, "walbrzych.pl": true, "warmia.pl": true, "warszawa.pl": true, "waw.pl": true, "wegrow.pl": true, "wielun.pl": true, "wlocl.pl": true, "wloclawek.pl": true, "wodzislaw.pl": true, "wolomin.pl": true, "wroclaw.pl": true, "zachpomor.pl": true, "zagan.pl": true, "zarow.pl": true, "zgora.pl": true, "zgorzelec.pl": true, "pm": true, "pn": true, "gov.pn": true, "co.pn": true, "org.pn": true, "edu.pn": true, "net.pn": true, "post": true, "pr": true, "com.pr": true, "net.pr": true, "org.pr": true, "gov.pr": true, "edu.pr": true, "isla.pr": true, "pro.pr": true, "biz.pr": true, "info.pr": true, "name.pr": true, "est.pr": true, "prof.pr": true, "ac.pr": true, "pro": true, "aaa.pro": true, "aca.pro": true, "acct.pro": true, "avocat.pro": true, "bar.pro": true, "cpa.pro": true, "eng.pro": true, "jur.pro": true, "law.pro": true, "med.pro": true, "recht.pro": true, "ps": true, "edu.ps": true, "gov.ps": true, "sec.ps": true, "plo.ps": true, "com.ps": true, "org.ps": true, "net.ps": true, "pt": true, "net.pt": true, "gov.pt": true, "org.pt": true, "edu.pt": true, "int.pt": true, "publ.pt": true, "com.pt": true, "nome.pt": true, "pw": true, "co.pw": true, "ne.pw": true, "or.pw": true, "ed.pw": true, "go.pw": true, "belau.pw": true, "py": true, "com.py": true, "coop.py": true, "edu.py": true, "gov.py": true, "mil.py": true, "net.py": true, "org.py": true, "qa": true, "com.qa": true, "edu.qa": true, "gov.qa": true, "mil.qa": true, "name.qa": true, "net.qa": true, "org.qa": true, "sch.qa": true, "re": true, "asso.re": true, "com.re": true, "nom.re": true, "ro": true, "arts.ro": true, "com.ro": true, "firm.ro": true, "info.ro": true, "nom.ro": true, "nt.ro": true, "org.ro": true, "rec.ro": true, "store.ro": true, "tm.ro": true, "www.ro": true, "rs": true, "ac.rs": true, "co.rs": true, "edu.rs": true, "gov.rs": true, "in.rs": true, "org.rs": true, "ru": true, "ac.ru": true, "edu.ru": true, "gov.ru": true, "int.ru": true, "mil.ru": true, "test.ru": true, "rw": true, "gov.rw": true, "net.rw": true, "edu.rw": true, "ac.rw": true, "com.rw": true, "co.rw": true, "int.rw": true, "mil.rw": true, "gouv.rw": true, "sa": true, "com.sa": true, "net.sa": true, "org.sa": true, "gov.sa": true, "med.sa": true, "pub.sa": true, "edu.sa": true, "sch.sa": true, "sb": true, "com.sb": true, "edu.sb": true, "gov.sb": true, "net.sb": true, "org.sb": true, "sc": true, "com.sc": true, "gov.sc": true, "net.sc": true, "org.sc": true, "edu.sc": true, "sd": true, "com.sd": true, "net.sd": true, "org.sd": true, "edu.sd": true, "med.sd": true, "tv.sd": true, "gov.sd": true, "info.sd": true, "se": true, "a.se": true, "ac.se": true, "b.se": true, "bd.se": true, "brand.se": true, "c.se": true, "d.se": true, "e.se": true, "f.se": true, "fh.se": true, "fhsk.se": true, "fhv.se": true, "g.se": true, "h.se": true, "i.se": true, "k.se": true, "komforb.se": true, "kommunalforbund.se": true, "komvux.se": true, "l.se": true, "lanbib.se": true, "m.se": true, "n.se": true, "naturbruksgymn.se": true, "o.se": true, "org.se": true, "p.se": true, "parti.se": true, "pp.se": true, "press.se": true, "r.se": true, "s.se": true, "t.se": true, "tm.se": true, "u.se": true, "w.se": true, "x.se": true, "y.se": true, "z.se": true, "sg": true, "com.sg": true, "net.sg": true, "org.sg": true, "gov.sg": true, "edu.sg": true, "per.sg": true, "sh": true, "com.sh": true, "net.sh": true, "gov.sh": true, "org.sh": true, "mil.sh": true, "si": true, "sj": true, "sk": true, "sl": true, "com.sl": true, "net.sl": true, "edu.sl": true, "gov.sl": true, "org.sl": true, "sm": true, "sn": true, "art.sn": true, "com.sn": true, "edu.sn": true, "gouv.sn": true, "org.sn": true, "perso.sn": true, "univ.sn": true, "so": true, "com.so": true, "net.so": true, "org.so": true, "sr": true, "st": true, "co.st": true, "com.st": true, "consulado.st": true, "edu.st": true, "embaixada.st": true, "gov.st": true, "mil.st": true, "net.st": true, "org.st": true, "principe.st": true, "saotome.st": true, "store.st": true, "su": true, "sv": true, "com.sv": true, "edu.sv": true, "gob.sv": true, "org.sv": true, "red.sv": true, "sx": true, "gov.sx": true, "sy": true, "edu.sy": true, "gov.sy": true, "net.sy": true, "mil.sy": true, "com.sy": true, "org.sy": true, "sz": true, "co.sz": true, "ac.sz": true, "org.sz": true, "tc": true, "td": true, "tel": true, "tf": true, "tg": true, "th": true, "ac.th": true, "co.th": true, "go.th": true, "in.th": true, "mi.th": true, "net.th": true, "or.th": true, "tj": true, "ac.tj": true, "biz.tj": true, "co.tj": true, "com.tj": true, "edu.tj": true, "go.tj": true, "gov.tj": true, "int.tj": true, "mil.tj": true, "name.tj": true, "net.tj": true, "nic.tj": true, "org.tj": true, "test.tj": true, "web.tj": true, "tk": true, "tl": true, "gov.tl": true, "tm": true, "com.tm": true, "co.tm": true, "org.tm": true, "net.tm": true, "nom.tm": true, "gov.tm": true, "mil.tm": true, "edu.tm": true, "tn": true, "com.tn": true, "ens.tn": true, "fin.tn": true, "gov.tn": true, "ind.tn": true, "intl.tn": true, "nat.tn": true, "net.tn": true, "org.tn": true, "info.tn": true, "perso.tn": true, "tourism.tn": true, "edunet.tn": true, "rnrt.tn": true, "rns.tn": true, "rnu.tn": true, "mincom.tn": true, "agrinet.tn": true, "defense.tn": true, "turen.tn": true, "to": true, "com.to": true, "gov.to": true, "net.to": true, "org.to": true, "edu.to": true, "mil.to": true, "tr": true, "com.tr": true, "info.tr": true, "biz.tr": true, "net.tr": true, "org.tr": true, "web.tr": true, "gen.tr": true, "tv.tr": true, "av.tr": true, "dr.tr": true, "bbs.tr": true, "name.tr": true, "tel.tr": true, "gov.tr": true, "bel.tr": true, "pol.tr": true, "mil.tr": true, "k12.tr": true, "edu.tr": true, "kep.tr": true, "nc.tr": true, "gov.nc.tr": true, "travel": true, "tt": true, "co.tt": true, "com.tt": true, "org.tt": true, "net.tt": true, "biz.tt": true, "info.tt": true, "pro.tt": true, "int.tt": true, "coop.tt": true, "jobs.tt": true, "mobi.tt": true, "travel.tt": true, "museum.tt": true, "aero.tt": true, "name.tt": true, "gov.tt": true, "edu.tt": true, "tv": true, "tw": true, "edu.tw": true, "gov.tw": true, "mil.tw": true, "com.tw": true, "net.tw": true, "org.tw": true, "idv.tw": true, "game.tw": true, "ebiz.tw": true, "club.tw": true, "xn--zf0ao64a.tw": true, "xn--uc0atv.tw": true, "xn--czrw28b.tw": true, "tz": true, "ac.tz": true, "co.tz": true, "go.tz": true, "hotel.tz": true, "info.tz": true, "me.tz": true, "mil.tz": true, "mobi.tz": true, "ne.tz": true, "or.tz": true, "sc.tz": true, "tv.tz": true, "ua": true, "com.ua": true, "edu.ua": true, "gov.ua": true, "in.ua": true, "net.ua": true, "org.ua": true, "cherkassy.ua": true, "cherkasy.ua": true, "chernigov.ua": true, "chernihiv.ua": true, "chernivtsi.ua": true, "chernovtsy.ua": true, "ck.ua": true, "cn.ua": true, "cr.ua": true, "crimea.ua": true, "cv.ua": true, "dn.ua": true, "dnepropetrovsk.ua": true, "dnipropetrovsk.ua": true, "dominic.ua": true, "donetsk.ua": true, "dp.ua": true, "if.ua": true, "ivano-frankivsk.ua": true, "kh.ua": true, "kharkiv.ua": true, "kharkov.ua": true, "kherson.ua": true, "khmelnitskiy.ua": true, "khmelnytskyi.ua": true, "kiev.ua": true, "kirovograd.ua": true, "km.ua": true, "kr.ua": true, "krym.ua": true, "ks.ua": true, "kv.ua": true, "kyiv.ua": true, "lg.ua": true, "lt.ua": true, "lugansk.ua": true, "lutsk.ua": true, "lv.ua": true, "lviv.ua": true, "mk.ua": true, "mykolaiv.ua": true, "nikolaev.ua": true, "od.ua": true, "odesa.ua": true, "odessa.ua": true, "pl.ua": true, "poltava.ua": true, "rivne.ua": true, "rovno.ua": true, "rv.ua": true, "sb.ua": true, "sebastopol.ua": true, "sevastopol.ua": true, "sm.ua": true, "sumy.ua": true, "te.ua": true, "ternopil.ua": true, "uz.ua": true, "uzhgorod.ua": true, "vinnica.ua": true, "vinnytsia.ua": true, "vn.ua": true, "volyn.ua": true, "yalta.ua": true, "zaporizhzhe.ua": true, "zaporizhzhia.ua": true, "zhitomir.ua": true, "zhytomyr.ua": true, "zp.ua": true, "zt.ua": true, "ug": true, "co.ug": true, "or.ug": true, "ac.ug": true, "sc.ug": true, "go.ug": true, "ne.ug": true, "com.ug": true, "org.ug": true, "uk": true, "ac.uk": true, "co.uk": true, "gov.uk": true, "ltd.uk": true, "me.uk": true, "net.uk": true, "nhs.uk": true, "org.uk": true, "plc.uk": true, "police.uk": true, "*.sch.uk": true, "us": true, "dni.us": true, "fed.us": true, "isa.us": true, "kids.us": true, "nsn.us": true, "ak.us": true, "al.us": true, "ar.us": true, "as.us": true, "az.us": true, "ca.us": true, "co.us": true, "ct.us": true, "dc.us": true, "de.us": true, "fl.us": true, "ga.us": true, "gu.us": true, "hi.us": true, "ia.us": true, "id.us": true, "il.us": true, "in.us": true, "ks.us": true, "ky.us": true, "la.us": true, "ma.us": true, "md.us": true, "me.us": true, "mi.us": true, "mn.us": true, "mo.us": true, "ms.us": true, "mt.us": true, "nc.us": true, "nd.us": true, "ne.us": true, "nh.us": true, "nj.us": true, "nm.us": true, "nv.us": true, "ny.us": true, "oh.us": true, "ok.us": true, "or.us": true, "pa.us": true, "pr.us": true, "ri.us": true, "sc.us": true, "sd.us": true, "tn.us": true, "tx.us": true, "ut.us": true, "vi.us": true, "vt.us": true, "va.us": true, "wa.us": true, "wi.us": true, "wv.us": true, "wy.us": true, "k12.ak.us": true, "k12.al.us": true, "k12.ar.us": true, "k12.as.us": true, "k12.az.us": true, "k12.ca.us": true, "k12.co.us": true, "k12.ct.us": true, "k12.dc.us": true, "k12.de.us": true, "k12.fl.us": true, "k12.ga.us": true, "k12.gu.us": true, "k12.ia.us": true, "k12.id.us": true, "k12.il.us": true, "k12.in.us": true, "k12.ks.us": true, "k12.ky.us": true, "k12.la.us": true, "k12.ma.us": true, "k12.md.us": true, "k12.me.us": true, "k12.mi.us": true, "k12.mn.us": true, "k12.mo.us": true, "k12.ms.us": true, "k12.mt.us": true, "k12.nc.us": true, "k12.ne.us": true, "k12.nh.us": true, "k12.nj.us": true, "k12.nm.us": true, "k12.nv.us": true, "k12.ny.us": true, "k12.oh.us": true, "k12.ok.us": true, "k12.or.us": true, "k12.pa.us": true, "k12.pr.us": true, "k12.ri.us": true, "k12.sc.us": true, "k12.tn.us": true, "k12.tx.us": true, "k12.ut.us": true, "k12.vi.us": true, "k12.vt.us": true, "k12.va.us": true, "k12.wa.us": true, "k12.wi.us": true, "k12.wy.us": true, "cc.ak.us": true, "cc.al.us": true, "cc.ar.us": true, "cc.as.us": true, "cc.az.us": true, "cc.ca.us": true, "cc.co.us": true, "cc.ct.us": true, "cc.dc.us": true, "cc.de.us": true, "cc.fl.us": true, "cc.ga.us": true, "cc.gu.us": true, "cc.hi.us": true, "cc.ia.us": true, "cc.id.us": true, "cc.il.us": true, "cc.in.us": true, "cc.ks.us": true, "cc.ky.us": true, "cc.la.us": true, "cc.ma.us": true, "cc.md.us": true, "cc.me.us": true, "cc.mi.us": true, "cc.mn.us": true, "cc.mo.us": true, "cc.ms.us": true, "cc.mt.us": true, "cc.nc.us": true, "cc.nd.us": true, "cc.ne.us": true, "cc.nh.us": true, "cc.nj.us": true, "cc.nm.us": true, "cc.nv.us": true, "cc.ny.us": true, "cc.oh.us": true, "cc.ok.us": true, "cc.or.us": true, "cc.pa.us": true, "cc.pr.us": true, "cc.ri.us": true, "cc.sc.us": true, "cc.sd.us": true, "cc.tn.us": true, "cc.tx.us": true, "cc.ut.us": true, "cc.vi.us": true, "cc.vt.us": true, "cc.va.us": true, "cc.wa.us": true, "cc.wi.us": true, "cc.wv.us": true, "cc.wy.us": true, "lib.ak.us": true, "lib.al.us": true, "lib.ar.us": true, "lib.as.us": true, "lib.az.us": true, "lib.ca.us": true, "lib.co.us": true, "lib.ct.us": true, "lib.dc.us": true, "lib.fl.us": true, "lib.ga.us": true, "lib.gu.us": true, "lib.hi.us": true, "lib.ia.us": true, "lib.id.us": true, "lib.il.us": true, "lib.in.us": true, "lib.ks.us": true, "lib.ky.us": true, "lib.la.us": true, "lib.ma.us": true, "lib.md.us": true, "lib.me.us": true, "lib.mi.us": true, "lib.mn.us": true, "lib.mo.us": true, "lib.ms.us": true, "lib.mt.us": true, "lib.nc.us": true, "lib.nd.us": true, "lib.ne.us": true, "lib.nh.us": true, "lib.nj.us": true, "lib.nm.us": true, "lib.nv.us": true, "lib.ny.us": true, "lib.oh.us": true, "lib.ok.us": true, "lib.or.us": true, "lib.pa.us": true, "lib.pr.us": true, "lib.ri.us": true, "lib.sc.us": true, "lib.sd.us": true, "lib.tn.us": true, "lib.tx.us": true, "lib.ut.us": true, "lib.vi.us": true, "lib.vt.us": true, "lib.va.us": true, "lib.wa.us": true, "lib.wi.us": true, "lib.wy.us": true, "pvt.k12.ma.us": true, "chtr.k12.ma.us": true, "paroch.k12.ma.us": true, "ann-arbor.mi.us": true, "cog.mi.us": true, "dst.mi.us": true, "eaton.mi.us": true, "gen.mi.us": true, "mus.mi.us": true, "tec.mi.us": true, "washtenaw.mi.us": true, "uy": true, "com.uy": true, "edu.uy": true, "gub.uy": true, "mil.uy": true, "net.uy": true, "org.uy": true, "uz": true, "co.uz": true, "com.uz": true, "net.uz": true, "org.uz": true, "va": true, "vc": true, "com.vc": true, "net.vc": true, "org.vc": true, "gov.vc": true, "mil.vc": true, "edu.vc": true, "ve": true, "arts.ve": true, "co.ve": true, "com.ve": true, "e12.ve": true, "edu.ve": true, "firm.ve": true, "gob.ve": true, "gov.ve": true, "info.ve": true, "int.ve": true, "mil.ve": true, "net.ve": true, "org.ve": true, "rec.ve": true, "store.ve": true, "tec.ve": true, "web.ve": true, "vg": true, "vi": true, "co.vi": true, "com.vi": true, "k12.vi": true, "net.vi": true, "org.vi": true, "vn": true, "com.vn": true, "net.vn": true, "org.vn": true, "edu.vn": true, "gov.vn": true, "int.vn": true, "ac.vn": true, "biz.vn": true, "info.vn": true, "name.vn": true, "pro.vn": true, "health.vn": true, "vu": true, "com.vu": true, "edu.vu": true, "net.vu": true, "org.vu": true, "wf": true, "ws": true, "com.ws": true, "net.ws": true, "org.ws": true, "gov.ws": true, "edu.ws": true, "yt": true, "xn--mgbaam7a8h": true, "xn--y9a3aq": true, "xn--54b7fta0cc": true, "xn--90ae": true, "xn--90ais": true, "xn--fiqs8s": true, "xn--fiqz9s": true, "xn--lgbbat1ad8j": true, "xn--wgbh1c": true, "xn--e1a4c": true, "xn--node": true, "xn--qxam": true, "xn--j6w193g": true, "xn--2scrj9c": true, "xn--3hcrj9c": true, "xn--45br5cyl": true, "xn--h2breg3eve": true, "xn--h2brj9c8c": true, "xn--mgbgu82a": true, "xn--rvc1e0am3e": true, "xn--h2brj9c": true, "xn--mgbbh1a71e": true, "xn--fpcrj9c3d": true, "xn--gecrj9c": true, "xn--s9brj9c": true, "xn--45brj9c": true, "xn--xkc2dl3a5ee0h": true, "xn--mgba3a4f16a": true, "xn--mgba3a4fra": true, "xn--mgbtx2b": true, "xn--mgbayh7gpa": true, "xn--3e0b707e": true, "xn--80ao21a": true, "xn--fzc2c9e2c": true, "xn--xkc2al3hye2a": true, "xn--mgbc0a9azcg": true, "xn--d1alf": true, "xn--l1acc": true, "xn--mix891f": true, "xn--mix082f": true, "xn--mgbx4cd0ab": true, "xn--mgb9awbf": true, "xn--mgbai9azgqp6j": true, "xn--mgbai9a5eva00b": true, "xn--ygbi2ammx": true, "xn--90a3ac": true, "xn--o1ac.xn--90a3ac": true, "xn--c1avg.xn--90a3ac": true, "xn--90azh.xn--90a3ac": true, "xn--d1at.xn--90a3ac": true, "xn--o1ach.xn--90a3ac": true, "xn--80au.xn--90a3ac": true, "xn--p1ai": true, "xn--wgbl6a": true, "xn--mgberp4a5d4ar": true, "xn--mgberp4a5d4a87g": true, "xn--mgbqly7c0a67fbc": true, "xn--mgbqly7cvafr": true, "xn--mgbpl2fh": true, "xn--yfro4i67o": true, "xn--clchc0ea0b2g2a9gcd": true, "xn--ogbpf8fl": true, "xn--mgbtf8fl": true, "xn--o3cw4h": true, "xn--12c1fe0br.xn--o3cw4h": true, "xn--12co0c3b4eva.xn--o3cw4h": true, "xn--h3cuzk1di.xn--o3cw4h": true, "xn--o3cyx2a.xn--o3cw4h": true, "xn--m3ch0j3a.xn--o3cw4h": true, "xn--12cfi8ixb8l.xn--o3cw4h": true, "xn--pgbs0dh": true, "xn--kpry57d": true, "xn--kprw13d": true, "xn--nnx388a": true, "xn--j1amh": true, "xn--mgb2ddes": true, "xxx": true, "*.ye": true, "ac.za": true, "agric.za": true, "alt.za": true, "co.za": true, "edu.za": true, "gov.za": true, "grondar.za": true, "law.za": true, "mil.za": true, "net.za": true, "ngo.za": true, "nis.za": true, "nom.za": true, "org.za": true, "school.za": true, "tm.za": true, "web.za": true, "zm": true, "ac.zm": true, "biz.zm": true, "co.zm": true, "com.zm": true, "edu.zm": true, "gov.zm": true, "info.zm": true, "mil.zm": true, "net.zm": true, "org.zm": true, "sch.zm": true, "zw": true, "ac.zw": true, "co.zw": true, "gov.zw": true, "mil.zw": true, "org.zw": true, "aaa": true, "aarp": true, "abarth": true, "abb": true, "abbott": true, "abbvie": true, "abc": true, "able": true, "abogado": true, "abudhabi": true, "academy": true, "accenture": true, "accountant": true, "accountants": true, "aco": true, "active": true, "actor": true, "adac": true, "ads": true, "adult": true, "aeg": true, "aetna": true, "afamilycompany": true, "afl": true, "africa": true, "agakhan": true, "agency": true, "aig": true, "aigo": true, "airbus": true, "airforce": true, "airtel": true, "akdn": true, "alfaromeo": true, "alibaba": true, "alipay": true, "allfinanz": true, "allstate": true, "ally": true, "alsace": true, "alstom": true, "americanexpress": true, "americanfamily": true, "amex": true, "amfam": true, "amica": true, "amsterdam": true, "analytics": true, "android": true, "anquan": true, "anz": true, "aol": true, "apartments": true, "app": true, "apple": true, "aquarelle": true, "arab": true, "aramco": true, "archi": true, "army": true, "art": true, "arte": true, "asda": true, "associates": true, "athleta": true, "attorney": true, "auction": true, "audi": true, "audible": true, "audio": true, "auspost": true, "author": true, "auto": true, "autos": true, "avianca": true, "aws": true, "axa": true, "azure": true, "baby": true, "baidu": true, "banamex": true, "bananarepublic": true, "band": true, "bank": true, "bar": true, "barcelona": true, "barclaycard": true, "barclays": true, "barefoot": true, "bargains": true, "baseball": true, "basketball": true, "bauhaus": true, "bayern": true, "bbc": true, "bbt": true, "bbva": true, "bcg": true, "bcn": true, "beats": true, "beauty": true, "beer": true, "bentley": true, "berlin": true, "best": true, "bestbuy": true, "bet": true, "bharti": true, "bible": true, "bid": true, "bike": true, "bing": true, "bingo": true, "bio": true, "black": true, "blackfriday": true, "blanco": true, "blockbuster": true, "blog": true, "bloomberg": true, "blue": true, "bms": true, "bmw": true, "bnl": true, "bnpparibas": true, "boats": true, "boehringer": true, "bofa": true, "bom": true, "bond": true, "boo": true, "book": true, "booking": true, "boots": true, "bosch": true, "bostik": true, "boston": true, "bot": true, "boutique": true, "box": true, "bradesco": true, "bridgestone": true, "broadway": true, "broker": true, "brother": true, "brussels": true, "budapest": true, "bugatti": true, "build": true, "builders": true, "business": true, "buy": true, "buzz": true, "bzh": true, "cab": true, "cafe": true, "cal": true, "call": true, "calvinklein": true, "cam": true, "camera": true, "camp": true, "cancerresearch": true, "canon": true, "capetown": true, "capital": true, "capitalone": true, "car": true, "caravan": true, "cards": true, "care": true, "career": true, "careers": true, "cars": true, "cartier": true, "casa": true, "case": true, "caseih": true, "cash": true, "casino": true, "catering": true, "catholic": true, "cba": true, "cbn": true, "cbre": true, "cbs": true, "ceb": true, "center": true, "ceo": true, "cern": true, "cfa": true, "cfd": true, "chanel": true, "channel": true, "chase": true, "chat": true, "cheap": true, "chintai": true, "christmas": true, "chrome": true, "chrysler": true, "church": true, "cipriani": true, "circle": true, "cisco": true, "citadel": true, "citi": true, "citic": true, "city": true, "cityeats": true, "claims": true, "cleaning": true, "click": true, "clinic": true, "clinique": true, "clothing": true, "cloud": true, "club": true, "clubmed": true, "coach": true, "codes": true, "coffee": true, "college": true, "cologne": true, "comcast": true, "commbank": true, "community": true, "company": true, "compare": true, "computer": true, "comsec": true, "condos": true, "construction": true, "consulting": true, "contact": true, "contractors": true, "cooking": true, "cookingchannel": true, "cool": true, "corsica": true, "country": true, "coupon": true, "coupons": true, "courses": true, "credit": true, "creditcard": true, "creditunion": true, "cricket": true, "crown": true, "crs": true, "cruise": true, "cruises": true, "csc": true, "cuisinella": true, "cymru": true, "cyou": true, "dabur": true, "dad": true, "dance": true, "data": true, "date": true, "dating": true, "datsun": true, "day": true, "dclk": true, "dds": true, "deal": true, "dealer": true, "deals": true, "degree": true, "delivery": true, "dell": true, "deloitte": true, "delta": true, "democrat": true, "dental": true, "dentist": true, "desi": true, "design": true, "dev": true, "dhl": true, "diamonds": true, "diet": true, "digital": true, "direct": true, "directory": true, "discount": true, "discover": true, "dish": true, "diy": true, "dnp": true, "docs": true, "doctor": true, "dodge": true, "dog": true, "doha": true, "domains": true, "dot": true, "download": true, "drive": true, "dtv": true, "dubai": true, "duck": true, "dunlop": true, "duns": true, "dupont": true, "durban": true, "dvag": true, "dvr": true, "earth": true, "eat": true, "eco": true, "edeka": true, "education": true, "email": true, "emerck": true, "energy": true, "engineer": true, "engineering": true, "enterprises": true, "epost": true, "epson": true, "equipment": true, "ericsson": true, "erni": true, "esq": true, "estate": true, "esurance": true, "etisalat": true, "eurovision": true, "eus": true, "events": true, "everbank": true, "exchange": true, "expert": true, "exposed": true, "express": true, "extraspace": true, "fage": true, "fail": true, "fairwinds": true, "faith": true, "family": true, "fan": true, "fans": true, "farm": true, "farmers": true, "fashion": true, "fast": true, "fedex": true, "feedback": true, "ferrari": true, "ferrero": true, "fiat": true, "fidelity": true, "fido": true, "film": true, "final": true, "finance": true, "financial": true, "fire": true, "firestone": true, "firmdale": true, "fish": true, "fishing": true, "fit": true, "fitness": true, "flickr": true, "flights": true, "flir": true, "florist": true, "flowers": true, "fly": true, "foo": true, "food": true, "foodnetwork": true, "football": true, "ford": true, "forex": true, "forsale": true, "forum": true, "foundation": true, "fox": true, "free": true, "fresenius": true, "frl": true, "frogans": true, "frontdoor": true, "frontier": true, "ftr": true, "fujitsu": true, "fujixerox": true, "fun": true, "fund": true, "furniture": true, "futbol": true, "fyi": true, "gal": true, "gallery": true, "gallo": true, "gallup": true, "game": true, "games": true, "gap": true, "garden": true, "gbiz": true, "gdn": true, "gea": true, "gent": true, "genting": true, "george": true, "ggee": true, "gift": true, "gifts": true, "gives": true, "giving": true, "glade": true, "glass": true, "gle": true, "global": true, "globo": true, "gmail": true, "gmbh": true, "gmo": true, "gmx": true, "godaddy": true, "gold": true, "goldpoint": true, "golf": true, "goo": true, "goodhands": true, "goodyear": true, "goog": true, "google": true, "gop": true, "got": true, "grainger": true, "graphics": true, "gratis": true, "green": true, "gripe": true, "grocery": true, "group": true, "guardian": true, "gucci": true, "guge": true, "guide": true, "guitars": true, "guru": true, "hair": true, "hamburg": true, "hangout": true, "haus": true, "hbo": true, "hdfc": true, "hdfcbank": true, "health": true, "healthcare": true, "help": true, "helsinki": true, "here": true, "hermes": true, "hgtv": true, "hiphop": true, "hisamitsu": true, "hitachi": true, "hiv": true, "hkt": true, "hockey": true, "holdings": true, "holiday": true, "homedepot": true, "homegoods": true, "homes": true, "homesense": true, "honda": true, "honeywell": true, "horse": true, "hospital": true, "host": true, "hosting": true, "hot": true, "hoteles": true, "hotels": true, "hotmail": true, "house": true, "how": true, "hsbc": true, "hughes": true, "hyatt": true, "hyundai": true, "ibm": true, "icbc": true, "ice": true, "icu": true, "ieee": true, "ifm": true, "ikano": true, "imamat": true, "imdb": true, "immo": true, "immobilien": true, "industries": true, "infiniti": true, "ing": true, "ink": true, "institute": true, "insurance": true, "insure": true, "intel": true, "international": true, "intuit": true, "investments": true, "ipiranga": true, "irish": true, "iselect": true, "ismaili": true, "ist": true, "istanbul": true, "itau": true, "itv": true, "iveco": true, "iwc": true, "jaguar": true, "java": true, "jcb": true, "jcp": true, "jeep": true, "jetzt": true, "jewelry": true, "jio": true, "jlc": true, "jll": true, "jmp": true, "jnj": true, "joburg": true, "jot": true, "joy": true, "jpmorgan": true, "jprs": true, "juegos": true, "juniper": true, "kaufen": true, "kddi": true, "kerryhotels": true, "kerrylogistics": true, "kerryproperties": true, "kfh": true, "kia": true, "kim": true, "kinder": true, "kindle": true, "kitchen": true, "kiwi": true, "koeln": true, "komatsu": true, "kosher": true, "kpmg": true, "kpn": true, "krd": true, "kred": true, "kuokgroup": true, "kyoto": true, "lacaixa": true, "ladbrokes": true, "lamborghini": true, "lamer": true, "lancaster": true, "lancia": true, "lancome": true, "land": true, "landrover": true, "lanxess": true, "lasalle": true, "lat": true, "latino": true, "latrobe": true, "law": true, "lawyer": true, "lds": true, "lease": true, "leclerc": true, "lefrak": true, "legal": true, "lego": true, "lexus": true, "lgbt": true, "liaison": true, "lidl": true, "life": true, "lifeinsurance": true, "lifestyle": true, "lighting": true, "like": true, "lilly": true, "limited": true, "limo": true, "lincoln": true, "linde": true, "link": true, "lipsy": true, "live": true, "living": true, "lixil": true, "loan": true, "loans": true, "locker": true, "locus": true, "loft": true, "lol": true, "london": true, "lotte": true, "lotto": true, "love": true, "lpl": true, "lplfinancial": true, "ltd": true, "ltda": true, "lundbeck": true, "lupin": true, "luxe": true, "luxury": true, "macys": true, "madrid": true, "maif": true, "maison": true, "makeup": true, "man": true, "management": true, "mango": true, "map": true, "market": true, "marketing": true, "markets": true, "marriott": true, "marshalls": true, "maserati": true, "mattel": true, "mba": true, "mckinsey": true, "med": true, "media": true, "meet": true, "melbourne": true, "meme": true, "memorial": true, "men": true, "menu": true, "meo": true, "merckmsd": true, "metlife": true, "miami": true, "microsoft": true, "mini": true, "mint": true, "mit": true, "mitsubishi": true, "mlb": true, "mls": true, "mma": true, "mobile": true, "mobily": true, "moda": true, "moe": true, "moi": true, "mom": true, "monash": true, "money": true, "monster": true, "mopar": true, "mormon": true, "mortgage": true, "moscow": true, "moto": true, "motorcycles": true, "mov": true, "movie": true, "movistar": true, "msd": true, "mtn": true, "mtpc": true, "mtr": true, "mutual": true, "nab": true, "nadex": true, "nagoya": true, "nationwide": true, "natura": true, "navy": true, "nba": true, "nec": true, "netbank": true, "netflix": true, "network": true, "neustar": true, "new": true, "newholland": true, "news": true, "next": true, "nextdirect": true, "nexus": true, "nfl": true, "ngo": true, "nhk": true, "nico": true, "nike": true, "nikon": true, "ninja": true, "nissan": true, "nissay": true, "nokia": true, "northwesternmutual": true, "norton": true, "now": true, "nowruz": true, "nowtv": true, "nra": true, "nrw": true, "ntt": true, "nyc": true, "obi": true, "observer": true, "off": true, "office": true, "okinawa": true, "olayan": true, "olayangroup": true, "oldnavy": true, "ollo": true, "omega": true, "one": true, "ong": true, "onl": true, "online": true, "onyourside": true, "ooo": true, "open": true, "oracle": true, "orange": true, "organic": true, "origins": true, "osaka": true, "otsuka": true, "ott": true, "ovh": true, "page": true, "panasonic": true, "panerai": true, "paris": true, "pars": true, "partners": true, "parts": true, "party": true, "passagens": true, "pay": true, "pccw": true, "pet": true, "pfizer": true, "pharmacy": true, "phd": true, "philips": true, "phone": true, "photo": true, "photography": true, "photos": true, "physio": true, "piaget": true, "pics": true, "pictet": true, "pictures": true, "pid": true, "pin": true, "ping": true, "pink": true, "pioneer": true, "pizza": true, "place": true, "play": true, "playstation": true, "plumbing": true, "plus": true, "pnc": true, "pohl": true, "poker": true, "politie": true, "porn": true, "pramerica": true, "praxi": true, "press": true, "prime": true, "prod": true, "productions": true, "prof": true, "progressive": true, "promo": true, "properties": true, "property": true, "protection": true, "pru": true, "prudential": true, "pub": true, "pwc": true, "qpon": true, "quebec": true, "quest": true, "qvc": true, "racing": true, "radio": true, "raid": true, "read": true, "realestate": true, "realtor": true, "realty": true, "recipes": true, "red": true, "redstone": true, "redumbrella": true, "rehab": true, "reise": true, "reisen": true, "reit": true, "reliance": true, "ren": true, "rent": true, "rentals": true, "repair": true, "report": true, "republican": true, "rest": true, "restaurant": true, "review": true, "reviews": true, "rexroth": true, "rich": true, "richardli": true, "ricoh": true, "rightathome": true, "ril": true, "rio": true, "rip": true, "rmit": true, "rocher": true, "rocks": true, "rodeo": true, "rogers": true, "room": true, "rsvp": true, "rugby": true, "ruhr": true, "run": true, "rwe": true, "ryukyu": true, "saarland": true, "safe": true, "safety": true, "sakura": true, "sale": true, "salon": true, "samsclub": true, "samsung": true, "sandvik": true, "sandvikcoromant": true, "sanofi": true, "sap": true, "sapo": true, "sarl": true, "sas": true, "save": true, "saxo": true, "sbi": true, "sbs": true, "sca": true, "scb": true, "schaeffler": true, "schmidt": true, "scholarships": true, "school": true, "schule": true, "schwarz": true, "science": true, "scjohnson": true, "scor": true, "scot": true, "search": true, "seat": true, "secure": true, "security": true, "seek": true, "select": true, "sener": true, "services": true, "ses": true, "seven": true, "sew": true, "sex": true, "sexy": true, "sfr": true, "shangrila": true, "sharp": true, "shaw": true, "shell": true, "shia": true, "shiksha": true, "shoes": true, "shop": true, "shopping": true, "shouji": true, "show": true, "showtime": true, "shriram": true, "silk": true, "sina": true, "singles": true, "site": true, "ski": true, "skin": true, "sky": true, "skype": true, "sling": true, "smart": true, "smile": true, "sncf": true, "soccer": true, "social": true, "softbank": true, "software": true, "sohu": true, "solar": true, "solutions": true, "song": true, "sony": true, "soy": true, "space": true, "spiegel": true, "spot": true, "spreadbetting": true, "srl": true, "srt": true, "stada": true, "staples": true, "star": true, "starhub": true, "statebank": true, "statefarm": true, "statoil": true, "stc": true, "stcgroup": true, "stockholm": true, "storage": true, "store": true, "stream": true, "studio": true, "study": true, "style": true, "sucks": true, "supplies": true, "supply": true, "support": true, "surf": true, "surgery": true, "suzuki": true, "swatch": true, "swiftcover": true, "swiss": true, "sydney": true, "symantec": true, "systems": true, "tab": true, "taipei": true, "talk": true, "taobao": true, "target": true, "tatamotors": true, "tatar": true, "tattoo": true, "tax": true, "taxi": true, "tci": true, "tdk": true, "team": true, "tech": true, "technology": true, "telecity": true, "telefonica": true, "temasek": true, "tennis": true, "teva": true, "thd": true, "theater": true, "theatre": true, "tiaa": true, "tickets": true, "tienda": true, "tiffany": true, "tips": true, "tires": true, "tirol": true, "tjmaxx": true, "tjx": true, "tkmaxx": true, "tmall": true, "today": true, "tokyo": true, "tools": true, "top": true, "toray": true, "toshiba": true, "total": true, "tours": true, "town": true, "toyota": true, "toys": true, "trade": true, "trading": true, "training": true, "travelchannel": true, "travelers": true, "travelersinsurance": true, "trust": true, "trv": true, "tube": true, "tui": true, "tunes": true, "tushu": true, "tvs": true, "ubank": true, "ubs": true, "uconnect": true, "unicom": true, "university": true, "uno": true, "uol": true, "ups": true, "vacations": true, "vana": true, "vanguard": true, "vegas": true, "ventures": true, "verisign": true, "versicherung": true, "vet": true, "viajes": true, "video": true, "vig": true, "viking": true, "villas": true, "vin": true, "vip": true, "virgin": true, "visa": true, "vision": true, "vista": true, "vistaprint": true, "viva": true, "vivo": true, "vlaanderen": true, "vodka": true, "volkswagen": true, "volvo": true, "vote": true, "voting": true, "voto": true, "voyage": true, "vuelos": true, "wales": true, "walmart": true, "walter": true, "wang": true, "wanggou": true, "warman": true, "watch": true, "watches": true, "weather": true, "weatherchannel": true, "webcam": true, "weber": true, "website": true, "wed": true, "wedding": true, "weibo": true, "weir": true, "whoswho": true, "wien": true, "wiki": true, "williamhill": true, "win": true, "windows": true, "wine": true, "winners": true, "wme": true, "wolterskluwer": true, "woodside": true, "work": true, "works": true, "world": true, "wow": true, "wtc": true, "wtf": true, "xbox": true, "xerox": true, "xfinity": true, "xihuan": true, "xin": true, "xn--11b4c3d": true, "xn--1ck2e1b": true, "xn--1qqw23a": true, "xn--30rr7y": true, "xn--3bst00m": true, "xn--3ds443g": true, "xn--3oq18vl8pn36a": true, "xn--3pxu8k": true, "xn--42c2d9a": true, "xn--45q11c": true, "xn--4gbrim": true, "xn--55qw42g": true, "xn--55qx5d": true, "xn--5su34j936bgsg": true, "xn--5tzm5g": true, "xn--6frz82g": true, "xn--6qq986b3xl": true, "xn--80adxhks": true, "xn--80aqecdr1a": true, "xn--80asehdb": true, "xn--80aswg": true, "xn--8y0a063a": true, "xn--9dbq2a": true, "xn--9et52u": true, "xn--9krt00a": true, "xn--b4w605ferd": true, "xn--bck1b9a5dre4c": true, "xn--c1avg": true, "xn--c2br7g": true, "xn--cck2b3b": true, "xn--cg4bki": true, "xn--czr694b": true, "xn--czrs0t": true, "xn--czru2d": true, "xn--d1acj3b": true, "xn--eckvdtc9d": true, "xn--efvy88h": true, "xn--estv75g": true, "xn--fct429k": true, "xn--fhbei": true, "xn--fiq228c5hs": true, "xn--fiq64b": true, "xn--fjq720a": true, "xn--flw351e": true, "xn--fzys8d69uvgm": true, "xn--g2xx48c": true, "xn--gckr3f0f": true, "xn--gk3at1e": true, "xn--hxt814e": true, "xn--i1b6b1a6a2e": true, "xn--imr513n": true, "xn--io0a7i": true, "xn--j1aef": true, "xn--jlq61u9w7b": true, "xn--jvr189m": true, "xn--kcrx77d1x4a": true, "xn--kpu716f": true, "xn--kput3i": true, "xn--mgba3a3ejt": true, "xn--mgba7c0bbn0a": true, "xn--mgbaakc7dvf": true, "xn--mgbab2bd": true, "xn--mgbb9fbpob": true, "xn--mgbca7dzdo": true, "xn--mgbi4ecexp": true, "xn--mgbt3dhd": true, "xn--mk1bu44c": true, "xn--mxtq1m": true, "xn--ngbc5azd": true, "xn--ngbe9e0a": true, "xn--ngbrx": true, "xn--nqv7f": true, "xn--nqv7fs00ema": true, "xn--nyqy26a": true, "xn--p1acf": true, "xn--pbt977c": true, "xn--pssy2u": true, "xn--q9jyb4c": true, "xn--qcka1pmc": true, "xn--rhqv96g": true, "xn--rovu88b": true, "xn--ses554g": true, "xn--t60b56a": true, "xn--tckwe": true, "xn--tiq49xqyj": true, "xn--unup4y": true, "xn--vermgensberater-ctb": true, "xn--vermgensberatung-pwb": true, "xn--vhquv": true, "xn--vuq861b": true, "xn--w4r85el8fhu5dnra": true, "xn--w4rs40l": true, "xn--xhq521b": true, "xn--zfr164b": true, "xperia": true, "xyz": true, "yachts": true, "yahoo": true, "yamaxun": true, "yandex": true, "yodobashi": true, "yoga": true, "yokohama": true, "you": true, "youtube": true, "yun": true, "zappos": true, "zara": true, "zero": true, "zip": true, "zippo": true, "zone": true, "zuerich": true, "cc.ua": true, "inf.ua": true, "ltd.ua": true, "1password.ca": true, "1password.com": true, "1password.eu": true, "beep.pl": true, "*.compute.estate": true, "*.alces.network": true, "alwaysdata.net": true, "cloudfront.net": true, "*.compute.amazonaws.com": true, "*.compute-1.amazonaws.com": true, "*.compute.amazonaws.com.cn": true, "us-east-1.amazonaws.com": true, "cn-north-1.eb.amazonaws.com.cn": true, "elasticbeanstalk.com": true, "ap-northeast-1.elasticbeanstalk.com": true, "ap-northeast-2.elasticbeanstalk.com": true, "ap-south-1.elasticbeanstalk.com": true, "ap-southeast-1.elasticbeanstalk.com": true, "ap-southeast-2.elasticbeanstalk.com": true, "ca-central-1.elasticbeanstalk.com": true, "eu-central-1.elasticbeanstalk.com": true, "eu-west-1.elasticbeanstalk.com": true, "eu-west-2.elasticbeanstalk.com": true, "eu-west-3.elasticbeanstalk.com": true, "sa-east-1.elasticbeanstalk.com": true, "us-east-1.elasticbeanstalk.com": true, "us-east-2.elasticbeanstalk.com": true, "us-gov-west-1.elasticbeanstalk.com": true, "us-west-1.elasticbeanstalk.com": true, "us-west-2.elasticbeanstalk.com": true, "*.elb.amazonaws.com": true, "*.elb.amazonaws.com.cn": true, "s3.amazonaws.com": true, "s3-ap-northeast-1.amazonaws.com": true, "s3-ap-northeast-2.amazonaws.com": true, "s3-ap-south-1.amazonaws.com": true, "s3-ap-southeast-1.amazonaws.com": true, "s3-ap-southeast-2.amazonaws.com": true, "s3-ca-central-1.amazonaws.com": true, "s3-eu-central-1.amazonaws.com": true, "s3-eu-west-1.amazonaws.com": true, "s3-eu-west-2.amazonaws.com": true, "s3-eu-west-3.amazonaws.com": true, "s3-external-1.amazonaws.com": true, "s3-fips-us-gov-west-1.amazonaws.com": true, "s3-sa-east-1.amazonaws.com": true, "s3-us-gov-west-1.amazonaws.com": true, "s3-us-east-2.amazonaws.com": true, "s3-us-west-1.amazonaws.com": true, "s3-us-west-2.amazonaws.com": true, "s3.ap-northeast-2.amazonaws.com": true, "s3.ap-south-1.amazonaws.com": true, "s3.cn-north-1.amazonaws.com.cn": true, "s3.ca-central-1.amazonaws.com": true, "s3.eu-central-1.amazonaws.com": true, "s3.eu-west-2.amazonaws.com": true, "s3.eu-west-3.amazonaws.com": true, "s3.us-east-2.amazonaws.com": true, "s3.dualstack.ap-northeast-1.amazonaws.com": true, "s3.dualstack.ap-northeast-2.amazonaws.com": true, "s3.dualstack.ap-south-1.amazonaws.com": true, "s3.dualstack.ap-southeast-1.amazonaws.com": true, "s3.dualstack.ap-southeast-2.amazonaws.com": true, "s3.dualstack.ca-central-1.amazonaws.com": true, "s3.dualstack.eu-central-1.amazonaws.com": true, "s3.dualstack.eu-west-1.amazonaws.com": true, "s3.dualstack.eu-west-2.amazonaws.com": true, "s3.dualstack.eu-west-3.amazonaws.com": true, "s3.dualstack.sa-east-1.amazonaws.com": true, "s3.dualstack.us-east-1.amazonaws.com": true, "s3.dualstack.us-east-2.amazonaws.com": true, "s3-website-us-east-1.amazonaws.com": true, "s3-website-us-west-1.amazonaws.com": true, "s3-website-us-west-2.amazonaws.com": true, "s3-website-ap-northeast-1.amazonaws.com": true, "s3-website-ap-southeast-1.amazonaws.com": true, "s3-website-ap-southeast-2.amazonaws.com": true, "s3-website-eu-west-1.amazonaws.com": true, "s3-website-sa-east-1.amazonaws.com": true, "s3-website.ap-northeast-2.amazonaws.com": true, "s3-website.ap-south-1.amazonaws.com": true, "s3-website.ca-central-1.amazonaws.com": true, "s3-website.eu-central-1.amazonaws.com": true, "s3-website.eu-west-2.amazonaws.com": true, "s3-website.eu-west-3.amazonaws.com": true, "s3-website.us-east-2.amazonaws.com": true, "t3l3p0rt.net": true, "tele.amune.org": true, "on-aptible.com": true, "user.party.eus": true, "pimienta.org": true, "poivron.org": true, "potager.org": true, "sweetpepper.org": true, "myasustor.com": true, "myfritz.net": true, "*.awdev.ca": true, "*.advisor.ws": true, "backplaneapp.io": true, "betainabox.com": true, "bnr.la": true, "boomla.net": true, "boxfuse.io": true, "square7.ch": true, "bplaced.com": true, "bplaced.de": true, "square7.de": true, "bplaced.net": true, "square7.net": true, "browsersafetymark.io": true, "mycd.eu": true, "ae.org": true, "ar.com": true, "br.com": true, "cn.com": true, "com.de": true, "com.se": true, "de.com": true, "eu.com": true, "gb.com": true, "gb.net": true, "hu.com": true, "hu.net": true, "jp.net": true, "jpn.com": true, "kr.com": true, "mex.com": true, "no.com": true, "qc.com": true, "ru.com": true, "sa.com": true, "se.com": true, "se.net": true, "uk.com": true, "uk.net": true, "us.com": true, "uy.com": true, "za.bz": true, "za.com": true, "africa.com": true, "gr.com": true, "in.net": true, "us.org": true, "co.com": true, "c.la": true, "certmgr.org": true, "xenapponazure.com": true, "virtueeldomein.nl": true, "c66.me": true, "cloud66.ws": true, "jdevcloud.com": true, "wpdevcloud.com": true, "cloudaccess.host": true, "freesite.host": true, "cloudaccess.net": true, "cloudcontrolled.com": true, "cloudcontrolapp.com": true, "co.ca": true, "co.cz": true, "c.cdn77.org": true, "cdn77-ssl.net": true, "r.cdn77.net": true, "rsc.cdn77.org": true, "ssl.origin.cdn77-secure.org": true, "cloudns.asia": true, "cloudns.biz": true, "cloudns.club": true, "cloudns.cc": true, "cloudns.eu": true, "cloudns.in": true, "cloudns.info": true, "cloudns.org": true, "cloudns.pro": true, "cloudns.pw": true, "cloudns.us": true, "co.nl": true, "co.no": true, "webhosting.be": true, "hosting-cluster.nl": true, "dyn.cosidns.de": true, "dynamisches-dns.de": true, "dnsupdater.de": true, "internet-dns.de": true, "l-o-g-i-n.de": true, "dynamic-dns.info": true, "feste-ip.net": true, "knx-server.net": true, "static-access.net": true, "realm.cz": true, "*.cryptonomic.net": true, "cupcake.is": true, "cyon.link": true, "cyon.site": true, "daplie.me": true, "localhost.daplie.me": true, "biz.dk": true, "co.dk": true, "firm.dk": true, "reg.dk": true, "store.dk": true, "debian.net": true, "dedyn.io": true, "dnshome.de": true, "drayddns.com": true, "dreamhosters.com": true, "mydrobo.com": true, "drud.io": true, "drud.us": true, "duckdns.org": true, "dy.fi": true, "tunk.org": true, "dyndns-at-home.com": true, "dyndns-at-work.com": true, "dyndns-blog.com": true, "dyndns-free.com": true, "dyndns-home.com": true, "dyndns-ip.com": true, "dyndns-mail.com": true, "dyndns-office.com": true, "dyndns-pics.com": true, "dyndns-remote.com": true, "dyndns-server.com": true, "dyndns-web.com": true, "dyndns-wiki.com": true, "dyndns-work.com": true, "dyndns.biz": true, "dyndns.info": true, "dyndns.org": true, "dyndns.tv": true, "at-band-camp.net": true, "ath.cx": true, "barrel-of-knowledge.info": true, "barrell-of-knowledge.info": true, "better-than.tv": true, "blogdns.com": true, "blogdns.net": true, "blogdns.org": true, "blogsite.org": true, "boldlygoingnowhere.org": true, "broke-it.net": true, "buyshouses.net": true, "cechire.com": true, "dnsalias.com": true, "dnsalias.net": true, "dnsalias.org": true, "dnsdojo.com": true, "dnsdojo.net": true, "dnsdojo.org": true, "does-it.net": true, "doesntexist.com": true, "doesntexist.org": true, "dontexist.com": true, "dontexist.net": true, "dontexist.org": true, "doomdns.com": true, "doomdns.org": true, "dvrdns.org": true, "dyn-o-saur.com": true, "dynalias.com": true, "dynalias.net": true, "dynalias.org": true, "dynathome.net": true, "dyndns.ws": true, "endofinternet.net": true, "endofinternet.org": true, "endoftheinternet.org": true, "est-a-la-maison.com": true, "est-a-la-masion.com": true, "est-le-patron.com": true, "est-mon-blogueur.com": true, "for-better.biz": true, "for-more.biz": true, "for-our.info": true, "for-some.biz": true, "for-the.biz": true, "forgot.her.name": true, "forgot.his.name": true, "from-ak.com": true, "from-al.com": true, "from-ar.com": true, "from-az.net": true, "from-ca.com": true, "from-co.net": true, "from-ct.com": true, "from-dc.com": true, "from-de.com": true, "from-fl.com": true, "from-ga.com": true, "from-hi.com": true, "from-ia.com": true, "from-id.com": true, "from-il.com": true, "from-in.com": true, "from-ks.com": true, "from-ky.com": true, "from-la.net": true, "from-ma.com": true, "from-md.com": true, "from-me.org": true, "from-mi.com": true, "from-mn.com": true, "from-mo.com": true, "from-ms.com": true, "from-mt.com": true, "from-nc.com": true, "from-nd.com": true, "from-ne.com": true, "from-nh.com": true, "from-nj.com": true, "from-nm.com": true, "from-nv.com": true, "from-ny.net": true, "from-oh.com": true, "from-ok.com": true, "from-or.com": true, "from-pa.com": true, "from-pr.com": true, "from-ri.com": true, "from-sc.com": true, "from-sd.com": true, "from-tn.com": true, "from-tx.com": true, "from-ut.com": true, "from-va.com": true, "from-vt.com": true, "from-wa.com": true, "from-wi.com": true, "from-wv.com": true, "from-wy.com": true, "ftpaccess.cc": true, "fuettertdasnetz.de": true, "game-host.org": true, "game-server.cc": true, "getmyip.com": true, "gets-it.net": true, "go.dyndns.org": true, "gotdns.com": true, "gotdns.org": true, "groks-the.info": true, "groks-this.info": true, "ham-radio-op.net": true, "here-for-more.info": true, "hobby-site.com": true, "hobby-site.org": true, "home.dyndns.org": true, "homedns.org": true, "homeftp.net": true, "homeftp.org": true, "homeip.net": true, "homelinux.com": true, "homelinux.net": true, "homelinux.org": true, "homeunix.com": true, "homeunix.net": true, "homeunix.org": true, "iamallama.com": true, "in-the-band.net": true, "is-a-anarchist.com": true, "is-a-blogger.com": true, "is-a-bookkeeper.com": true, "is-a-bruinsfan.org": true, "is-a-bulls-fan.com": true, "is-a-candidate.org": true, "is-a-caterer.com": true, "is-a-celticsfan.org": true, "is-a-chef.com": true, "is-a-chef.net": true, "is-a-chef.org": true, "is-a-conservative.com": true, "is-a-cpa.com": true, "is-a-cubicle-slave.com": true, "is-a-democrat.com": true, "is-a-designer.com": true, "is-a-doctor.com": true, "is-a-financialadvisor.com": true, "is-a-geek.com": true, "is-a-geek.net": true, "is-a-geek.org": true, "is-a-green.com": true, "is-a-guru.com": true, "is-a-hard-worker.com": true, "is-a-hunter.com": true, "is-a-knight.org": true, "is-a-landscaper.com": true, "is-a-lawyer.com": true, "is-a-liberal.com": true, "is-a-libertarian.com": true, "is-a-linux-user.org": true, "is-a-llama.com": true, "is-a-musician.com": true, "is-a-nascarfan.com": true, "is-a-nurse.com": true, "is-a-painter.com": true, "is-a-patsfan.org": true, "is-a-personaltrainer.com": true, "is-a-photographer.com": true, "is-a-player.com": true, "is-a-republican.com": true, "is-a-rockstar.com": true, "is-a-socialist.com": true, "is-a-soxfan.org": true, "is-a-student.com": true, "is-a-teacher.com": true, "is-a-techie.com": true, "is-a-therapist.com": true, "is-an-accountant.com": true, "is-an-actor.com": true, "is-an-actress.com": true, "is-an-anarchist.com": true, "is-an-artist.com": true, "is-an-engineer.com": true, "is-an-entertainer.com": true, "is-by.us": true, "is-certified.com": true, "is-found.org": true, "is-gone.com": true, "is-into-anime.com": true, "is-into-cars.com": true, "is-into-cartoons.com": true, "is-into-games.com": true, "is-leet.com": true, "is-lost.org": true, "is-not-certified.com": true, "is-saved.org": true, "is-slick.com": true, "is-uberleet.com": true, "is-very-bad.org": true, "is-very-evil.org": true, "is-very-good.org": true, "is-very-nice.org": true, "is-very-sweet.org": true, "is-with-theband.com": true, "isa-geek.com": true, "isa-geek.net": true, "isa-geek.org": true, "isa-hockeynut.com": true, "issmarterthanyou.com": true, "isteingeek.de": true, "istmein.de": true, "kicks-ass.net": true, "kicks-ass.org": true, "knowsitall.info": true, "land-4-sale.us": true, "lebtimnetz.de": true, "leitungsen.de": true, "likes-pie.com": true, "likescandy.com": true, "merseine.nu": true, "mine.nu": true, "misconfused.org": true, "mypets.ws": true, "myphotos.cc": true, "neat-url.com": true, "office-on-the.net": true, "on-the-web.tv": true, "podzone.net": true, "podzone.org": true, "readmyblog.org": true, "saves-the-whales.com": true, "scrapper-site.net": true, "scrapping.cc": true, "selfip.biz": true, "selfip.com": true, "selfip.info": true, "selfip.net": true, "selfip.org": true, "sells-for-less.com": true, "sells-for-u.com": true, "sells-it.net": true, "sellsyourhome.org": true, "servebbs.com": true, "servebbs.net": true, "servebbs.org": true, "serveftp.net": true, "serveftp.org": true, "servegame.org": true, "shacknet.nu": true, "simple-url.com": true, "space-to-rent.com": true, "stuff-4-sale.org": true, "stuff-4-sale.us": true, "teaches-yoga.com": true, "thruhere.net": true, "traeumtgerade.de": true, "webhop.biz": true, "webhop.info": true, "webhop.net": true, "webhop.org": true, "worse-than.tv": true, "writesthisblog.com": true, "ddnss.de": true, "dyn.ddnss.de": true, "dyndns.ddnss.de": true, "dyndns1.de": true, "dyn-ip24.de": true, "home-webserver.de": true, "dyn.home-webserver.de": true, "myhome-server.de": true, "ddnss.org": true, "definima.net": true, "definima.io": true, "ddnsfree.com": true, "ddnsgeek.com": true, "giize.com": true, "gleeze.com": true, "kozow.com": true, "loseyourip.com": true, "ooguy.com": true, "theworkpc.com": true, "casacam.net": true, "dynu.net": true, "accesscam.org": true, "camdvr.org": true, "freeddns.org": true, "mywire.org": true, "webredirect.org": true, "myddns.rocks": true, "blogsite.xyz": true, "dynv6.net": true, "e4.cz": true, "mytuleap.com": true, "enonic.io": true, "customer.enonic.io": true, "eu.org": true, "al.eu.org": true, "asso.eu.org": true, "at.eu.org": true, "au.eu.org": true, "be.eu.org": true, "bg.eu.org": true, "ca.eu.org": true, "cd.eu.org": true, "ch.eu.org": true, "cn.eu.org": true, "cy.eu.org": true, "cz.eu.org": true, "de.eu.org": true, "dk.eu.org": true, "edu.eu.org": true, "ee.eu.org": true, "es.eu.org": true, "fi.eu.org": true, "fr.eu.org": true, "gr.eu.org": true, "hr.eu.org": true, "hu.eu.org": true, "ie.eu.org": true, "il.eu.org": true, "in.eu.org": true, "int.eu.org": true, "is.eu.org": true, "it.eu.org": true, "jp.eu.org": true, "kr.eu.org": true, "lt.eu.org": true, "lu.eu.org": true, "lv.eu.org": true, "mc.eu.org": true, "me.eu.org": true, "mk.eu.org": true, "mt.eu.org": true, "my.eu.org": true, "net.eu.org": true, "ng.eu.org": true, "nl.eu.org": true, "no.eu.org": true, "nz.eu.org": true, "paris.eu.org": true, "pl.eu.org": true, "pt.eu.org": true, "q-a.eu.org": true, "ro.eu.org": true, "ru.eu.org": true, "se.eu.org": true, "si.eu.org": true, "sk.eu.org": true, "tr.eu.org": true, "uk.eu.org": true, "us.eu.org": true, "eu-1.evennode.com": true, "eu-2.evennode.com": true, "eu-3.evennode.com": true, "eu-4.evennode.com": true, "us-1.evennode.com": true, "us-2.evennode.com": true, "us-3.evennode.com": true, "us-4.evennode.com": true, "twmail.cc": true, "twmail.net": true, "twmail.org": true, "mymailer.com.tw": true, "url.tw": true, "apps.fbsbx.com": true, "ru.net": true, "adygeya.ru": true, "bashkiria.ru": true, "bir.ru": true, "cbg.ru": true, "com.ru": true, "dagestan.ru": true, "grozny.ru": true, "kalmykia.ru": true, "kustanai.ru": true, "marine.ru": true, "mordovia.ru": true, "msk.ru": true, "mytis.ru": true, "nalchik.ru": true, "nov.ru": true, "pyatigorsk.ru": true, "spb.ru": true, "vladikavkaz.ru": true, "vladimir.ru": true, "abkhazia.su": true, "adygeya.su": true, "aktyubinsk.su": true, "arkhangelsk.su": true, "armenia.su": true, "ashgabad.su": true, "azerbaijan.su": true, "balashov.su": true, "bashkiria.su": true, "bryansk.su": true, "bukhara.su": true, "chimkent.su": true, "dagestan.su": true, "east-kazakhstan.su": true, "exnet.su": true, "georgia.su": true, "grozny.su": true, "ivanovo.su": true, "jambyl.su": true, "kalmykia.su": true, "kaluga.su": true, "karacol.su": true, "karaganda.su": true, "karelia.su": true, "khakassia.su": true, "krasnodar.su": true, "kurgan.su": true, "kustanai.su": true, "lenug.su": true, "mangyshlak.su": true, "mordovia.su": true, "msk.su": true, "murmansk.su": true, "nalchik.su": true, "navoi.su": true, "north-kazakhstan.su": true, "nov.su": true, "obninsk.su": true, "penza.su": true, "pokrovsk.su": true, "sochi.su": true, "spb.su": true, "tashkent.su": true, "termez.su": true, "togliatti.su": true, "troitsk.su": true, "tselinograd.su": true, "tula.su": true, "tuva.su": true, "vladikavkaz.su": true, "vladimir.su": true, "vologda.su": true, "channelsdvr.net": true, "fastlylb.net": true, "map.fastlylb.net": true, "freetls.fastly.net": true, "map.fastly.net": true, "a.prod.fastly.net": true, "global.prod.fastly.net": true, "a.ssl.fastly.net": true, "b.ssl.fastly.net": true, "global.ssl.fastly.net": true, "fhapp.xyz": true, "fedorainfracloud.org": true, "fedorapeople.org": true, "cloud.fedoraproject.org": true, "app.os.fedoraproject.org": true, "app.os.stg.fedoraproject.org": true, "filegear.me": true, "firebaseapp.com": true, "flynnhub.com": true, "flynnhosting.net": true, "freebox-os.com": true, "freeboxos.com": true, "fbx-os.fr": true, "fbxos.fr": true, "freebox-os.fr": true, "freeboxos.fr": true, "*.futurecms.at": true, "futurehosting.at": true, "futuremailing.at": true, "*.ex.ortsinfo.at": true, "*.kunden.ortsinfo.at": true, "*.statics.cloud": true, "service.gov.uk": true, "github.io": true, "githubusercontent.com": true, "gitlab.io": true, "homeoffice.gov.uk": true, "ro.im": true, "shop.ro": true, "goip.de": true, "*.0emm.com": true, "appspot.com": true, "blogspot.ae": true, "blogspot.al": true, "blogspot.am": true, "blogspot.ba": true, "blogspot.be": true, "blogspot.bg": true, "blogspot.bj": true, "blogspot.ca": true, "blogspot.cf": true, "blogspot.ch": true, "blogspot.cl": true, "blogspot.co.at": true, "blogspot.co.id": true, "blogspot.co.il": true, "blogspot.co.ke": true, "blogspot.co.nz": true, "blogspot.co.uk": true, "blogspot.co.za": true, "blogspot.com": true, "blogspot.com.ar": true, "blogspot.com.au": true, "blogspot.com.br": true, "blogspot.com.by": true, "blogspot.com.co": true, "blogspot.com.cy": true, "blogspot.com.ee": true, "blogspot.com.eg": true, "blogspot.com.es": true, "blogspot.com.mt": true, "blogspot.com.ng": true, "blogspot.com.tr": true, "blogspot.com.uy": true, "blogspot.cv": true, "blogspot.cz": true, "blogspot.de": true, "blogspot.dk": true, "blogspot.fi": true, "blogspot.fr": true, "blogspot.gr": true, "blogspot.hk": true, "blogspot.hr": true, "blogspot.hu": true, "blogspot.ie": true, "blogspot.in": true, "blogspot.is": true, "blogspot.it": true, "blogspot.jp": true, "blogspot.kr": true, "blogspot.li": true, "blogspot.lt": true, "blogspot.lu": true, "blogspot.md": true, "blogspot.mk": true, "blogspot.mr": true, "blogspot.mx": true, "blogspot.my": true, "blogspot.nl": true, "blogspot.no": true, "blogspot.pe": true, "blogspot.pt": true, "blogspot.qa": true, "blogspot.re": true, "blogspot.ro": true, "blogspot.rs": true, "blogspot.ru": true, "blogspot.se": true, "blogspot.sg": true, "blogspot.si": true, "blogspot.sk": true, "blogspot.sn": true, "blogspot.td": true, "blogspot.tw": true, "blogspot.ug": true, "blogspot.vn": true, "cloudfunctions.net": true, "cloud.goog": true, "codespot.com": true, "googleapis.com": true, "googlecode.com": true, "pagespeedmobilizer.com": true, "publishproxy.com": true, "withgoogle.com": true, "withyoutube.com": true, "hashbang.sh": true, "hasura-app.io": true, "hepforge.org": true, "herokuapp.com": true, "herokussl.com": true, "moonscale.net": true, "iki.fi": true, "biz.at": true, "info.at": true, "info.cx": true, "ac.leg.br": true, "al.leg.br": true, "am.leg.br": true, "ap.leg.br": true, "ba.leg.br": true, "ce.leg.br": true, "df.leg.br": true, "es.leg.br": true, "go.leg.br": true, "ma.leg.br": true, "mg.leg.br": true, "ms.leg.br": true, "mt.leg.br": true, "pa.leg.br": true, "pb.leg.br": true, "pe.leg.br": true, "pi.leg.br": true, "pr.leg.br": true, "rj.leg.br": true, "rn.leg.br": true, "ro.leg.br": true, "rr.leg.br": true, "rs.leg.br": true, "sc.leg.br": true, "se.leg.br": true, "sp.leg.br": true, "to.leg.br": true, "pixolino.com": true, "ipifony.net": true, "*.triton.zone": true, "*.cns.joyent.com": true, "js.org": true, "keymachine.de": true, "knightpoint.systems": true, "co.krd": true, "edu.krd": true, "git-repos.de": true, "lcube-server.de": true, "svn-repos.de": true, "linkyard.cloud": true, "linkyard-cloud.ch": true, "we.bs": true, "barsy.bg": true, "barsyonline.com": true, "barsy.de": true, "barsy.eu": true, "barsy.in": true, "barsy.net": true, "barsy.online": true, "barsy.support": true, "*.magentosite.cloud": true, "hb.cldmail.ru": true, "cloud.metacentrum.cz": true, "custom.metacentrum.cz": true, "meteorapp.com": true, "eu.meteorapp.com": true, "co.pl": true, "azurewebsites.net": true, "azure-mobile.net": true, "cloudapp.net": true, "mozilla-iot.org": true, "bmoattachments.org": true, "net.ru": true, "org.ru": true, "pp.ru": true, "bitballoon.com": true, "netlify.com": true, "4u.com": true, "ngrok.io": true, "nh-serv.co.uk": true, "nfshost.com": true, "nsupdate.info": true, "nerdpol.ovh": true, "blogsyte.com": true, "brasilia.me": true, "cable-modem.org": true, "ciscofreak.com": true, "collegefan.org": true, "couchpotatofries.org": true, "damnserver.com": true, "ddns.me": true, "ditchyourip.com": true, "dnsfor.me": true, "dnsiskinky.com": true, "dvrcam.info": true, "dynns.com": true, "eating-organic.net": true, "fantasyleague.cc": true, "geekgalaxy.com": true, "golffan.us": true, "health-carereform.com": true, "homesecuritymac.com": true, "homesecuritypc.com": true, "hopto.me": true, "ilovecollege.info": true, "loginto.me": true, "mlbfan.org": true, "mmafan.biz": true, "myactivedirectory.com": true, "mydissent.net": true, "myeffect.net": true, "mymediapc.net": true, "mypsx.net": true, "mysecuritycamera.com": true, "mysecuritycamera.net": true, "mysecuritycamera.org": true, "net-freaks.com": true, "nflfan.org": true, "nhlfan.net": true, "no-ip.ca": true, "no-ip.co.uk": true, "no-ip.net": true, "noip.us": true, "onthewifi.com": true, "pgafan.net": true, "point2this.com": true, "pointto.us": true, "privatizehealthinsurance.net": true, "quicksytes.com": true, "read-books.org": true, "securitytactics.com": true, "serveexchange.com": true, "servehumour.com": true, "servep2p.com": true, "servesarcasm.com": true, "stufftoread.com": true, "ufcfan.org": true, "unusualperson.com": true, "workisboring.com": true, "3utilities.com": true, "bounceme.net": true, "ddns.net": true, "ddnsking.com": true, "gotdns.ch": true, "hopto.org": true, "myftp.biz": true, "myftp.org": true, "myvnc.com": true, "no-ip.biz": true, "no-ip.info": true, "no-ip.org": true, "noip.me": true, "redirectme.net": true, "servebeer.com": true, "serveblog.net": true, "servecounterstrike.com": true, "serveftp.com": true, "servegame.com": true, "servehalflife.com": true, "servehttp.com": true, "serveirc.com": true, "serveminecraft.net": true, "servemp3.com": true, "servepics.com": true, "servequake.com": true, "sytes.net": true, "webhop.me": true, "zapto.org": true, "stage.nodeart.io": true, "nodum.co": true, "nodum.io": true, "nyc.mn": true, "nom.ae": true, "nom.ai": true, "nom.al": true, "nym.by": true, "nym.bz": true, "nom.cl": true, "nom.gd": true, "nom.gl": true, "nym.gr": true, "nom.gt": true, "nom.hn": true, "nom.im": true, "nym.kz": true, "nym.la": true, "nom.li": true, "nym.li": true, "nym.lt": true, "nym.lu": true, "nym.me": true, "nom.mk": true, "nym.mx": true, "nom.nu": true, "nym.nz": true, "nym.pe": true, "nym.pt": true, "nom.pw": true, "nom.qa": true, "nom.rs": true, "nom.si": true, "nym.sk": true, "nym.su": true, "nym.sx": true, "nym.tw": true, "nom.ug": true, "nom.uy": true, "nom.vc": true, "nom.vg": true, "cya.gg": true, "nid.io": true, "opencraft.hosting": true, "operaunite.com": true, "outsystemscloud.com": true, "ownprovider.com": true, "oy.lc": true, "pgfog.com": true, "pagefrontapp.com": true, "art.pl": true, "gliwice.pl": true, "krakow.pl": true, "poznan.pl": true, "wroc.pl": true, "zakopane.pl": true, "pantheonsite.io": true, "gotpantheon.com": true, "mypep.link": true, "on-web.fr": true, "*.platform.sh": true, "*.platformsh.site": true, "xen.prgmr.com": true, "priv.at": true, "protonet.io": true, "chirurgiens-dentistes-en-france.fr": true, "byen.site": true, "qa2.com": true, "dev-myqnapcloud.com": true, "alpha-myqnapcloud.com": true, "myqnapcloud.com": true, "*.quipelements.com": true, "vapor.cloud": true, "vaporcloud.io": true, "rackmaze.com": true, "rackmaze.net": true, "rhcloud.com": true, "resindevice.io": true, "devices.resinstaging.io": true, "hzc.io": true, "wellbeingzone.eu": true, "ptplus.fit": true, "wellbeingzone.co.uk": true, "sandcats.io": true, "logoip.de": true, "logoip.com": true, "schokokeks.net": true, "scrysec.com": true, "firewall-gateway.com": true, "firewall-gateway.de": true, "my-gateway.de": true, "my-router.de": true, "spdns.de": true, "spdns.eu": true, "firewall-gateway.net": true, "my-firewall.org": true, "myfirewall.org": true, "spdns.org": true, "*.s5y.io": true, "*.sensiosite.cloud": true, "biz.ua": true, "co.ua": true, "pp.ua": true, "shiftedit.io": true, "myshopblocks.com": true, "1kapp.com": true, "appchizi.com": true, "applinzi.com": true, "sinaapp.com": true, "vipsinaapp.com": true, "bounty-full.com": true, "alpha.bounty-full.com": true, "beta.bounty-full.com": true, "static.land": true, "dev.static.land": true, "sites.static.land": true, "apps.lair.io": true, "*.stolos.io": true, "spacekit.io": true, "stackspace.space": true, "storj.farm": true, "temp-dns.com": true, "diskstation.me": true, "dscloud.biz": true, "dscloud.me": true, "dscloud.mobi": true, "dsmynas.com": true, "dsmynas.net": true, "dsmynas.org": true, "familyds.com": true, "familyds.net": true, "familyds.org": true, "i234.me": true, "myds.me": true, "synology.me": true, "vpnplus.to": true, "taifun-dns.de": true, "gda.pl": true, "gdansk.pl": true, "gdynia.pl": true, "med.pl": true, "sopot.pl": true, "cust.dev.thingdust.io": true, "cust.disrec.thingdust.io": true, "cust.prod.thingdust.io": true, "cust.testing.thingdust.io": true, "bloxcms.com": true, "townnews-staging.com": true, "12hp.at": true, "2ix.at": true, "4lima.at": true, "lima-city.at": true, "12hp.ch": true, "2ix.ch": true, "4lima.ch": true, "lima-city.ch": true, "trafficplex.cloud": true, "de.cool": true, "12hp.de": true, "2ix.de": true, "4lima.de": true, "lima-city.de": true, "1337.pictures": true, "clan.rip": true, "lima-city.rocks": true, "webspace.rocks": true, "lima.zone": true, "*.transurl.be": true, "*.transurl.eu": true, "*.transurl.nl": true, "tuxfamily.org": true, "dd-dns.de": true, "diskstation.eu": true, "diskstation.org": true, "dray-dns.de": true, "draydns.de": true, "dyn-vpn.de": true, "dynvpn.de": true, "mein-vigor.de": true, "my-vigor.de": true, "my-wan.de": true, "syno-ds.de": true, "synology-diskstation.de": true, "synology-ds.de": true, "uber.space": true, "hk.com": true, "hk.org": true, "ltd.hk": true, "inc.hk": true, "lib.de.us": true, "2038.io": true, "router.management": true, "v-info.info": true, "wedeploy.io": true, "wedeploy.me": true, "wedeploy.sh": true, "remotewd.com": true, "wmflabs.org": true, "cistron.nl": true, "demon.nl": true, "xs4all.space": true, "official.academy": true, "yolasite.com": true, "ybo.faith": true, "yombo.me": true, "homelink.one": true, "ybo.party": true, "ybo.review": true, "ybo.science": true, "ybo.trade": true, "za.net": true, "za.org": true, "now.sh": true });
  }
});

// node_modules/tough-cookie/lib/store.js
var require_store = __commonJS({
  "node_modules/tough-cookie/lib/store.js"(exports) {
    "use strict";
    function Store() {
    }
    exports.Store = Store;
    Store.prototype.synchronous = false;
    Store.prototype.findCookie = function(domain, path, key, cb) {
      throw new Error("findCookie is not implemented");
    };
    Store.prototype.findCookies = function(domain, path, cb) {
      throw new Error("findCookies is not implemented");
    };
    Store.prototype.putCookie = function(cookie, cb) {
      throw new Error("putCookie is not implemented");
    };
    Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      throw new Error("updateCookie is not implemented");
    };
    Store.prototype.removeCookie = function(domain, path, key, cb) {
      throw new Error("removeCookie is not implemented");
    };
    Store.prototype.removeCookies = function(domain, path, cb) {
      throw new Error("removeCookies is not implemented");
    };
    Store.prototype.getAllCookies = function(cb) {
      throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    };
  }
});

// node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS({
  "node_modules/tough-cookie/lib/permuteDomain.js"(exports) {
    "use strict";
    var pubsuffix = require_pubsuffix();
    function permuteDomain(domain) {
      var pubSuf = pubsuffix.getPublicSuffix(domain);
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
      var prefix = domain.slice(0, -(pubSuf.length + 1));
      var parts = prefix.split(".").reverse();
      var cur = pubSuf;
      var permutations = [cur];
      while (parts.length) {
        cur = parts.shift() + "." + cur;
        permutations.push(cur);
      }
      return permutations;
    }
    exports.permuteDomain = permuteDomain;
  }
});

// node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS({
  "node_modules/tough-cookie/lib/pathMatch.js"(exports) {
    "use strict";
    function pathMatch(reqPath, cookiePath) {
      if (cookiePath === reqPath) {
        return true;
      }
      var idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
      return false;
    }
    exports.pathMatch = pathMatch;
  }
});

// node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS({
  "node_modules/tough-cookie/lib/memstore.js"(exports) {
    "use strict";
    var Store = require_store().Store;
    var permuteDomain = require_permuteDomain().permuteDomain;
    var pathMatch = require_pathMatch().pathMatch;
    var util = (init_util(), __toCommonJS(util_exports));
    function MemoryCookieStore() {
      Store.call(this);
      this.idx = {};
    }
    util.inherits(MemoryCookieStore, Store);
    exports.MemoryCookieStore = MemoryCookieStore;
    MemoryCookieStore.prototype.idx = null;
    MemoryCookieStore.prototype.synchronous = true;
    MemoryCookieStore.prototype.inspect = function() {
      return "{ idx: " + util.inspect(this.idx, false, 2) + " }";
    };
    MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
      if (!this.idx[domain]) {
        return cb(null, void 0);
      }
      if (!this.idx[domain][path]) {
        return cb(null, void 0);
      }
      return cb(null, this.idx[domain][path][key] || null);
    };
    MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
      var results = [];
      if (!domain) {
        return cb(null, []);
      }
      var pathMatcher;
      if (!path) {
        pathMatcher = function matchAll(domainIndex) {
          for (var curPath in domainIndex) {
            var pathIndex = domainIndex[curPath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        };
      } else {
        pathMatcher = function matchRFC(domainIndex) {
          Object.keys(domainIndex).forEach(function(cookiePath) {
            if (pathMatch(path, cookiePath)) {
              var pathIndex = domainIndex[cookiePath];
              for (var key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          });
        };
      }
      var domains = permuteDomain(domain) || [domain];
      var idx = this.idx;
      domains.forEach(function(curDomain) {
        var domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
      cb(null, results);
    };
    MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
      if (!this.idx[cookie.domain]) {
        this.idx[cookie.domain] = {};
      }
      if (!this.idx[cookie.domain][cookie.path]) {
        this.idx[cookie.domain][cookie.path] = {};
      }
      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
      cb(null);
    };
    MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
    MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
      if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
        delete this.idx[domain][path][key];
      }
      cb(null);
    };
    MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
      if (this.idx[domain]) {
        if (path) {
          delete this.idx[domain][path];
        } else {
          delete this.idx[domain];
        }
      }
      return cb(null);
    };
    MemoryCookieStore.prototype.getAllCookies = function(cb) {
      var cookies = [];
      var idx = this.idx;
      var domains = Object.keys(idx);
      domains.forEach(function(domain) {
        var paths = Object.keys(idx[domain]);
        paths.forEach(function(path) {
          var keys = Object.keys(idx[domain][path]);
          keys.forEach(function(key) {
            if (key !== null) {
              cookies.push(idx[domain][path][key]);
            }
          });
        });
      });
      cookies.sort(function(a, b) {
        return (a.creationIndex || 0) - (b.creationIndex || 0);
      });
      cb(null, cookies);
    };
  }
});

// node_modules/tough-cookie/package.json
var require_package = __commonJS({
  "node_modules/tough-cookie/package.json"(exports, module) {
    module.exports = {
      author: {
        name: "Jeremy Stashewsky",
        email: "jstashewsky@salesforce.com",
        website: "https://github.com/stash"
      },
      contributors: [
        {
          name: "Alexander Savin",
          website: "https://github.com/apsavin"
        },
        {
          name: "Ian Livingstone",
          website: "https://github.com/ianlivingstone"
        },
        {
          name: "Ivan Nikulin",
          website: "https://github.com/inikulin"
        },
        {
          name: "Lalit Kapoor",
          website: "https://github.com/lalitkapoor"
        },
        {
          name: "Sam Thompson",
          website: "https://github.com/sambthompson"
        },
        {
          name: "Sebastian Mayr",
          website: "https://github.com/Sebmaster"
        }
      ],
      license: "BSD-3-Clause",
      name: "tough-cookie",
      description: "RFC6265 Cookies and Cookie Jar for node.js",
      keywords: [
        "HTTP",
        "cookie",
        "cookies",
        "set-cookie",
        "cookiejar",
        "jar",
        "RFC6265",
        "RFC2965"
      ],
      version: "2.3.4",
      homepage: "https://github.com/salesforce/tough-cookie",
      repository: {
        type: "git",
        url: "git://github.com/salesforce/tough-cookie.git"
      },
      bugs: {
        url: "https://github.com/salesforce/tough-cookie/issues"
      },
      main: "./lib/cookie",
      files: [
        "lib"
      ],
      scripts: {
        suffixup: "curl -o public_suffix_list.dat https://publicsuffix.org/list/public_suffix_list.dat && ./generate-pubsuffix.js",
        test: "vows test/*_test.js"
      },
      engines: {
        node: ">=0.8"
      },
      devDependencies: {
        async: "^1.4.2",
        "string.prototype.repeat": "^0.2.0",
        vows: "^0.8.1"
      },
      dependencies: {
        punycode: "^1.4.1"
      }
    };
  }
});

// node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS({
  "node_modules/tough-cookie/lib/cookie.js"(exports, module) {
    "use strict";
    var net = (init_net(), __toCommonJS(net_exports));
    var urlParse = (init_url(), __toCommonJS(url_exports)).parse;
    var pubsuffix = require_pubsuffix();
    var Store = require_store().Store;
    var MemoryCookieStore = require_memstore().MemoryCookieStore;
    var pathMatch = require_pathMatch().pathMatch;
    var VERSION = require_package().version;
    var punycode;
    try {
      punycode = require_punycode();
    } catch (e) {
      console.warn("cookie: can't load punycode; won't use punycode for domain normalization");
    }
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
    var CONTROL_CHARS = /[\x00-\x1F]/;
    var TERMINATORS = ["\n", "\r", "\0"];
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    var MONTH_TO_NUM = {
      jan: 0,
      feb: 1,
      mar: 2,
      apr: 3,
      may: 4,
      jun: 5,
      jul: 6,
      aug: 7,
      sep: 8,
      oct: 9,
      nov: 10,
      dec: 11
    };
    var NUM_TO_MONTH = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var NUM_TO_DAY = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var MAX_TIME = 2147483647e3;
    var MIN_TIME = 0;
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
      var count = 0;
      while (count < token.length) {
        var c = token.charCodeAt(count);
        if (c <= 47 || c >= 58) {
          break;
        }
        count++;
      }
      if (count < minDigits || count > maxDigits) {
        return null;
      }
      if (!trailingOK && count != token.length) {
        return null;
      }
      return parseInt(token.substr(0, count), 10);
    }
    function parseTime(token) {
      var parts = token.split(":");
      var result = [0, 0, 0];
      if (parts.length !== 3) {
        return null;
      }
      for (var i = 0; i < 3; i++) {
        var trailingOK = i == 2;
        var num = parseDigits(parts[i], 1, 2, trailingOK);
        if (num === null) {
          return null;
        }
        result[i] = num;
      }
      return result;
    }
    function parseMonth(token) {
      token = String(token).substr(0, 3).toLowerCase();
      var num = MONTH_TO_NUM[token];
      return num >= 0 ? num : null;
    }
    function parseDate(str) {
      if (!str) {
        return;
      }
      var tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
      var hour = null;
      var minute = null;
      var second = null;
      var dayOfMonth = null;
      var month = null;
      var year = null;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
        var result;
        if (second === null) {
          result = parseTime(token);
          if (result) {
            hour = result[0];
            minute = result[1];
            second = result[2];
            continue;
          }
        }
        if (dayOfMonth === null) {
          result = parseDigits(token, 1, 2, true);
          if (result !== null) {
            dayOfMonth = result;
            continue;
          }
        }
        if (month === null) {
          result = parseMonth(token);
          if (result !== null) {
            month = result;
            continue;
          }
        }
        if (year === null) {
          result = parseDigits(token, 2, 4, true);
          if (result !== null) {
            year = result;
            if (year >= 70 && year <= 99) {
              year += 1900;
            } else if (year >= 0 && year <= 69) {
              year += 2e3;
            }
          }
        }
      }
      if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
      }
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    }
    function formatDate(date) {
      var d = date.getUTCDate();
      d = d >= 10 ? d : "0" + d;
      var h = date.getUTCHours();
      h = h >= 10 ? h : "0" + h;
      var m = date.getUTCMinutes();
      m = m >= 10 ? m : "0" + m;
      var s = date.getUTCSeconds();
      s = s >= 10 ? s : "0" + s;
      return NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
    }
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./, "");
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
      return str.toLowerCase();
    }
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
      if (str == domStr) {
        return true;
      }
      if (net.isIP(str)) {
        return false;
      }
      var idx = str.indexOf(domStr);
      if (idx <= 0) {
        return false;
      }
      if (str.length !== domStr.length + idx) {
        return false;
      }
      if (str.substr(idx - 1, 1) !== ".") {
        return false;
      }
      return true;
    }
    function defaultPath(path) {
      if (!path || path.substr(0, 1) !== "/") {
        return "/";
      }
      if (path === "/") {
        return path;
      }
      var rightSlash = path.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
      return path.slice(0, rightSlash);
    }
    function trimTerminator(str) {
      for (var t = 0; t < TERMINATORS.length; t++) {
        var terminatorIdx = str.indexOf(TERMINATORS[t]);
        if (terminatorIdx !== -1) {
          str = str.substr(0, terminatorIdx);
        }
      }
      return str;
    }
    function parseCookiePair(cookiePair, looseMode) {
      cookiePair = trimTerminator(cookiePair);
      var firstEq = cookiePair.indexOf("=");
      if (looseMode) {
        if (firstEq === 0) {
          cookiePair = cookiePair.substr(1);
          firstEq = cookiePair.indexOf("=");
        }
      } else {
        if (firstEq <= 0) {
          return;
        }
      }
      var cookieName, cookieValue;
      if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
      } else {
        cookieName = cookiePair.substr(0, firstEq).trim();
        cookieValue = cookiePair.substr(firstEq + 1).trim();
      }
      if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return;
      }
      var c = new Cookie();
      c.key = cookieName;
      c.value = cookieValue;
      return c;
    }
    function parse(str, options) {
      if (!options || typeof options !== "object") {
        options = {};
      }
      str = str.trim();
      var firstSemi = str.indexOf(";");
      var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
      var c = parseCookiePair(cookiePair, !!options.loose);
      if (!c) {
        return;
      }
      if (firstSemi === -1) {
        return c;
      }
      var unparsed = str.slice(firstSemi + 1).trim();
      if (unparsed.length === 0) {
        return c;
      }
      var cookie_avs = unparsed.split(";");
      while (cookie_avs.length) {
        var av = cookie_avs.shift().trim();
        if (av.length === 0) {
          continue;
        }
        var av_sep = av.indexOf("=");
        var av_key, av_value;
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0, av_sep);
          av_value = av.substr(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
          av_value = av_value.trim();
        }
        switch (av_key) {
          case "expires":
            if (av_value) {
              var exp = parseDate(av_value);
              if (exp) {
                c.expires = exp;
              }
            }
            break;
          case "max-age":
            if (av_value) {
              if (/^-?[0-9]+$/.test(av_value)) {
                var delta = parseInt(av_value, 10);
                c.setMaxAge(delta);
              }
            }
            break;
          case "domain":
            if (av_value) {
              var domain = av_value.trim().replace(/^\./, "");
              if (domain) {
                c.domain = domain.toLowerCase();
              }
            }
            break;
          case "path":
            c.path = av_value && av_value[0] === "/" ? av_value : null;
            break;
          case "secure":
            c.secure = true;
            break;
          case "httponly":
            c.httpOnly = true;
            break;
          default:
            c.extensions = c.extensions || [];
            c.extensions.push(av);
            break;
        }
      }
      return c;
    }
    function jsonParse(str) {
      var obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    function fromJSON(str) {
      if (!str) {
        return null;
      }
      var obj;
      if (typeof str === "string") {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        obj = str;
      }
      var c = new Cookie();
      for (var i = 0; i < Cookie.serializableProperties.length; i++) {
        var prop = Cookie.serializableProperties[i];
        if (obj[prop] === void 0 || obj[prop] === Cookie.prototype[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (obj[prop] === null) {
            c[prop] = null;
          } else {
            c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
          }
        } else {
          c[prop] = obj[prop];
        }
      }
      return c;
    }
    function cookieCompare(a, b) {
      var cmp = 0;
      var aPathLen = a.path ? a.path.length : 0;
      var bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
      var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = a.creationIndex - b.creationIndex;
      return cmp;
    }
    function permutePath(path) {
      if (path === "/") {
        return ["/"];
      }
      if (path.lastIndexOf("/") === path.length - 1) {
        path = path.substr(0, path.length - 1);
      }
      var permutations = [path];
      while (path.length > 1) {
        var lindex = path.lastIndexOf("/");
        if (lindex === 0) {
          break;
        }
        path = path.substr(0, lindex);
        permutations.push(path);
      }
      permutations.push("/");
      return permutations;
    }
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      try {
        url = decodeURI(url);
      } catch (err) {
      }
      return urlParse(url);
    }
    function Cookie(options) {
      options = options || {};
      Object.keys(options).forEach(function(prop) {
        if (Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && prop.substr(0, 1) !== "_") {
          this[prop] = options[prop];
        }
      }, this);
      this.creation = this.creation || new Date();
      Object.defineProperty(this, "creationIndex", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: ++Cookie.cookiesCreated
      });
    }
    Cookie.cookiesCreated = 0;
    Cookie.parse = parse;
    Cookie.fromJSON = fromJSON;
    Cookie.prototype.key = "";
    Cookie.prototype.value = "";
    Cookie.prototype.expires = "Infinity";
    Cookie.prototype.maxAge = null;
    Cookie.prototype.domain = null;
    Cookie.prototype.path = null;
    Cookie.prototype.secure = false;
    Cookie.prototype.httpOnly = false;
    Cookie.prototype.extensions = null;
    Cookie.prototype.hostOnly = null;
    Cookie.prototype.pathIsDefault = null;
    Cookie.prototype.creation = null;
    Cookie.prototype.lastAccessed = null;
    Object.defineProperty(Cookie.prototype, "creationIndex", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: 0
    });
    Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop) {
      return !(Cookie.prototype[prop] instanceof Function || prop === "creationIndex" || prop.substr(0, 1) === "_");
    });
    Cookie.prototype.inspect = function inspect() {
      var now = Date.now();
      return 'Cookie="' + this.toString() + "; hostOnly=" + (this.hostOnly != null ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
    };
    Cookie.prototype.toJSON = function() {
      var obj = {};
      var props = Cookie.serializableProperties;
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (this[prop] === Cookie.prototype[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (this[prop] === null) {
            obj[prop] = null;
          } else {
            obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
          }
        } else if (prop === "maxAge") {
          if (this[prop] !== null) {
            obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
          }
        } else {
          if (this[prop] !== Cookie.prototype[prop]) {
            obj[prop] = this[prop];
          }
        }
      }
      return obj;
    };
    Cookie.prototype.clone = function() {
      return fromJSON(this.toJSON());
    };
    Cookie.prototype.validate = function validate() {
      if (!COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge <= 0) {
        return false;
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
      var cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false;
        }
        var suffix = pubsuffix.getPublicSuffix(cdomain);
        if (suffix == null) {
          return false;
        }
      }
      return true;
    };
    Cookie.prototype.setExpires = function setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = parseDate(exp) || "Infinity";
      }
    };
    Cookie.prototype.setMaxAge = function setMaxAge(age) {
      if (age === Infinity || age === -Infinity) {
        this.maxAge = age.toString();
      } else {
        this.maxAge = age;
      }
    };
    Cookie.prototype.cookieString = function cookieString() {
      var val = this.value;
      if (val == null) {
        val = "";
      }
      if (this.key === "") {
        return val;
      }
      return this.key + "=" + val;
    };
    Cookie.prototype.toString = function toString() {
      var str = this.cookieString();
      if (this.expires != Infinity) {
        if (this.expires instanceof Date) {
          str += "; Expires=" + formatDate(this.expires);
        } else {
          str += "; Expires=" + this.expires;
        }
      }
      if (this.maxAge != null && this.maxAge != Infinity) {
        str += "; Max-Age=" + this.maxAge;
      }
      if (this.domain && !this.hostOnly) {
        str += "; Domain=" + this.domain;
      }
      if (this.path) {
        str += "; Path=" + this.path;
      }
      if (this.secure) {
        str += "; Secure";
      }
      if (this.httpOnly) {
        str += "; HttpOnly";
      }
      if (this.extensions) {
        this.extensions.forEach(function(ext) {
          str += "; " + ext;
        });
      }
      return str;
    };
    Cookie.prototype.TTL = function TTL(now) {
      if (this.maxAge != null) {
        return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
      }
      var expires = this.expires;
      if (expires != Infinity) {
        if (!(expires instanceof Date)) {
          expires = parseDate(expires) || Infinity;
        }
        if (expires == Infinity) {
          return Infinity;
        }
        return expires.getTime() - (now || Date.now());
      }
      return Infinity;
    };
    Cookie.prototype.expiryTime = function expiryTime(now) {
      if (this.maxAge != null) {
        var relativeTo = now || this.creation || new Date();
        var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
        return relativeTo.getTime() + age;
      }
      if (this.expires == Infinity) {
        return Infinity;
      }
      return this.expires.getTime();
    };
    Cookie.prototype.expiryDate = function expiryDate(now) {
      var millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(MAX_TIME);
      } else if (millisec == -Infinity) {
        return new Date(MIN_TIME);
      } else {
        return new Date(millisec);
      }
    };
    Cookie.prototype.isPersistent = function isPersistent() {
      return this.maxAge != null || this.expires != Infinity;
    };
    Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
      if (this.domain == null) {
        return null;
      }
      return canonicalDomain(this.domain);
    };
    function CookieJar(store, options) {
      if (typeof options === "boolean") {
        options = { rejectPublicSuffixes: options };
      } else if (options == null) {
        options = {};
      }
      if (options.rejectPublicSuffixes != null) {
        this.rejectPublicSuffixes = options.rejectPublicSuffixes;
      }
      if (options.looseMode != null) {
        this.enableLooseMode = options.looseMode;
      }
      if (!store) {
        store = new MemoryCookieStore();
      }
      this.store = store;
    }
    CookieJar.prototype.store = null;
    CookieJar.prototype.rejectPublicSuffixes = true;
    CookieJar.prototype.enableLooseMode = false;
    var CAN_BE_SYNC = [];
    CAN_BE_SYNC.push("setCookie");
    CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
      var err;
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
      var host = canonicalDomain(context.hostname);
      var loose = this.enableLooseMode;
      if (options.loose != null) {
        loose = options.loose;
      }
      if (!(cookie instanceof Cookie)) {
        cookie = Cookie.parse(cookie, { loose });
      }
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
      var now = options.now || new Date();
      if (this.rejectPublicSuffixes && cookie.domain) {
        var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
        if (suffix == null) {
          err = new Error("Cookie has domain set to a public suffix");
          return cb(options.ignoreError ? null : err);
        }
      }
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), false)) {
          err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host);
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.hostOnly == null) {
          cookie.hostOnly = false;
        }
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
      if (!cookie.path || cookie.path[0] !== "/") {
        cookie.path = defaultPath(context.pathname);
        cookie.pathIsDefault = true;
      }
      if (options.http === false && cookie.httpOnly) {
        err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      var store = this.store;
      if (!store.updateCookie) {
        store.updateCookie = function(oldCookie, newCookie, cb2) {
          this.putCookie(newCookie, cb2);
        };
      }
      function withCookie(err2, oldCookie) {
        if (err2) {
          return cb(err2);
        }
        var next = function(err3) {
          if (err3) {
            return cb(err3);
          } else {
            cb(null, cookie);
          }
        };
        if (oldCookie) {
          if (options.http === false && oldCookie.httpOnly) {
            err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err2);
          }
          cookie.creation = oldCookie.creation;
          cookie.creationIndex = oldCookie.creationIndex;
          cookie.lastAccessed = now;
          store.updateCookie(oldCookie, cookie, next);
        } else {
          cookie.creation = cookie.lastAccessed = now;
          store.putCookie(cookie, next);
        }
      }
      store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    };
    CAN_BE_SYNC.push("getCookies");
    CookieJar.prototype.getCookies = function(url, options, cb) {
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
      var host = canonicalDomain(context.hostname);
      var path = context.pathname || "/";
      var secure = options.secure;
      if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
        secure = true;
      }
      var http = options.http;
      if (http == null) {
        http = true;
      }
      var now = options.now || Date.now();
      var expireCheck = options.expire !== false;
      var allPaths = !!options.allPaths;
      var store = this.store;
      function matchingCookie(c) {
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!domainMatch(host, c.domain, false)) {
            return false;
          }
        }
        if (!allPaths && !pathMatch(path, c.path)) {
          return false;
        }
        if (c.secure && !secure) {
          return false;
        }
        if (c.httpOnly && !http) {
          return false;
        }
        if (expireCheck && c.expiryTime() <= now) {
          store.removeCookie(c.domain, c.path, c.key, function() {
          });
          return false;
        }
        return true;
      }
      store.findCookies(host, allPaths ? null : path, function(err, cookies) {
        if (err) {
          return cb(err);
        }
        cookies = cookies.filter(matchingCookie);
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }
        var now2 = new Date();
        cookies.forEach(function(c) {
          c.lastAccessed = now2;
        });
        cb(null, cookies);
      });
    };
    CAN_BE_SYNC.push("getCookieString");
    CookieJar.prototype.getCookieString = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var cb = args.pop();
      var next = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.sort(cookieCompare).map(function(c) {
            return c.cookieString();
          }).join("; "));
        }
      };
      args.push(next);
      this.getCookies.apply(this, args);
    };
    CAN_BE_SYNC.push("getSetCookieStrings");
    CookieJar.prototype.getSetCookieStrings = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var cb = args.pop();
      var next = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.map(function(c) {
            return c.toString();
          }));
        }
      };
      args.push(next);
      this.getCookies.apply(this, args);
    };
    CAN_BE_SYNC.push("serialize");
    CookieJar.prototype.serialize = function(cb) {
      var type = this.store.constructor.name;
      if (type === "Object") {
        type = null;
      }
      var serialized = {
        version: "tough-cookie@" + VERSION,
        storeType: type,
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
        cookies: []
      };
      if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
        return cb(new Error("store does not support getAllCookies and cannot be serialized"));
      }
      this.store.getAllCookies(function(err, cookies) {
        if (err) {
          return cb(err);
        }
        serialized.cookies = cookies.map(function(cookie) {
          cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
          delete cookie.creationIndex;
          return cookie;
        });
        return cb(null, serialized);
      });
    };
    CookieJar.prototype.toJSON = function() {
      return this.serializeSync();
    };
    CAN_BE_SYNC.push("_importCookies");
    CookieJar.prototype._importCookies = function(serialized, cb) {
      var jar = this;
      var cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies)) {
        return cb(new Error("serialized jar has no cookies array"));
      }
      cookies = cookies.slice();
      function putNext(err) {
        if (err) {
          return cb(err);
        }
        if (!cookies.length) {
          return cb(err, jar);
        }
        var cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
        if (cookie === null) {
          return putNext(null);
        }
        jar.store.putCookie(cookie, putNext);
      }
      putNext();
    };
    CookieJar.deserialize = function(strOrObj, store, cb) {
      if (arguments.length !== 3) {
        cb = store;
        store = null;
      }
      var serialized;
      if (typeof strOrObj === "string") {
        serialized = jsonParse(strOrObj);
        if (serialized instanceof Error) {
          return cb(serialized);
        }
      } else {
        serialized = strOrObj;
      }
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
      jar._importCookies(serialized, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, jar);
      });
    };
    CookieJar.deserializeSync = function(strOrObj, store) {
      var serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
      if (!jar.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      jar._importCookiesSync(serialized);
      return jar;
    };
    CookieJar.fromJSON = CookieJar.deserializeSync;
    CAN_BE_SYNC.push("clone");
    CookieJar.prototype.clone = function(newStore, cb) {
      if (arguments.length === 1) {
        cb = newStore;
        newStore = null;
      }
      this.serialize(function(err, serialized) {
        if (err) {
          return cb(err);
        }
        CookieJar.deserialize(newStore, serialized, cb);
      });
    };
    function syncWrap(method) {
      return function() {
        if (!this.store.synchronous) {
          throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        var args = Array.prototype.slice.call(arguments);
        var syncErr, syncResult;
        args.push(function syncCb(err, result) {
          syncErr = err;
          syncResult = result;
        });
        this[method].apply(this, args);
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    CAN_BE_SYNC.forEach(function(method) {
      CookieJar.prototype[method + "Sync"] = syncWrap(method);
    });
    module.exports = {
      CookieJar,
      Cookie,
      Store,
      MemoryCookieStore,
      parseDate,
      formatDate,
      parse,
      fromJSON,
      domainMatch,
      defaultPath,
      pathMatch,
      getPublicSuffix: pubsuffix.getPublicSuffix,
      cookieCompare,
      permuteDomain: require_permuteDomain().permuteDomain,
      permutePath,
      canonicalDomain
    };
  }
});

// node_modules/request/lib/cookies.js
var require_cookies = __commonJS({
  "node_modules/request/lib/cookies.js"(exports) {
    "use strict";
    var tough = require_cookie();
    var Cookie = tough.Cookie;
    var CookieJar = tough.CookieJar;
    exports.parse = function(str) {
      if (str && str.uri) {
        str = str.uri;
      }
      if (typeof str !== "string") {
        throw new Error("The cookie function only accepts STRING as param");
      }
      return Cookie.parse(str, { loose: true });
    };
    function RequestJar(store) {
      var self2 = this;
      self2._jar = new CookieJar(store, { looseMode: true });
    }
    RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
      var self2 = this;
      return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
    };
    RequestJar.prototype.getCookieString = function(uri) {
      var self2 = this;
      return self2._jar.getCookieStringSync(uri);
    };
    RequestJar.prototype.getCookies = function(uri) {
      var self2 = this;
      return self2._jar.getCookiesSync(uri);
    };
    exports.jar = function(store) {
      return new RequestJar(store);
    };
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-stringify-safe/stringify.js"(exports, module) {
    exports = module.exports = stringify;
    exports.getSerialize = serializer;
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];
      if (cycleReplacer == null)
        cycleReplacer = function(key, value) {
          if (stack[0] === value)
            return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value))
            value = cycleReplacer.call(this, key, value);
        } else
          stack.push(value);
        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = (init_buffer(), __toCommonJS(buffer_exports));
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/request/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/request/lib/helpers.js"(exports) {
    "use strict";
    var jsonSafeStringify = require_stringify();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Buffer2 = require_safe_buffer().Buffer;
    var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
    function paramsHaveRequestBody(params) {
      return params.body || params.requestBodyStream || params.json && typeof params.json !== "boolean" || params.multipart;
    }
    function safeStringify(obj, replacer) {
      var ret;
      try {
        ret = JSON.stringify(obj, replacer);
      } catch (e) {
        ret = jsonSafeStringify(obj, replacer);
      }
      return ret;
    }
    function md5(str) {
      return crypto.createHash("md5").update(str).digest("hex");
    }
    function isReadStream(rs) {
      return rs.readable && rs.path && rs.mode;
    }
    function toBase64(str) {
      return Buffer2.from(str || "", "utf8").toString("base64");
    }
    function copy(obj) {
      var o = {};
      Object.keys(obj).forEach(function(i) {
        o[i] = obj[i];
      });
      return o;
    }
    function version() {
      var numbers = process.version.replace("v", "").split(".");
      return {
        major: parseInt(numbers[0], 10),
        minor: parseInt(numbers[1], 10),
        patch: parseInt(numbers[2], 10)
      };
    }
    exports.paramsHaveRequestBody = paramsHaveRequestBody;
    exports.safeStringify = safeStringify;
    exports.md5 = md5;
    exports.isReadStream = isReadStream;
    exports.toBase64 = toBase64;
    exports.copy = copy;
    exports.version = version;
    exports.defer = defer;
  }
});

// browser-external:https
var https_exports = {};
__export(https_exports, {
  default: () => https_default
});
var https_default;
var init_https = __esm({
  "browser-external:https"() {
    https_default = new Proxy({}, {
      get() {
        throw new Error('Module "https" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS({
  "node_modules/aws-sign2/index.js"(exports, module) {
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var parse = (init_url(), __toCommonJS(url_exports)).parse;
    var keys = [
      "acl",
      "location",
      "logging",
      "notification",
      "partNumber",
      "policy",
      "requestPayment",
      "torrent",
      "uploadId",
      "uploads",
      "versionId",
      "versioning",
      "versions",
      "website"
    ];
    function authorization(options) {
      return "AWS " + options.key + ":" + sign(options);
    }
    module.exports = authorization;
    module.exports.authorization = authorization;
    function hmacSha1(options) {
      return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
    }
    module.exports.hmacSha1 = hmacSha1;
    function sign(options) {
      options.message = stringToSign(options);
      return hmacSha1(options);
    }
    module.exports.sign = sign;
    function signQuery(options) {
      options.message = queryStringToSign(options);
      return hmacSha1(options);
    }
    module.exports.signQuery = signQuery;
    function stringToSign(options) {
      var headers = options.amazonHeaders || "";
      if (headers)
        headers += "\n";
      var r = [
        options.verb,
        options.md5,
        options.contentType,
        options.date ? options.date.toUTCString() : "",
        headers + options.resource
      ];
      return r.join("\n");
    }
    module.exports.stringToSign = stringToSign;
    function queryStringToSign(options) {
      return "GET\n\n\n" + options.date + "\n" + options.resource;
    }
    module.exports.queryStringToSign = queryStringToSign;
    function canonicalizeHeaders(headers) {
      var buf = [], fields = Object.keys(headers);
      for (var i = 0, len = fields.length; i < len; ++i) {
        var field = fields[i], val = headers[field], field = field.toLowerCase();
        if (field.indexOf("x-amz") !== 0)
          continue;
        buf.push(field + ":" + val);
      }
      return buf.sort().join("\n");
    }
    module.exports.canonicalizeHeaders = canonicalizeHeaders;
    function canonicalizeResource(resource) {
      var url = parse(resource, true), path = url.pathname, buf = [];
      Object.keys(url.query).forEach(function(key) {
        if (!~keys.indexOf(key))
          return;
        var val = url.query[key] == "" ? "" : "=" + encodeURIComponent(url.query[key]);
        buf.push(key + val);
      });
      return path + (buf.length ? "?" + buf.sort().join("&") : "");
    }
    module.exports.canonicalizeResource = canonicalizeResource;
  }
});

// node_modules/aws4/lru.js
var require_lru = __commonJS({
  "node_modules/aws4/lru.js"(exports, module) {
    module.exports = function(size) {
      return new LruCache(size);
    };
    function LruCache(size) {
      this.capacity = size | 0;
      this.map = /* @__PURE__ */ Object.create(null);
      this.list = new DoublyLinkedList();
    }
    LruCache.prototype.get = function(key) {
      var node = this.map[key];
      if (node == null)
        return void 0;
      this.used(node);
      return node.val;
    };
    LruCache.prototype.set = function(key, val) {
      var node = this.map[key];
      if (node != null) {
        node.val = val;
      } else {
        if (!this.capacity)
          this.prune();
        if (!this.capacity)
          return false;
        node = new DoublyLinkedNode(key, val);
        this.map[key] = node;
        this.capacity--;
      }
      this.used(node);
      return true;
    };
    LruCache.prototype.used = function(node) {
      this.list.moveToFront(node);
    };
    LruCache.prototype.prune = function() {
      var node = this.list.pop();
      if (node != null) {
        delete this.map[node.key];
        this.capacity++;
      }
    };
    function DoublyLinkedList() {
      this.firstNode = null;
      this.lastNode = null;
    }
    DoublyLinkedList.prototype.moveToFront = function(node) {
      if (this.firstNode == node)
        return;
      this.remove(node);
      if (this.firstNode == null) {
        this.firstNode = node;
        this.lastNode = node;
        node.prev = null;
        node.next = null;
      } else {
        node.prev = null;
        node.next = this.firstNode;
        node.next.prev = node;
        this.firstNode = node;
      }
    };
    DoublyLinkedList.prototype.pop = function() {
      var lastNode = this.lastNode;
      if (lastNode != null) {
        this.remove(lastNode);
      }
      return lastNode;
    };
    DoublyLinkedList.prototype.remove = function(node) {
      if (this.firstNode == node) {
        this.firstNode = node.next;
      } else if (node.prev != null) {
        node.prev.next = node.next;
      }
      if (this.lastNode == node) {
        this.lastNode = node.prev;
      } else if (node.next != null) {
        node.next.prev = node.prev;
      }
    };
    function DoublyLinkedNode(key, val) {
      this.key = key;
      this.val = val;
      this.prev = null;
      this.next = null;
    }
  }
});

// node_modules/aws4/aws4.js
var require_aws4 = __commonJS({
  "node_modules/aws4/aws4.js"(exports) {
    var aws4 = exports;
    var url = (init_url(), __toCommonJS(url_exports));
    var querystring = (init_querystring(), __toCommonJS(querystring_exports));
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var lru = require_lru();
    var credentialsCache = lru(1e3);
    function hmac(key, string, encoding) {
      return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
    }
    function hash(string, encoding) {
      return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeRfc3986Full(str) {
      return encodeRfc3986(encodeURIComponent(str));
    }
    var HEADERS_TO_IGNORE = {
      "authorization": true,
      "connection": true,
      "x-amzn-trace-id": true,
      "user-agent": true,
      "expect": true,
      "presigned-expires": true,
      "range": true
    };
    function RequestSigner(request, credentials) {
      if (typeof request === "string")
        request = url.parse(request);
      var headers = request.headers = request.headers || {}, hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);
      this.request = request;
      this.credentials = credentials || this.defaultCredentials();
      this.service = request.service || hostParts[0] || "";
      this.region = request.region || hostParts[1] || "us-east-1";
      if (this.service === "email")
        this.service = "ses";
      if (!request.method && request.body)
        request.method = "POST";
      if (!headers.Host && !headers.host) {
        headers.Host = request.hostname || request.host || this.createHost();
        if (request.port)
          headers.Host += ":" + request.port;
      }
      if (!request.hostname && !request.host)
        request.hostname = headers.Host || headers.host;
      this.isCodeCommitGit = this.service === "codecommit" && request.method === "GIT";
    }
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || "").match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/);
      var hostParts = (match || []).slice(1, 3);
      if (hostParts[1] === "es")
        hostParts = hostParts.reverse();
      if (hostParts[1] == "s3") {
        hostParts[0] = "s3";
        hostParts[1] = "us-east-1";
      } else {
        for (var i = 0; i < 2; i++) {
          if (/^s3-/.test(hostParts[i])) {
            hostParts[1] = hostParts[i].slice(3);
            hostParts[0] = "s3";
            break;
          }
        }
      }
      return hostParts;
    };
    RequestSigner.prototype.isSingleRegion = function() {
      if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
        return true;
      return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
    };
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
      return subdomain + region + ".amazonaws.com";
    };
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath();
      var request = this.request, headers = request.headers, query;
      if (request.signQuery) {
        this.parsedPath.query = query = this.parsedPath.query || {};
        if (this.credentials.sessionToken)
          query["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !query["X-Amz-Expires"])
          query["X-Amz-Expires"] = 86400;
        if (query["X-Amz-Date"])
          this.datetime = query["X-Amz-Date"];
        else
          query["X-Amz-Date"] = this.getDateTime();
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
        query["X-Amz-SignedHeaders"] = this.signedHeaders();
      } else {
        if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
          if (request.body && !headers["Content-Type"] && !headers["content-type"])
            headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
          if (request.body && !headers["Content-Length"] && !headers["content-length"])
            headers["Content-Length"] = Buffer.byteLength(request.body);
          if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
            headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
          if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
            headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
          if (headers["X-Amz-Date"] || headers["x-amz-date"])
            this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
          else
            headers["X-Amz-Date"] = this.getDateTime();
        }
        delete headers.Authorization;
        delete headers.authorization;
      }
    };
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      if (this.request.signQuery) {
        this.parsedPath.query["X-Amz-Signature"] = this.signature();
      } else {
        this.request.headers.Authorization = this.authHeader();
      }
      this.request.path = this.formatPath();
      return this.request;
    };
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date());
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
        if (this.isCodeCommitGit)
          this.datetime = this.datetime.slice(0, -1);
      }
      return this.datetime;
    };
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8);
    };
    RequestSigner.prototype.authHeader = function() {
      return [
        "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
        "SignedHeaders=" + this.signedHeaders(),
        "Signature=" + this.signature()
      ].join(", ");
    };
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
      if (!kCredentials) {
        kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
        kRegion = hmac(kDate, this.region);
        kService = hmac(kRegion, this.service);
        kCredentials = hmac(kService, "aws4_request");
        credentialsCache.set(cacheKey, kCredentials);
      }
      return hmac(kCredentials, this.stringToSign(), "hex");
    };
    RequestSigner.prototype.stringToSign = function() {
      return [
        "AWS4-HMAC-SHA256",
        this.getDateTime(),
        this.credentialString(),
        hash(this.canonicalString(), "hex")
      ].join("\n");
    };
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
      if (this.service === "s3" && this.request.signQuery) {
        bodyHash = "UNSIGNED-PAYLOAD";
      } else if (this.isCodeCommitGit) {
        bodyHash = "";
      } else {
        bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
      }
      if (query) {
        var reducedQuery = Object.keys(query).reduce(function(obj, key) {
          if (!key)
            return obj;
          obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
          return obj;
        }, {});
        var encodedQueryPieces = [];
        Object.keys(reducedQuery).sort().forEach(function(key) {
          if (!Array.isArray(reducedQuery[key])) {
            encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
          } else {
            reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val) {
              encodedQueryPieces.push(key + "=" + val);
            });
          }
        });
        queryStr = encodedQueryPieces.join("&");
      }
      if (pathStr !== "/") {
        if (normalizePath)
          pathStr = pathStr.replace(/\/{2,}/g, "/");
        pathStr = pathStr.split("/").reduce(function(path, piece) {
          if (normalizePath && piece === "..") {
            path.pop();
          } else if (!normalizePath || piece !== ".") {
            if (decodePath)
              piece = decodeURIComponent(piece.replace(/\+/g, " "));
            path.push(encodeRfc3986Full(piece));
          }
          return path;
        }, []).join("/");
        if (pathStr[0] !== "/")
          pathStr = "/" + pathStr;
        if (decodeSlashesInPath)
          pathStr = pathStr.replace(/%2F/g, "/");
      }
      return [
        this.request.method || "GET",
        pathStr,
        queryStr,
        this.canonicalHeaders() + "\n",
        this.signedHeaders(),
        bodyHash
      ].join("\n");
    };
    RequestSigner.prototype.canonicalHeaders = function() {
      var headers = this.request.headers;
      function trimAll(header) {
        return header.toString().trim().replace(/\s+/g, " ");
      }
      return Object.keys(headers).filter(function(key) {
        return HEADERS_TO_IGNORE[key.toLowerCase()] == null;
      }).sort(function(a, b) {
        return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
      }).map(function(key) {
        return key.toLowerCase() + ":" + trimAll(headers[key]);
      }).join("\n");
    };
    RequestSigner.prototype.signedHeaders = function() {
      return Object.keys(this.request.headers).map(function(key) {
        return key.toLowerCase();
      }).filter(function(key) {
        return HEADERS_TO_IGNORE[key] == null;
      }).sort().join(";");
    };
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        "aws4_request"
      ].join("/");
    };
    RequestSigner.prototype.defaultCredentials = function() {
      var env = process.env;
      return {
        accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
        sessionToken: env.AWS_SESSION_TOKEN
      };
    };
    RequestSigner.prototype.parsePath = function() {
      var path = this.request.path || "/";
      if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
        path = encodeURI(decodeURI(path));
      }
      var queryIx = path.indexOf("?"), query = null;
      if (queryIx >= 0) {
        query = querystring.parse(path.slice(queryIx + 1));
        path = path.slice(0, queryIx);
      }
      this.parsedPath = {
        path,
        query
      };
    };
    RequestSigner.prototype.formatPath = function() {
      var path = this.parsedPath.path, query = this.parsedPath.query;
      if (!query)
        return path;
      if (query[""] != null)
        delete query[""];
      return path + "?" + encodeRfc3986(querystring.stringify(query));
    };
    aws4.RequestSigner = RequestSigner;
    aws4.sign = function(request, credentials) {
      return new RequestSigner(request, credentials).sign();
    };
  }
});

// browser-external:assert
var assert_exports = {};
__export(assert_exports, {
  default: () => assert_default
});
var assert_default;
var init_assert = __esm({
  "browser-external:assert"() {
    assert_default = new Proxy({}, {
      get() {
        throw new Error('Module "assert" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/assert-plus/assert.js
var require_assert = __commonJS({
  "node_modules/assert-plus/assert.js"(exports, module) {
    var assert = (init_assert(), __toCommonJS(assert_exports));
    var Stream = (init_stream(), __toCommonJS(stream_exports)).Stream;
    var util = (init_util(), __toCommonJS(util_exports));
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert.AssertionError({
        message: util.format("%s (%s) is required", name, expected),
        actual: actual === void 0 ? typeof arg : actual(arg),
        expected,
        operator: oper || "===",
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return Object.prototype.toString.call(arg).slice(8, -1);
    }
    function noop() {
    }
    var types = {
      bool: {
        check: function(arg) {
          return typeof arg === "boolean";
        }
      },
      func: {
        check: function(arg) {
          return typeof arg === "function";
        }
      },
      string: {
        check: function(arg) {
          return typeof arg === "string";
        }
      },
      object: {
        check: function(arg) {
          return typeof arg === "object" && arg !== null;
        }
      },
      number: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg);
        }
      },
      finite: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
        }
      },
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: "Buffer.isBuffer"
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: "Array.isArray"
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream;
        },
        operator: "instanceof",
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: "instanceof",
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: "instanceof",
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof arg === "string" && UUID_REGEXP.test(arg);
        },
        operator: "isUUID"
      }
    };
    function _setExports(ndebug) {
      var keys = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, "true", arg);
          }
        };
      }
      keys.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type = types[k];
        out[k] = function(arg, msg) {
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optional" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "arrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optionalArrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      Object.keys(assert).forEach(function(k) {
        if (k === "AssertionError") {
          out[k] = assert[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module.exports = _setExports(process.env.NODE_NDEBUG);
  }
});

// node_modules/sshpk/lib/algs.js
var require_algs = __commonJS({
  "node_modules/sshpk/lib/algs.js"(exports, module) {
    var Buffer2 = require_safer().Buffer;
    var algInfo = {
      "dsa": {
        parts: ["p", "q", "g", "y"],
        sizePart: "p"
      },
      "rsa": {
        parts: ["e", "n"],
        sizePart: "n"
      },
      "ecdsa": {
        parts: ["curve", "Q"],
        sizePart: "Q"
      },
      "ed25519": {
        parts: ["A"],
        sizePart: "A"
      }
    };
    algInfo["curve25519"] = algInfo["ed25519"];
    var algPrivInfo = {
      "dsa": {
        parts: ["p", "q", "g", "y", "x"]
      },
      "rsa": {
        parts: ["n", "e", "d", "iqmp", "p", "q"]
      },
      "ecdsa": {
        parts: ["curve", "Q", "d"]
      },
      "ed25519": {
        parts: ["A", "k"]
      }
    };
    algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
    var hashAlgs = {
      "md5": true,
      "sha1": true,
      "sha256": true,
      "sha384": true,
      "sha512": true
    };
    var curves = {
      "nistp256": {
        size: 256,
        pkcs8oid: "1.2.840.10045.3.1.7",
        p: Buffer2.from("00ffffffff 00000001 00000000 0000000000000000 ffffffff ffffffff ffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("00FFFFFFFF 00000001 00000000 0000000000000000 FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("5ac635d8 aa3a93e7 b3ebbd55 769886bc651d06b0 cc53b0f6 3bce3c3e 27d2604b".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00c49d3608 86e70493 6a6678e1 139d26b7819f7e90".replace(/ /g, ""), "hex"),
        n: Buffer2.from("00ffffffff 00000000 ffffffff ffffffffbce6faad a7179e84 f3b9cac2 fc632551".replace(/ /g, ""), "hex"),
        G: Buffer2.from("046b17d1f2 e12c4247 f8bce6e5 63a440f277037d81 2deb33a0 f4a13945 d898c2964fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e162bce3357 6b315ece cbb64068 37bf51f5".replace(/ /g, ""), "hex")
      },
      "nistp384": {
        size: 384,
        pkcs8oid: "1.3.132.0.34",
        p: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffeffffffff 00000000 00000000 ffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("00FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFEFFFFFFFF 00000000 00000000 FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("b3312fa7 e23ee7e4 988e056b e3f82d19181d9c6e fe814112 0314088f 5013875ac656398d 8a2ed19d 2a85c8ed d3ec2aef".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00a335926a a319a27a 1d00896a 6773a4827acdac73".replace(/ /g, ""), "hex"),
        n: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff c7634d81 f4372ddf581a0db2 48b0a77a ecec196a ccc52973".replace(/ /g, ""), "hex"),
        G: Buffer2.from("04aa87ca22 be8b0537 8eb1c71e f320ad746e1d3b62 8ba79b98 59f741e0 82542a385502f25d bf55296c 3a545e38 72760ab73617de4a 96262c6f 5d9e98bf 9292dc29f8f41dbd 289a147c e9da3113 b5f0b8c00a60b1ce 1d7e819d 7a431d7c 90ea0e5f".replace(/ /g, ""), "hex")
      },
      "nistp521": {
        size: 521,
        pkcs8oid: "1.3.132.0.35",
        p: Buffer2.from("01ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("01FFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("51953eb961 8e1c9a1f 929a21a0 b68540eea2da725b 99b315f3 b8b48991 8ef109e156193951 ec7e937b 1652c0bd 3bb1bf073573df88 3d2c34f1 ef451fd4 6b503f00".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00d09e8800 291cb853 96cc6717 393284aaa0da64ba".replace(/ /g, ""), "hex"),
        n: Buffer2.from("01ffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffa51868783 bf2f966b 7fcc0148 f709a5d03bb5c9b8 899c47ae bb6fb71e 91386409".replace(/ /g, ""), "hex"),
        G: Buffer2.from("0400c6 858e06b7 0404e9cd 9e3ecb66 2395b4429c648139 053fb521 f828af60 6b4d3dbaa14b5e77 efe75928 fe1dc127 a2ffa8de3348b3c1 856a429b f97e7e31 c2e5bd660118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd998f54449 579b4468 17afbd17 273e662c97ee7299 5ef42640 c550b901 3fad0761353c7086 a272c240 88be9476 9fd16650".replace(/ /g, ""), "hex")
      }
    };
    module.exports = {
      info: algInfo,
      privInfo: algPrivInfo,
      hashAlgs,
      curves
    };
  }
});

// node_modules/sshpk/lib/errors.js
var require_errors = __commonJS({
  "node_modules/sshpk/lib/errors.js"(exports, module) {
    var assert = require_assert();
    var util = (init_util(), __toCommonJS(util_exports));
    function FingerprintFormatError(fp, format) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, FingerprintFormatError);
      this.name = "FingerprintFormatError";
      this.fingerprint = fp;
      this.format = format;
      this.message = "Fingerprint format is not supported, or is invalid: ";
      if (fp !== void 0)
        this.message += " fingerprint = " + fp;
      if (format !== void 0)
        this.message += " format = " + format;
    }
    util.inherits(FingerprintFormatError, Error);
    function InvalidAlgorithmError(alg) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, InvalidAlgorithmError);
      this.name = "InvalidAlgorithmError";
      this.algorithm = alg;
      this.message = 'Algorithm "' + alg + '" is not supported';
    }
    util.inherits(InvalidAlgorithmError, Error);
    function KeyParseError(name, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, KeyParseError);
      this.name = "KeyParseError";
      this.format = format;
      this.keyName = name;
      this.innerErr = innerErr;
      this.message = "Failed to parse " + name + " as a valid " + format + " format key: " + innerErr.message;
    }
    util.inherits(KeyParseError, Error);
    function SignatureParseError(type, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, SignatureParseError);
      this.name = "SignatureParseError";
      this.type = type;
      this.format = format;
      this.innerErr = innerErr;
      this.message = "Failed to parse the given data as a " + type + " signature in " + format + " format: " + innerErr.message;
    }
    util.inherits(SignatureParseError, Error);
    function CertificateParseError(name, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CertificateParseError);
      this.name = "CertificateParseError";
      this.format = format;
      this.certName = name;
      this.innerErr = innerErr;
      this.message = "Failed to parse " + name + " as a valid " + format + " format certificate: " + innerErr.message;
    }
    util.inherits(CertificateParseError, Error);
    function KeyEncryptedError(name, format) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, KeyEncryptedError);
      this.name = "KeyEncryptedError";
      this.format = format;
      this.keyName = name;
      this.message = "The " + format + " format key " + name + " is encrypted (password-protected), and no passphrase was provided in `options`";
    }
    util.inherits(KeyEncryptedError, Error);
    module.exports = {
      FingerprintFormatError,
      InvalidAlgorithmError,
      KeyParseError,
      SignatureParseError,
      KeyEncryptedError,
      CertificateParseError
    };
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports, module) {
    module.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports, module) {
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports, module) {
    var assert = (init_assert(), __toCommonJS(assert_exports));
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer2.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer2.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values = [];
      var value = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value <<= 7;
        value += byte & 127;
        if ((byte & 128) === 0) {
          values.push(value);
          value = 0;
        }
      }
      value = values.shift();
      values.unshift(value % 40);
      values.unshift(value / 40 >> 0);
      return values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value = 0;
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value -= 1 << i * 8;
      return value >> 0;
    };
    module.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports, module) {
    var assert = (init_assert(), __toCommonJS(assert_exports));
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof from, "object");
      assert.ok(to);
      assert.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
      return to;
    }
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports, module) {
    var errors = require_errors2();
    var types = require_types();
    var Reader = require_reader();
    var Writer = require_writer();
    module.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/asn1/lib/index.js"(exports, module) {
    var Ber = require_ber();
    module.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/jsbn/index.js"(exports, module) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q2, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q2 != null)
            q2.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q2 != null) {
          r.drShiftTo(ys, q2);
          if (ts != ms)
            BigInteger.ZERO.subTo(q2, q2);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q2 = nbi(), r = nbi();
        this.divRemTo(a, q2, r);
        return new Array(q2, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom2() {
      }
      SecureRandom2.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      BigInteger.SecureRandom = SecureRandom2;
      BigInteger.BigInteger = BigInteger;
      if (typeof exports !== "undefined") {
        exports = module.exports = BigInteger;
      } else {
        this.BigInteger = BigInteger;
        this.SecureRandom = SecureRandom2;
      }
    }).call(exports);
  }
});

// node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS({
  "node_modules/ecc-jsbn/lib/ec.js"(exports, module) {
    var BigInteger = require_jsbn().BigInteger;
    var Barrett = BigInteger.prototype.Barrett;
    function ECFieldElementFp(q2, x) {
      this.x = x;
      this.q = q2;
    }
    function feFpEquals(other) {
      if (other == this)
        return true;
      return this.q.equals(other.q) && this.x.equals(other.x);
    }
    function feFpToBigInteger() {
      return this.x;
    }
    function feFpNegate() {
      return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
    }
    function feFpAdd(b) {
      return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
    }
    function feFpSubtract(b) {
      return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
    }
    function feFpMultiply(b) {
      return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
    }
    function feFpSquare() {
      return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
    }
    function feFpDivide(b) {
      return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
    }
    ECFieldElementFp.prototype.equals = feFpEquals;
    ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
    ECFieldElementFp.prototype.negate = feFpNegate;
    ECFieldElementFp.prototype.add = feFpAdd;
    ECFieldElementFp.prototype.subtract = feFpSubtract;
    ECFieldElementFp.prototype.multiply = feFpMultiply;
    ECFieldElementFp.prototype.square = feFpSquare;
    ECFieldElementFp.prototype.divide = feFpDivide;
    function ECPointFp(curve, x, y, z) {
      this.curve = curve;
      this.x = x;
      this.y = y;
      if (z == null) {
        this.z = BigInteger.ONE;
      } else {
        this.z = z;
      }
      this.zinv = null;
    }
    function pointFpGetX() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      var r = this.x.toBigInteger().multiply(this.zinv);
      this.curve.reduce(r);
      return this.curve.fromBigInteger(r);
    }
    function pointFpGetY() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      var r = this.y.toBigInteger().multiply(this.zinv);
      this.curve.reduce(r);
      return this.curve.fromBigInteger(r);
    }
    function pointFpEquals(other) {
      if (other == this)
        return true;
      if (this.isInfinity())
        return other.isInfinity();
      if (other.isInfinity())
        return this.isInfinity();
      var u, v;
      u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
      if (!u.equals(BigInteger.ZERO))
        return false;
      v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
      return v.equals(BigInteger.ZERO);
    }
    function pointFpIsInfinity() {
      if (this.x == null && this.y == null)
        return true;
      return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
    }
    function pointFpNegate() {
      return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
    }
    function pointFpAdd(b) {
      if (this.isInfinity())
        return b;
      if (b.isInfinity())
        return this;
      var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
      var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
      if (BigInteger.ZERO.equals(v)) {
        if (BigInteger.ZERO.equals(u)) {
          return this.twice();
        }
        return this.curve.getInfinity();
      }
      var THREE = new BigInteger("3");
      var x1 = this.x.toBigInteger();
      var y1 = this.y.toBigInteger();
      var x2 = b.x.toBigInteger();
      var y2 = b.y.toBigInteger();
      var v2 = v.square();
      var v3 = v2.multiply(v);
      var x1v2 = x1.multiply(v2);
      var zu2 = u.square().multiply(this.z);
      var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
      var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
      var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    }
    function pointFpTwice() {
      if (this.isInfinity())
        return this;
      if (this.y.toBigInteger().signum() == 0)
        return this.curve.getInfinity();
      var THREE = new BigInteger("3");
      var x1 = this.x.toBigInteger();
      var y1 = this.y.toBigInteger();
      var y1z1 = y1.multiply(this.z);
      var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
      var a = this.curve.a.toBigInteger();
      var w = x1.square().multiply(THREE);
      if (!BigInteger.ZERO.equals(a)) {
        w = w.add(this.z.square().multiply(a));
      }
      w = w.mod(this.curve.q);
      var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
      var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
      var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    }
    function pointFpMultiply(k) {
      if (this.isInfinity())
        return this;
      if (k.signum() == 0)
        return this.curve.getInfinity();
      var e = k;
      var h = e.multiply(new BigInteger("3"));
      var neg = this.negate();
      var R = this;
      var i;
      for (i = h.bitLength() - 2; i > 0; --i) {
        R = R.twice();
        var hBit = h.testBit(i);
        var eBit = e.testBit(i);
        if (hBit != eBit) {
          R = R.add(hBit ? this : neg);
        }
      }
      return R;
    }
    function pointFpMultiplyTwo(j, x, k) {
      var i;
      if (j.bitLength() > k.bitLength())
        i = j.bitLength() - 1;
      else
        i = k.bitLength() - 1;
      var R = this.curve.getInfinity();
      var both = this.add(x);
      while (i >= 0) {
        R = R.twice();
        if (j.testBit(i)) {
          if (k.testBit(i)) {
            R = R.add(both);
          } else {
            R = R.add(this);
          }
        } else {
          if (k.testBit(i)) {
            R = R.add(x);
          }
        }
        --i;
      }
      return R;
    }
    ECPointFp.prototype.getX = pointFpGetX;
    ECPointFp.prototype.getY = pointFpGetY;
    ECPointFp.prototype.equals = pointFpEquals;
    ECPointFp.prototype.isInfinity = pointFpIsInfinity;
    ECPointFp.prototype.negate = pointFpNegate;
    ECPointFp.prototype.add = pointFpAdd;
    ECPointFp.prototype.twice = pointFpTwice;
    ECPointFp.prototype.multiply = pointFpMultiply;
    ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
    function ECCurveFp(q2, a, b) {
      this.q = q2;
      this.a = this.fromBigInteger(a);
      this.b = this.fromBigInteger(b);
      this.infinity = new ECPointFp(this, null, null);
      this.reducer = new Barrett(this.q);
    }
    function curveFpGetQ() {
      return this.q;
    }
    function curveFpGetA() {
      return this.a;
    }
    function curveFpGetB() {
      return this.b;
    }
    function curveFpEquals(other) {
      if (other == this)
        return true;
      return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
    }
    function curveFpGetInfinity() {
      return this.infinity;
    }
    function curveFpFromBigInteger(x) {
      return new ECFieldElementFp(this.q, x);
    }
    function curveReduce(x) {
      this.reducer.reduce(x);
    }
    function curveFpEncodePointHex(p) {
      if (p.isInfinity())
        return "00";
      var xHex = p.getX().toBigInteger().toString(16);
      var yHex = p.getY().toBigInteger().toString(16);
      var oLen = this.getQ().toString(16).length;
      if (oLen % 2 != 0)
        oLen++;
      while (xHex.length < oLen) {
        xHex = "0" + xHex;
      }
      while (yHex.length < oLen) {
        yHex = "0" + yHex;
      }
      return "04" + xHex + yHex;
    }
    ECCurveFp.prototype.getQ = curveFpGetQ;
    ECCurveFp.prototype.getA = curveFpGetA;
    ECCurveFp.prototype.getB = curveFpGetB;
    ECCurveFp.prototype.equals = curveFpEquals;
    ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
    ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
    ECCurveFp.prototype.reduce = curveReduce;
    ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
    ECCurveFp.prototype.decodePointHex = function(s) {
      var yIsEven;
      switch (parseInt(s.substr(0, 2), 16)) {
        case 0:
          return this.infinity;
        case 2:
          yIsEven = false;
        case 3:
          if (yIsEven == void 0)
            yIsEven = true;
          var len = s.length - 2;
          var xHex = s.substr(2, len);
          var x = this.fromBigInteger(new BigInteger(xHex, 16));
          var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
          var beta = alpha.sqrt();
          if (beta == null)
            throw "Invalid point compression";
          var betaValue = beta.toBigInteger();
          if (betaValue.testBit(0) != yIsEven) {
            beta = this.fromBigInteger(this.getQ().subtract(betaValue));
          }
          return new ECPointFp(this, x, beta);
        case 4:
        case 6:
        case 7:
          var len = (s.length - 2) / 2;
          var xHex = s.substr(2, len);
          var yHex = s.substr(len + 2, len);
          return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
        default:
          return null;
      }
    };
    ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
      if (p.isInfinity())
        return "00";
      var xHex = p.getX().toBigInteger().toString(16);
      var oLen = this.getQ().toString(16).length;
      if (oLen % 2 != 0)
        oLen++;
      while (xHex.length < oLen)
        xHex = "0" + xHex;
      var yPrefix;
      if (p.getY().toBigInteger().isEven())
        yPrefix = "02";
      else
        yPrefix = "03";
      return yPrefix + xHex;
    };
    ECFieldElementFp.prototype.getR = function() {
      if (this.r != void 0)
        return this.r;
      this.r = null;
      var bitLength = this.q.bitLength();
      if (bitLength > 128) {
        var firstWord = this.q.shiftRight(bitLength - 64);
        if (firstWord.intValue() == -1) {
          this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
        }
      }
      return this.r;
    };
    ECFieldElementFp.prototype.modMult = function(x1, x2) {
      return this.modReduce(x1.multiply(x2));
    };
    ECFieldElementFp.prototype.modReduce = function(x) {
      if (this.getR() != null) {
        var qLen = q.bitLength();
        while (x.bitLength() > qLen + 1) {
          var u = x.shiftRight(qLen);
          var v = x.subtract(u.shiftLeft(qLen));
          if (!this.getR().equals(BigInteger.ONE)) {
            u = u.multiply(this.getR());
          }
          x = u.add(v);
        }
        while (x.compareTo(q) >= 0) {
          x = x.subtract(q);
        }
      } else {
        x = x.mod(q);
      }
      return x;
    };
    ECFieldElementFp.prototype.sqrt = function() {
      if (!this.q.testBit(0))
        throw "unsupported";
      if (this.q.testBit(1)) {
        var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
        return z.square().equals(this) ? z : null;
      }
      var qMinusOne = this.q.subtract(BigInteger.ONE);
      var legendreExponent = qMinusOne.shiftRight(1);
      if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
        return null;
      }
      var u = qMinusOne.shiftRight(2);
      var k = u.shiftLeft(1).add(BigInteger.ONE);
      var Q = this.x;
      var fourQ = modDouble(modDouble(Q));
      var U, V;
      do {
        var P;
        do {
          P = new BigInteger(this.q.bitLength(), new SecureRandom());
        } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
        var result = this.lucasSequence(P, Q, k);
        U = result[0];
        V = result[1];
        if (this.modMult(V, V).equals(fourQ)) {
          if (V.testBit(0)) {
            V = V.add(q);
          }
          V = V.shiftRight(1);
          return new ECFieldElementFp(q, V);
        }
      } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
      return null;
    };
    ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
      var n = k.bitLength();
      var s = k.getLowestSetBit();
      var Uh = BigInteger.ONE;
      var Vl = BigInteger.TWO;
      var Vh = P;
      var Ql = BigInteger.ONE;
      var Qh = BigInteger.ONE;
      for (var j = n - 1; j >= s + 1; --j) {
        Ql = this.modMult(Ql, Qh);
        if (k.testBit(j)) {
          Qh = this.modMult(Ql, Q);
          Uh = this.modMult(Uh, Vh);
          Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
          Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
        } else {
          Qh = Ql;
          Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
          Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
          Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        }
      }
      Ql = this.modMult(Ql, Qh);
      Qh = this.modMult(Ql, Q);
      Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
      Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
      Ql = this.modMult(Ql, Qh);
      for (var j = 1; j <= s; ++j) {
        Uh = this.modMult(Uh, Vl);
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        Ql = this.modMult(Ql, Ql);
      }
      return [Uh, Vl];
    };
    var exports = {
      ECCurveFp,
      ECPointFp,
      ECFieldElementFp
    };
    module.exports = exports;
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q2, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q2[i]);
          p[i] ^= t;
          q2[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q2, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n) {
        return crypto_scalarmult(q2, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q2) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q2[1], q2[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q2[0], q2[1]);
        M(b, b, t);
        M(c, p[3], q2[3]);
        M(c, c, D2);
        M(d, p[2], q2[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q2, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q2[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q2, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q2, b);
          add(q2, p);
          add(p, p);
          cswap(p, q2, b);
        }
      }
      function scalarbase(p, s) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X);
        set25519(q2[1], Y);
        set25519(q2[2], gf1);
        M(q2[3], X, Y);
        scalarmult(p, q2, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64)
          return -1;
        if (unpackneg(q2, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q2, h);
        scalarbase(q2, sm.subarray(32));
        add(p, q2);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n, p);
        return q2;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n);
        return q2;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto = (init_crypto(), __toCommonJS(crypto_exports));
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/sshpk/lib/utils.js
var require_utils = __commonJS({
  "node_modules/sshpk/lib/utils.js"(exports, module) {
    module.exports = {
      bufferSplit,
      addRSAMissing,
      calculateDSAPublic,
      calculateED25519Public,
      calculateX25519Public,
      mpNormalize,
      mpDenormalize,
      ecNormalize,
      countZeros,
      assertCompatible,
      isCompatible,
      opensslKeyDeriv,
      opensshCipherInfo,
      publicFromPrivateECDSA,
      zeroPadToLength,
      writeBitString,
      readBitString,
      pbkdf2
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var PrivateKey = require_private_key();
    var Key = require_key();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var algs = require_algs();
    var asn1 = require_lib2();
    var ec = require_ec();
    var jsbn = require_jsbn().BigInteger;
    var nacl = require_nacl_fast();
    var MAX_CLASS_DEPTH = 3;
    function isCompatible(obj, klass, needVer) {
      if (obj === null || typeof obj !== "object")
        return false;
      if (needVer === void 0)
        needVer = klass.prototype._sshpkApiVersion;
      if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
        return true;
      var proto = Object.getPrototypeOf(obj);
      var depth = 0;
      while (proto.constructor.name !== klass.name) {
        proto = Object.getPrototypeOf(proto);
        if (!proto || ++depth > MAX_CLASS_DEPTH)
          return false;
      }
      if (proto.constructor.name !== klass.name)
        return false;
      var ver = proto._sshpkApiVersion;
      if (ver === void 0)
        ver = klass._oldVersionDetect(obj);
      if (ver[0] != needVer[0] || ver[1] < needVer[1])
        return false;
      return true;
    }
    function assertCompatible(obj, klass, needVer, name) {
      if (name === void 0)
        name = "object";
      assert.ok(obj, name + " must not be null");
      assert.object(obj, name + " must be an object");
      if (needVer === void 0)
        needVer = klass.prototype._sshpkApiVersion;
      if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
        return;
      var proto = Object.getPrototypeOf(obj);
      var depth = 0;
      while (proto.constructor.name !== klass.name) {
        proto = Object.getPrototypeOf(proto);
        assert.ok(proto && ++depth <= MAX_CLASS_DEPTH, name + " must be a " + klass.name + " instance");
      }
      assert.strictEqual(proto.constructor.name, klass.name, name + " must be a " + klass.name + " instance");
      var ver = proto._sshpkApiVersion;
      if (ver === void 0)
        ver = klass._oldVersionDetect(obj);
      assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1], name + " must be compatible with " + klass.name + " klass version " + needVer[0] + "." + needVer[1]);
    }
    var CIPHER_LEN = {
      "des-ede3-cbc": { key: 24, iv: 8 },
      "aes-128-cbc": { key: 16, iv: 16 },
      "aes-256-cbc": { key: 32, iv: 16 }
    };
    var PKCS5_SALT_LEN = 8;
    function opensslKeyDeriv(cipher, salt, passphrase, count) {
      assert.buffer(salt, "salt");
      assert.buffer(passphrase, "passphrase");
      assert.number(count, "iteration count");
      var clen = CIPHER_LEN[cipher];
      assert.object(clen, "supported cipher");
      salt = salt.slice(0, PKCS5_SALT_LEN);
      var D, D_prev, bufs;
      var material = Buffer2.alloc(0);
      while (material.length < clen.key + clen.iv) {
        bufs = [];
        if (D_prev)
          bufs.push(D_prev);
        bufs.push(passphrase);
        bufs.push(salt);
        D = Buffer2.concat(bufs);
        for (var j = 0; j < count; ++j)
          D = crypto.createHash("md5").update(D).digest();
        material = Buffer2.concat([material, D]);
        D_prev = D;
      }
      return {
        key: material.slice(0, clen.key),
        iv: material.slice(clen.key, clen.key + clen.iv)
      };
    }
    function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
      var hkey = Buffer2.alloc(salt.length + 4);
      salt.copy(hkey);
      var gen = 0, ts = [];
      var i = 1;
      while (gen < size) {
        var t = T(i++);
        gen += t.length;
        ts.push(t);
      }
      return Buffer2.concat(ts).slice(0, size);
      function T(I) {
        hkey.writeUInt32BE(I, hkey.length - 4);
        var hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(hkey);
        var Ti = hmac.digest();
        var Uc = Ti;
        var c = 1;
        while (c++ < iterations) {
          hmac = crypto.createHmac(hashAlg, passphrase);
          hmac.update(Uc);
          Uc = hmac.digest();
          for (var x = 0; x < Ti.length; ++x)
            Ti[x] ^= Uc[x];
        }
        return Ti;
      }
    }
    function countZeros(buf) {
      var o = 0, obit = 8;
      while (o < buf.length) {
        var mask = 1 << obit;
        if ((buf[o] & mask) === mask)
          break;
        obit--;
        if (obit < 0) {
          o++;
          obit = 8;
        }
      }
      return o * 8 + (8 - obit) - 1;
    }
    function bufferSplit(buf, chr) {
      assert.buffer(buf);
      assert.string(chr);
      var parts = [];
      var lastPart = 0;
      var matches = 0;
      for (var i = 0; i < buf.length; ++i) {
        if (buf[i] === chr.charCodeAt(matches))
          ++matches;
        else if (buf[i] === chr.charCodeAt(0))
          matches = 1;
        else
          matches = 0;
        if (matches >= chr.length) {
          var newPart = i + 1;
          parts.push(buf.slice(lastPart, newPart - matches));
          lastPart = newPart;
          matches = 0;
        }
      }
      if (lastPart <= buf.length)
        parts.push(buf.slice(lastPart, buf.length));
      return parts;
    }
    function ecNormalize(buf, addZero) {
      assert.buffer(buf);
      if (buf[0] === 0 && buf[1] === 4) {
        if (addZero)
          return buf;
        return buf.slice(1);
      } else if (buf[0] === 4) {
        if (!addZero)
          return buf;
      } else {
        while (buf[0] === 0)
          buf = buf.slice(1);
        if (buf[0] === 2 || buf[0] === 3)
          throw new Error("Compressed elliptic curve points are not supported");
        if (buf[0] !== 4)
          throw new Error("Not a valid elliptic curve point");
        if (!addZero)
          return buf;
      }
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      return b;
    }
    function readBitString(der, tag) {
      if (tag === void 0)
        tag = asn1.Ber.BitString;
      var buf = der.readString(tag, true);
      assert.strictEqual(buf[0], 0, "bit strings with unused bits are not supported (0x" + buf[0].toString(16) + ")");
      return buf.slice(1);
    }
    function writeBitString(der, buf, tag) {
      if (tag === void 0)
        tag = asn1.Ber.BitString;
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      der.writeBuffer(b, tag);
    }
    function mpNormalize(buf) {
      assert.buffer(buf);
      while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
        buf = buf.slice(1);
      if ((buf[0] & 128) === 128) {
        var b = Buffer2.alloc(buf.length + 1);
        b[0] = 0;
        buf.copy(b, 1);
        buf = b;
      }
      return buf;
    }
    function mpDenormalize(buf) {
      assert.buffer(buf);
      while (buf.length > 1 && buf[0] === 0)
        buf = buf.slice(1);
      return buf;
    }
    function zeroPadToLength(buf, len) {
      assert.buffer(buf);
      assert.number(len);
      while (buf.length > len) {
        assert.equal(buf[0], 0);
        buf = buf.slice(1);
      }
      while (buf.length < len) {
        var b = Buffer2.alloc(buf.length + 1);
        b[0] = 0;
        buf.copy(b, 1);
        buf = b;
      }
      return buf;
    }
    function bigintToMpBuf(bigint) {
      var buf = Buffer2.from(bigint.toByteArray());
      buf = mpNormalize(buf);
      return buf;
    }
    function calculateDSAPublic(g, p, x) {
      assert.buffer(g);
      assert.buffer(p);
      assert.buffer(x);
      g = new jsbn(g);
      p = new jsbn(p);
      x = new jsbn(x);
      var y = g.modPow(x, p);
      var ybuf = bigintToMpBuf(y);
      return ybuf;
    }
    function calculateED25519Public(k) {
      assert.buffer(k);
      var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
      return Buffer2.from(kp.publicKey);
    }
    function calculateX25519Public(k) {
      assert.buffer(k);
      var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
      return Buffer2.from(kp.publicKey);
    }
    function addRSAMissing(key) {
      assert.object(key);
      assertCompatible(key, PrivateKey, [1, 1]);
      var d = new jsbn(key.part.d.data);
      var buf;
      if (!key.part.dmodp) {
        var p = new jsbn(key.part.p.data);
        var dmodp = d.mod(p.subtract(1));
        buf = bigintToMpBuf(dmodp);
        key.part.dmodp = { name: "dmodp", data: buf };
        key.parts.push(key.part.dmodp);
      }
      if (!key.part.dmodq) {
        var q2 = new jsbn(key.part.q.data);
        var dmodq = d.mod(q2.subtract(1));
        buf = bigintToMpBuf(dmodq);
        key.part.dmodq = { name: "dmodq", data: buf };
        key.parts.push(key.part.dmodq);
      }
    }
    function publicFromPrivateECDSA(curveName, priv) {
      assert.string(curveName, "curveName");
      assert.buffer(priv);
      var params = algs.curves[curveName];
      var p = new jsbn(params.p);
      var a = new jsbn(params.a);
      var b = new jsbn(params.b);
      var curve = new ec.ECCurveFp(p, a, b);
      var G = curve.decodePointHex(params.G.toString("hex"));
      var d = new jsbn(mpNormalize(priv));
      var pub = G.multiply(d);
      pub = Buffer2.from(curve.encodePointHex(pub), "hex");
      var parts = [];
      parts.push({ name: "curve", data: Buffer2.from(curveName) });
      parts.push({ name: "Q", data: pub });
      var key = new Key({ type: "ecdsa", curve, parts });
      return key;
    }
    function opensshCipherInfo(cipher) {
      var inf = {};
      switch (cipher) {
        case "3des-cbc":
          inf.keySize = 24;
          inf.blockSize = 8;
          inf.opensslName = "des-ede3-cbc";
          break;
        case "blowfish-cbc":
          inf.keySize = 16;
          inf.blockSize = 8;
          inf.opensslName = "bf-cbc";
          break;
        case "aes128-cbc":
        case "aes128-ctr":
        case "aes128-gcm@openssh.com":
          inf.keySize = 16;
          inf.blockSize = 16;
          inf.opensslName = "aes-128-" + cipher.slice(7, 10);
          break;
        case "aes192-cbc":
        case "aes192-ctr":
        case "aes192-gcm@openssh.com":
          inf.keySize = 24;
          inf.blockSize = 16;
          inf.opensslName = "aes-192-" + cipher.slice(7, 10);
          break;
        case "aes256-cbc":
        case "aes256-ctr":
        case "aes256-gcm@openssh.com":
          inf.keySize = 32;
          inf.blockSize = 16;
          inf.opensslName = "aes-256-" + cipher.slice(7, 10);
          break;
        default:
          throw new Error('Unsupported openssl cipher "' + cipher + '"');
      }
      return inf;
    }
  }
});

// node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS({
  "node_modules/sshpk/lib/ssh-buffer.js"(exports, module) {
    module.exports = SSHBuffer;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    function SSHBuffer(opts) {
      assert.object(opts, "options");
      if (opts.buffer !== void 0)
        assert.buffer(opts.buffer, "options.buffer");
      this._size = opts.buffer ? opts.buffer.length : 1024;
      this._buffer = opts.buffer || Buffer2.alloc(this._size);
      this._offset = 0;
    }
    SSHBuffer.prototype.toBuffer = function() {
      return this._buffer.slice(0, this._offset);
    };
    SSHBuffer.prototype.atEnd = function() {
      return this._offset >= this._buffer.length;
    };
    SSHBuffer.prototype.remainder = function() {
      return this._buffer.slice(this._offset);
    };
    SSHBuffer.prototype.skip = function(n) {
      this._offset += n;
    };
    SSHBuffer.prototype.expand = function() {
      this._size *= 2;
      var buf = Buffer2.alloc(this._size);
      this._buffer.copy(buf, 0);
      this._buffer = buf;
    };
    SSHBuffer.prototype.readPart = function() {
      return { data: this.readBuffer() };
    };
    SSHBuffer.prototype.readBuffer = function() {
      var len = this._buffer.readUInt32BE(this._offset);
      this._offset += 4;
      assert.ok(this._offset + len <= this._buffer.length, "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)");
      var buf = this._buffer.slice(this._offset, this._offset + len);
      this._offset += len;
      return buf;
    };
    SSHBuffer.prototype.readString = function() {
      return this.readBuffer().toString();
    };
    SSHBuffer.prototype.readCString = function() {
      var offset = this._offset;
      while (offset < this._buffer.length && this._buffer[offset] !== 0)
        offset++;
      assert.ok(offset < this._buffer.length, "c string does not terminate");
      var str = this._buffer.slice(this._offset, offset).toString();
      this._offset = offset + 1;
      return str;
    };
    SSHBuffer.prototype.readInt = function() {
      var v = this._buffer.readUInt32BE(this._offset);
      this._offset += 4;
      return v;
    };
    SSHBuffer.prototype.readInt64 = function() {
      assert.ok(this._offset + 8 < this._buffer.length, "buffer not long enough to read Int64");
      var v = this._buffer.slice(this._offset, this._offset + 8);
      this._offset += 8;
      return v;
    };
    SSHBuffer.prototype.readChar = function() {
      var v = this._buffer[this._offset++];
      return v;
    };
    SSHBuffer.prototype.writeBuffer = function(buf) {
      while (this._offset + 4 + buf.length > this._size)
        this.expand();
      this._buffer.writeUInt32BE(buf.length, this._offset);
      this._offset += 4;
      buf.copy(this._buffer, this._offset);
      this._offset += buf.length;
    };
    SSHBuffer.prototype.writeString = function(str) {
      this.writeBuffer(Buffer2.from(str, "utf8"));
    };
    SSHBuffer.prototype.writeCString = function(str) {
      while (this._offset + 1 + str.length > this._size)
        this.expand();
      this._buffer.write(str, this._offset);
      this._offset += str.length;
      this._buffer[this._offset++] = 0;
    };
    SSHBuffer.prototype.writeInt = function(v) {
      while (this._offset + 4 > this._size)
        this.expand();
      this._buffer.writeUInt32BE(v, this._offset);
      this._offset += 4;
    };
    SSHBuffer.prototype.writeInt64 = function(v) {
      assert.buffer(v, "value");
      if (v.length > 8) {
        var lead = v.slice(0, v.length - 8);
        for (var i = 0; i < lead.length; ++i) {
          assert.strictEqual(lead[i], 0, "must fit in 64 bits of precision");
        }
        v = v.slice(v.length - 8, v.length);
      }
      while (this._offset + 8 > this._size)
        this.expand();
      v.copy(this._buffer, this._offset);
      this._offset += 8;
    };
    SSHBuffer.prototype.writeChar = function(v) {
      while (this._offset + 1 > this._size)
        this.expand();
      this._buffer[this._offset++] = v;
    };
    SSHBuffer.prototype.writePart = function(p) {
      this.writeBuffer(p.data);
    };
    SSHBuffer.prototype.write = function(buf) {
      while (this._offset + buf.length > this._size)
        this.expand();
      buf.copy(this._buffer, this._offset);
      this._offset += buf.length;
    };
  }
});

// node_modules/sshpk/lib/signature.js
var require_signature = __commonJS({
  "node_modules/sshpk/lib/signature.js"(exports, module) {
    module.exports = Signature;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var errs = require_errors();
    var utils = require_utils();
    var asn1 = require_lib2();
    var SSHBuffer = require_ssh_buffer();
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var SignatureParseError = errs.SignatureParseError;
    function Signature(opts) {
      assert.object(opts, "options");
      assert.arrayOfObject(opts.parts, "options.parts");
      assert.string(opts.type, "options.type");
      var partLookup = {};
      for (var i = 0; i < opts.parts.length; ++i) {
        var part = opts.parts[i];
        partLookup[part.name] = part;
      }
      this.type = opts.type;
      this.hashAlgorithm = opts.hashAlgo;
      this.curve = opts.curve;
      this.parts = opts.parts;
      this.part = partLookup;
    }
    Signature.prototype.toBuffer = function(format) {
      if (format === void 0)
        format = "asn1";
      assert.string(format, "format");
      var buf;
      var stype = "ssh-" + this.type;
      switch (this.type) {
        case "rsa":
          switch (this.hashAlgorithm) {
            case "sha256":
              stype = "rsa-sha2-256";
              break;
            case "sha512":
              stype = "rsa-sha2-512";
              break;
            case "sha1":
            case void 0:
              break;
            default:
              throw new Error("SSH signature format does not support hash algorithm " + this.hashAlgorithm);
          }
          if (format === "ssh") {
            buf = new SSHBuffer({});
            buf.writeString(stype);
            buf.writePart(this.part.sig);
            return buf.toBuffer();
          } else {
            return this.part.sig.data;
          }
          break;
        case "ed25519":
          if (format === "ssh") {
            buf = new SSHBuffer({});
            buf.writeString(stype);
            buf.writePart(this.part.sig);
            return buf.toBuffer();
          } else {
            return this.part.sig.data;
          }
          break;
        case "dsa":
        case "ecdsa":
          var r, s;
          if (format === "asn1") {
            var der = new asn1.BerWriter();
            der.startSequence();
            r = utils.mpNormalize(this.part.r.data);
            s = utils.mpNormalize(this.part.s.data);
            der.writeBuffer(r, asn1.Ber.Integer);
            der.writeBuffer(s, asn1.Ber.Integer);
            der.endSequence();
            return der.buffer;
          } else if (format === "ssh" && this.type === "dsa") {
            buf = new SSHBuffer({});
            buf.writeString("ssh-dss");
            r = this.part.r.data;
            if (r.length > 20 && r[0] === 0)
              r = r.slice(1);
            s = this.part.s.data;
            if (s.length > 20 && s[0] === 0)
              s = s.slice(1);
            if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
              throw new Error("OpenSSH only supports DSA signatures with SHA1 hash");
            }
            buf.writeBuffer(Buffer2.concat([r, s]));
            return buf.toBuffer();
          } else if (format === "ssh" && this.type === "ecdsa") {
            var inner = new SSHBuffer({});
            r = this.part.r.data;
            inner.writeBuffer(r);
            inner.writePart(this.part.s);
            buf = new SSHBuffer({});
            var curve;
            if (r[0] === 0)
              r = r.slice(1);
            var sz = r.length * 8;
            if (sz === 256)
              curve = "nistp256";
            else if (sz === 384)
              curve = "nistp384";
            else if (sz === 528)
              curve = "nistp521";
            buf.writeString("ecdsa-sha2-" + curve);
            buf.writeBuffer(inner.toBuffer());
            return buf.toBuffer();
          }
          throw new Error("Invalid signature format");
        default:
          throw new Error("Invalid signature data");
      }
    };
    Signature.prototype.toString = function(format) {
      assert.optionalString(format, "format");
      return this.toBuffer(format).toString("base64");
    };
    Signature.parse = function(data, type, format) {
      if (typeof data === "string")
        data = Buffer2.from(data, "base64");
      assert.buffer(data, "data");
      assert.string(format, "format");
      assert.string(type, "type");
      var opts = {};
      opts.type = type.toLowerCase();
      opts.parts = [];
      try {
        assert.ok(data.length > 0, "signature must not be empty");
        switch (opts.type) {
          case "rsa":
            return parseOneNum(data, type, format, opts);
          case "ed25519":
            return parseOneNum(data, type, format, opts);
          case "dsa":
          case "ecdsa":
            if (format === "asn1")
              return parseDSAasn1(data, type, format, opts);
            else if (opts.type === "dsa")
              return parseDSA(data, type, format, opts);
            else
              return parseECDSA(data, type, format, opts);
          default:
            throw new InvalidAlgorithmError(type);
        }
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw e;
        throw new SignatureParseError(type, format, e);
      }
    };
    function parseOneNum(data, type, format, opts) {
      if (format === "ssh") {
        try {
          var buf = new SSHBuffer({ buffer: data });
          var head = buf.readString();
        } catch (e) {
        }
        if (buf !== void 0) {
          var msg = "SSH signature does not match expected type (expected " + type + ", got " + head + ")";
          switch (head) {
            case "ssh-rsa":
              assert.strictEqual(type, "rsa", msg);
              opts.hashAlgo = "sha1";
              break;
            case "rsa-sha2-256":
              assert.strictEqual(type, "rsa", msg);
              opts.hashAlgo = "sha256";
              break;
            case "rsa-sha2-512":
              assert.strictEqual(type, "rsa", msg);
              opts.hashAlgo = "sha512";
              break;
            case "ssh-ed25519":
              assert.strictEqual(type, "ed25519", msg);
              opts.hashAlgo = "sha512";
              break;
            default:
              throw new Error("Unknown SSH signature type: " + head);
          }
          var sig = buf.readPart();
          assert.ok(buf.atEnd(), "extra trailing bytes");
          sig.name = "sig";
          opts.parts.push(sig);
          return new Signature(opts);
        }
      }
      opts.parts.push({ name: "sig", data });
      return new Signature(opts);
    }
    function parseDSAasn1(data, type, format, opts) {
      var der = new asn1.BerReader(data);
      der.readSequence();
      var r = der.readString(asn1.Ber.Integer, true);
      var s = der.readString(asn1.Ber.Integer, true);
      opts.parts.push({ name: "r", data: utils.mpNormalize(r) });
      opts.parts.push({ name: "s", data: utils.mpNormalize(s) });
      return new Signature(opts);
    }
    function parseDSA(data, type, format, opts) {
      if (data.length != 40) {
        var buf = new SSHBuffer({ buffer: data });
        var d = buf.readBuffer();
        if (d.toString("ascii") === "ssh-dss")
          d = buf.readBuffer();
        assert.ok(buf.atEnd(), "extra trailing bytes");
        assert.strictEqual(d.length, 40, "invalid inner length");
        data = d;
      }
      opts.parts.push({ name: "r", data: data.slice(0, 20) });
      opts.parts.push({ name: "s", data: data.slice(20, 40) });
      return new Signature(opts);
    }
    function parseECDSA(data, type, format, opts) {
      var buf = new SSHBuffer({ buffer: data });
      var r, s;
      var inner = buf.readBuffer();
      var stype = inner.toString("ascii");
      if (stype.slice(0, 6) === "ecdsa-") {
        var parts = stype.split("-");
        assert.strictEqual(parts[0], "ecdsa");
        assert.strictEqual(parts[1], "sha2");
        opts.curve = parts[2];
        switch (opts.curve) {
          case "nistp256":
            opts.hashAlgo = "sha256";
            break;
          case "nistp384":
            opts.hashAlgo = "sha384";
            break;
          case "nistp521":
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unsupported ECDSA curve: " + opts.curve);
        }
        inner = buf.readBuffer();
        assert.ok(buf.atEnd(), "extra trailing bytes on outer");
        buf = new SSHBuffer({ buffer: inner });
        r = buf.readPart();
      } else {
        r = { data: inner };
      }
      s = buf.readPart();
      assert.ok(buf.atEnd(), "extra trailing bytes");
      r.name = "r";
      s.name = "s";
      opts.parts.push(r);
      opts.parts.push(s);
      return new Signature(opts);
    }
    Signature.isSignature = function(obj, ver) {
      return utils.isCompatible(obj, Signature, ver);
    };
    Signature.prototype._sshpkApiVersion = [2, 1];
    Signature._oldVersionDetect = function(obj) {
      assert.func(obj.toBuffer);
      if (obj.hasOwnProperty("hashAlgorithm"))
        return [2, 0];
      return [1, 0];
    };
  }
});

// node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS({
  "node_modules/ecc-jsbn/lib/sec.js"(exports, module) {
    var BigInteger = require_jsbn().BigInteger;
    var ECCurveFp = require_ec().ECCurveFp;
    function X9ECParameters(curve, g, n, h) {
      this.curve = curve;
      this.g = g;
      this.n = n;
      this.h = h;
    }
    function x9getCurve() {
      return this.curve;
    }
    function x9getG() {
      return this.g;
    }
    function x9getN() {
      return this.n;
    }
    function x9getH() {
      return this.h;
    }
    X9ECParameters.prototype.getCurve = x9getCurve;
    X9ECParameters.prototype.getG = x9getG;
    X9ECParameters.prototype.getN = x9getN;
    X9ECParameters.prototype.getH = x9getH;
    function fromHex(s) {
      return new BigInteger(s, 16);
    }
    function secp128r1() {
      var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
      var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
      var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp160k1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
      var a = BigInteger.ZERO;
      var b = fromHex("7");
      var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp160r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
      var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
      var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp192k1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
      var a = BigInteger.ZERO;
      var b = fromHex("3");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp192r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
      var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp224r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
      var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp256r1() {
      var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
      var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
      var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
      return new X9ECParameters(curve, G, n, h);
    }
    module.exports = {
      "secp128r1": secp128r1,
      "secp160k1": secp160k1,
      "secp160r1": secp160r1,
      "secp192k1": secp192k1,
      "secp192r1": secp192r1,
      "secp224r1": secp224r1,
      "secp256r1": secp256r1
    };
  }
});

// node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS({
  "node_modules/ecc-jsbn/index.js"(exports) {
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var BigInteger = require_jsbn().BigInteger;
    var ECPointFp = require_ec().ECPointFp;
    var Buffer2 = require_safer().Buffer;
    exports.ECCurves = require_sec();
    function unstupid(hex, len) {
      return hex.length >= len ? hex : unstupid("0" + hex, len);
    }
    exports.ECKey = function(curve, key, isPublic) {
      var priv;
      var c = curve();
      var n = c.getN();
      var bytes = Math.floor(n.bitLength() / 8);
      if (key) {
        if (isPublic) {
          var curve = c.getCurve();
          this.P = curve.decodePointHex(key.toString("hex"));
        } else {
          if (key.length != bytes)
            return false;
          priv = new BigInteger(key.toString("hex"), 16);
        }
      } else {
        var n1 = n.subtract(BigInteger.ONE);
        var r = new BigInteger(crypto.randomBytes(n.bitLength()));
        priv = r.mod(n1).add(BigInteger.ONE);
        this.P = c.getG().multiply(priv);
      }
      if (this.P) {
        this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
      }
      if (priv) {
        this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
        this.deriveSharedSecret = function(key2) {
          if (!key2 || !key2.P)
            return false;
          var S = key2.P.multiply(priv);
          return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
        };
      }
    };
  }
});

// node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS({
  "node_modules/sshpk/lib/dhe.js"(exports, module) {
    module.exports = {
      DiffieHellman,
      generateECDSA,
      generateED25519
    };
    var assert = require_assert();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var nacl = require_nacl_fast();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var CRYPTO_HAVE_ECDH = crypto.createECDH !== void 0;
    var ecdh = require_ecc_jsbn();
    var ec = require_ec();
    var jsbn = require_jsbn().BigInteger;
    function DiffieHellman(key) {
      utils.assertCompatible(key, Key, [1, 4], "key");
      this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
      this._algo = key.type;
      this._curve = key.curve;
      this._key = key;
      if (key.type === "dsa") {
        if (!CRYPTO_HAVE_ECDH) {
          throw new Error("Due to bugs in the node 0.10 crypto API, node 0.12.x or later is required to use DH");
        }
        this._dh = crypto.createDiffieHellman(key.part.p.data, void 0, key.part.g.data, void 0);
        this._p = key.part.p;
        this._g = key.part.g;
        if (this._isPriv)
          this._dh.setPrivateKey(key.part.x.data);
        this._dh.setPublicKey(key.part.y.data);
      } else if (key.type === "ecdsa") {
        if (!CRYPTO_HAVE_ECDH) {
          this._ecParams = new X9ECParameters(this._curve);
          if (this._isPriv) {
            this._priv = new ECPrivate(this._ecParams, key.part.d.data);
          }
          return;
        }
        var curve = {
          "nistp256": "prime256v1",
          "nistp384": "secp384r1",
          "nistp521": "secp521r1"
        }[key.curve];
        this._dh = crypto.createECDH(curve);
        if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
          CRYPTO_HAVE_ECDH = false;
          DiffieHellman.call(this, key);
          return;
        }
        if (this._isPriv)
          this._dh.setPrivateKey(key.part.d.data);
        this._dh.setPublicKey(key.part.Q.data);
      } else if (key.type === "curve25519") {
        if (this._isPriv) {
          utils.assertCompatible(key, PrivateKey, [1, 5], "key");
          this._priv = key.part.k.data;
        }
      } else {
        throw new Error("DH not supported for " + key.type + " keys");
      }
    }
    DiffieHellman.prototype.getPublicKey = function() {
      if (this._isPriv)
        return this._key.toPublic();
      return this._key;
    };
    DiffieHellman.prototype.getPrivateKey = function() {
      if (this._isPriv)
        return this._key;
      else
        return void 0;
    };
    DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
    DiffieHellman.prototype._keyCheck = function(pk, isPub) {
      assert.object(pk, "key");
      if (!isPub)
        utils.assertCompatible(pk, PrivateKey, [1, 3], "key");
      utils.assertCompatible(pk, Key, [1, 4], "key");
      if (pk.type !== this._algo) {
        throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
      }
      if (pk.curve !== this._curve) {
        throw new Error("A key from the " + pk.curve + " curve cannot be used with a " + this._curve + " Diffie-Hellman");
      }
      if (pk.type === "dsa") {
        assert.deepEqual(pk.part.p, this._p, "DSA key prime does not match");
        assert.deepEqual(pk.part.g, this._g, "DSA key generator does not match");
      }
    };
    DiffieHellman.prototype.setKey = function(pk) {
      this._keyCheck(pk);
      if (pk.type === "dsa") {
        this._dh.setPrivateKey(pk.part.x.data);
        this._dh.setPublicKey(pk.part.y.data);
      } else if (pk.type === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          this._dh.setPrivateKey(pk.part.d.data);
          this._dh.setPublicKey(pk.part.Q.data);
        } else {
          this._priv = new ECPrivate(this._ecParams, pk.part.d.data);
        }
      } else if (pk.type === "curve25519") {
        var k = pk.part.k;
        if (!pk.part.k)
          k = pk.part.r;
        this._priv = k.data;
        if (this._priv[0] === 0)
          this._priv = this._priv.slice(1);
        this._priv = this._priv.slice(0, 32);
      }
      this._key = pk;
      this._isPriv = true;
    };
    DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
    DiffieHellman.prototype.computeSecret = function(otherpk) {
      this._keyCheck(otherpk, true);
      if (!this._isPriv)
        throw new Error("DH exchange has not been initialized with a private key yet");
      var pub;
      if (this._algo === "dsa") {
        return this._dh.computeSecret(otherpk.part.y.data);
      } else if (this._algo === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          return this._dh.computeSecret(otherpk.part.Q.data);
        } else {
          pub = new ECPublic(this._ecParams, otherpk.part.Q.data);
          return this._priv.deriveSharedSecret(pub);
        }
      } else if (this._algo === "curve25519") {
        pub = otherpk.part.A.data;
        while (pub[0] === 0 && pub.length > 32)
          pub = pub.slice(1);
        var priv = this._priv;
        assert.strictEqual(pub.length, 32);
        assert.strictEqual(priv.length, 32);
        var secret = nacl.box.before(new Uint8Array(pub), new Uint8Array(priv));
        return Buffer2.from(secret);
      }
      throw new Error("Invalid algorithm: " + this._algo);
    };
    DiffieHellman.prototype.generateKey = function() {
      var parts = [];
      var priv, pub;
      if (this._algo === "dsa") {
        this._dh.generateKeys();
        parts.push({ name: "p", data: this._p.data });
        parts.push({ name: "q", data: this._key.part.q.data });
        parts.push({ name: "g", data: this._g.data });
        parts.push({ name: "y", data: this._dh.getPublicKey() });
        parts.push({ name: "x", data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: "dsa",
          parts
        });
        this._isPriv = true;
        return this._key;
      } else if (this._algo === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          this._dh.generateKeys();
          parts.push({
            name: "curve",
            data: Buffer2.from(this._curve)
          });
          parts.push({ name: "Q", data: this._dh.getPublicKey() });
          parts.push({ name: "d", data: this._dh.getPrivateKey() });
          this._key = new PrivateKey({
            type: "ecdsa",
            curve: this._curve,
            parts
          });
          this._isPriv = true;
          return this._key;
        } else {
          var n = this._ecParams.getN();
          var r = new jsbn(crypto.randomBytes(n.bitLength()));
          var n1 = n.subtract(jsbn.ONE);
          priv = r.mod(n1).add(jsbn.ONE);
          pub = this._ecParams.getG().multiply(priv);
          priv = Buffer2.from(priv.toByteArray());
          pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
          this._priv = new ECPrivate(this._ecParams, priv);
          parts.push({
            name: "curve",
            data: Buffer2.from(this._curve)
          });
          parts.push({ name: "Q", data: pub });
          parts.push({ name: "d", data: priv });
          this._key = new PrivateKey({
            type: "ecdsa",
            curve: this._curve,
            parts
          });
          this._isPriv = true;
          return this._key;
        }
      } else if (this._algo === "curve25519") {
        var pair = nacl.box.keyPair();
        priv = Buffer2.from(pair.secretKey);
        pub = Buffer2.from(pair.publicKey);
        priv = Buffer2.concat([priv, pub]);
        assert.strictEqual(priv.length, 64);
        assert.strictEqual(pub.length, 32);
        parts.push({ name: "A", data: pub });
        parts.push({ name: "k", data: priv });
        this._key = new PrivateKey({
          type: "curve25519",
          parts
        });
        this._isPriv = true;
        return this._key;
      }
      throw new Error("Invalid algorithm: " + this._algo);
    };
    DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
    function X9ECParameters(name) {
      var params = algs.curves[name];
      assert.object(params);
      var p = new jsbn(params.p);
      var a = new jsbn(params.a);
      var b = new jsbn(params.b);
      var n = new jsbn(params.n);
      var h = jsbn.ONE;
      var curve = new ec.ECCurveFp(p, a, b);
      var G = curve.decodePointHex(params.G.toString("hex"));
      this.curve = curve;
      this.g = G;
      this.n = n;
      this.h = h;
    }
    X9ECParameters.prototype.getCurve = function() {
      return this.curve;
    };
    X9ECParameters.prototype.getG = function() {
      return this.g;
    };
    X9ECParameters.prototype.getN = function() {
      return this.n;
    };
    X9ECParameters.prototype.getH = function() {
      return this.h;
    };
    function ECPublic(params, buffer) {
      this._params = params;
      if (buffer[0] === 0)
        buffer = buffer.slice(1);
      this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
    }
    function ECPrivate(params, buffer) {
      this._params = params;
      this._priv = new jsbn(utils.mpNormalize(buffer));
    }
    ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
      assert.ok(pubKey instanceof ECPublic);
      var S = pubKey._pub.multiply(this._priv);
      return Buffer2.from(S.getX().toBigInteger().toByteArray());
    };
    function generateED25519() {
      var pair = nacl.sign.keyPair();
      var priv = Buffer2.from(pair.secretKey);
      var pub = Buffer2.from(pair.publicKey);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      var parts = [];
      parts.push({ name: "A", data: pub });
      parts.push({ name: "k", data: priv.slice(0, 32) });
      var key = new PrivateKey({
        type: "ed25519",
        parts
      });
      return key;
    }
    function generateECDSA(curve) {
      var parts = [];
      var key;
      if (CRYPTO_HAVE_ECDH) {
        var osCurve = {
          "nistp256": "prime256v1",
          "nistp384": "secp384r1",
          "nistp521": "secp521r1"
        }[curve];
        var dh = crypto.createECDH(osCurve);
        dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(curve)
        });
        parts.push({ name: "Q", data: dh.getPublicKey() });
        parts.push({ name: "d", data: dh.getPrivateKey() });
        key = new PrivateKey({
          type: "ecdsa",
          curve,
          parts
        });
        return key;
      } else {
        var ecParams = new X9ECParameters(curve);
        var n = ecParams.getN();
        var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
        var c = new jsbn(crypto.randomBytes(cByteLen));
        var n1 = n.subtract(jsbn.ONE);
        var priv = c.mod(n1).add(jsbn.ONE);
        var pub = ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
        parts.push({ name: "curve", data: Buffer2.from(curve) });
        parts.push({ name: "Q", data: pub });
        parts.push({ name: "d", data: priv });
        key = new PrivateKey({
          type: "ecdsa",
          curve,
          parts
        });
        return key;
      }
    }
  }
});

// node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS({
  "node_modules/sshpk/lib/ed-compat.js"(exports, module) {
    module.exports = {
      Verifier,
      Signer
    };
    var nacl = require_nacl_fast();
    var stream = (init_stream(), __toCommonJS(stream_exports));
    var util = (init_util(), __toCommonJS(util_exports));
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var Signature = require_signature();
    function Verifier(key, hashAlgo) {
      if (hashAlgo.toLowerCase() !== "sha512")
        throw new Error("ED25519 only supports the use of SHA-512 hashes");
      this.key = key;
      this.chunks = [];
      stream.Writable.call(this, {});
    }
    util.inherits(Verifier, stream.Writable);
    Verifier.prototype._write = function(chunk, enc, cb) {
      this.chunks.push(chunk);
      cb();
    };
    Verifier.prototype.update = function(chunk) {
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, "binary");
      this.chunks.push(chunk);
    };
    Verifier.prototype.verify = function(signature, fmt) {
      var sig;
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== "ed25519")
          return false;
        sig = signature.toBuffer("raw");
      } else if (typeof signature === "string") {
        sig = Buffer2.from(signature, "base64");
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error("signature was created by too old a version of sshpk and cannot be verified");
      }
      assert.buffer(sig);
      return nacl.sign.detached.verify(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(sig), new Uint8Array(this.key.part.A.data));
    };
    function Signer(key, hashAlgo) {
      if (hashAlgo.toLowerCase() !== "sha512")
        throw new Error("ED25519 only supports the use of SHA-512 hashes");
      this.key = key;
      this.chunks = [];
      stream.Writable.call(this, {});
    }
    util.inherits(Signer, stream.Writable);
    Signer.prototype._write = function(chunk, enc, cb) {
      this.chunks.push(chunk);
      cb();
    };
    Signer.prototype.update = function(chunk) {
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, "binary");
      this.chunks.push(chunk);
    };
    Signer.prototype.sign = function() {
      var sig = nacl.sign.detached(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(Buffer2.concat([
        this.key.part.k.data,
        this.key.part.A.data
      ])));
      var sigBuf = Buffer2.from(sig);
      var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
      sigObj.hashAlgorithm = "sha512";
      return sigObj;
    };
  }
});

// node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS({
  "node_modules/sshpk/lib/formats/pkcs8.js"(exports, module) {
    module.exports = {
      read,
      readPkcs8,
      write,
      writePkcs8,
      pkcs8ToBuffer,
      readECDSACurve,
      writeECDSACurve
    };
    var assert = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    function read(buf, options) {
      return pem.read(buf, options, "pkcs8");
    }
    function write(key, options) {
      return pem.write(key, options, "pkcs8");
    }
    function readMPInt(der, nm) {
      assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function readPkcs8(alg, type, der) {
      if (der.peek() === asn1.Ber.Integer) {
        assert.strictEqual(type, "private", "unexpected Integer at start of public key");
        der.readString(asn1.Ber.Integer, true);
      }
      der.readSequence();
      var next = der.offset + der.length;
      var oid = der.readOID();
      switch (oid) {
        case "1.2.840.113549.1.1.1":
          der._offset = next;
          if (type === "public")
            return readPkcs8RSAPublic(der);
          else
            return readPkcs8RSAPrivate(der);
        case "1.2.840.10040.4.1":
          if (type === "public")
            return readPkcs8DSAPublic(der);
          else
            return readPkcs8DSAPrivate(der);
        case "1.2.840.10045.2.1":
          if (type === "public")
            return readPkcs8ECDSAPublic(der);
          else
            return readPkcs8ECDSAPrivate(der);
        case "1.3.101.112":
          if (type === "public") {
            return readPkcs8EdDSAPublic(der);
          } else {
            return readPkcs8EdDSAPrivate(der);
          }
        case "1.3.101.110":
          if (type === "public") {
            return readPkcs8X25519Public(der);
          } else {
            return readPkcs8X25519Private(der);
          }
        default:
          throw new Error("Unknown key type OID " + oid);
      }
    }
    function readPkcs8RSAPublic(der) {
      der.readSequence(asn1.Ber.BitString);
      der.readByte();
      der.readSequence();
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "exponent");
      var key = {
        type: "rsa",
        source: der.originalInput,
        parts: [
          { name: "e", data: e },
          { name: "n", data: n }
        ]
      };
      return new Key(key);
    }
    function readPkcs8RSAPrivate(der) {
      der.readSequence(asn1.Ber.OctetString);
      der.readSequence();
      var ver = readMPInt(der, "version");
      assert.equal(ver[0], 0, "unknown RSA private key version");
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "public exponent");
      var d = readMPInt(der, "private exponent");
      var p = readMPInt(der, "prime1");
      var q2 = readMPInt(der, "prime2");
      var dmodp = readMPInt(der, "exponent1");
      var dmodq = readMPInt(der, "exponent2");
      var iqmp = readMPInt(der, "iqmp");
      var key = {
        type: "rsa",
        parts: [
          { name: "n", data: n },
          { name: "e", data: e },
          { name: "d", data: d },
          { name: "iqmp", data: iqmp },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "dmodp", data: dmodp },
          { name: "dmodq", data: dmodq }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8DSAPublic(der) {
      der.readSequence();
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      der.readSequence(asn1.Ber.BitString);
      der.readByte();
      var y = readMPInt(der, "y");
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y }
        ]
      };
      return new Key(key);
    }
    function readPkcs8DSAPrivate(der) {
      der.readSequence();
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      der.readSequence(asn1.Ber.OctetString);
      var x = readMPInt(der, "x");
      var y = utils.calculateDSAPublic(g, p, x);
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y },
          { name: "x", data: x }
        ]
      };
      return new PrivateKey(key);
    }
    function readECDSACurve(der) {
      var curveName, curveNames;
      var j, c, cd;
      if (der.peek() === asn1.Ber.OID) {
        var oid = der.readOID();
        curveNames = Object.keys(algs.curves);
        for (j = 0; j < curveNames.length; ++j) {
          c = curveNames[j];
          cd = algs.curves[c];
          if (cd.pkcs8oid === oid) {
            curveName = c;
            break;
          }
        }
      } else {
        der.readSequence();
        var version = der.readString(asn1.Ber.Integer, true);
        assert.strictEqual(version[0], 1, "ECDSA key not version 1");
        var curve = {};
        der.readSequence();
        var fieldTypeOid = der.readOID();
        assert.strictEqual(fieldTypeOid, "1.2.840.10045.1.1", "ECDSA key is not from a prime-field");
        var p = curve.p = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
        curve.size = p.length * 8 - utils.countZeros(p);
        der.readSequence();
        curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
        curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
        if (der.peek() === asn1.Ber.BitString)
          curve.s = der.readString(asn1.Ber.BitString, true);
        curve.G = der.readString(asn1.Ber.OctetString, true);
        assert.strictEqual(curve.G[0], 4, "uncompressed G is required");
        curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
        curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
        assert.strictEqual(curve.h[0], 1, "a cofactor=1 curve is required");
        curveNames = Object.keys(algs.curves);
        var ks = Object.keys(curve);
        for (j = 0; j < curveNames.length; ++j) {
          c = curveNames[j];
          cd = algs.curves[c];
          var equal = true;
          for (var i = 0; i < ks.length; ++i) {
            var k = ks[i];
            if (cd[k] === void 0)
              continue;
            if (typeof cd[k] === "object" && cd[k].equals !== void 0) {
              if (!cd[k].equals(curve[k])) {
                equal = false;
                break;
              }
            } else if (Buffer2.isBuffer(cd[k])) {
              if (cd[k].toString("binary") !== curve[k].toString("binary")) {
                equal = false;
                break;
              }
            } else {
              if (cd[k] !== curve[k]) {
                equal = false;
                break;
              }
            }
          }
          if (equal) {
            curveName = c;
            break;
          }
        }
      }
      return curveName;
    }
    function readPkcs8ECDSAPrivate(der) {
      var curveName = readECDSACurve(der);
      assert.string(curveName, "a known elliptic curve");
      der.readSequence(asn1.Ber.OctetString);
      der.readSequence();
      var version = readMPInt(der, "version");
      assert.equal(version[0], 1, "unknown version of ECDSA key");
      var d = der.readString(asn1.Ber.OctetString, true);
      var Q;
      if (der.peek() == 160) {
        der.readSequence(160);
        der._offset += der.length;
      }
      if (der.peek() == 161) {
        der.readSequence(161);
        Q = der.readString(asn1.Ber.BitString, true);
        Q = utils.ecNormalize(Q);
      }
      if (Q === void 0) {
        var pub = utils.publicFromPrivateECDSA(curveName, d);
        Q = pub.part.Q.data;
      }
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curveName) },
          { name: "Q", data: Q },
          { name: "d", data: d }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8ECDSAPublic(der) {
      var curveName = readECDSACurve(der);
      assert.string(curveName, "a known elliptic curve");
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curveName) },
          { name: "Q", data: Q }
        ]
      };
      return new Key(key);
    }
    function readPkcs8EdDSAPublic(der) {
      if (der.peek() === 0)
        der.readByte();
      var A = utils.readBitString(der);
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) }
        ]
      };
      return new Key(key);
    }
    function readPkcs8X25519Public(der) {
      var A = utils.readBitString(der);
      var key = {
        type: "curve25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) }
        ]
      };
      return new Key(key);
    }
    function readPkcs8EdDSAPrivate(der) {
      if (der.peek() === 0)
        der.readByte();
      der.readSequence(asn1.Ber.OctetString);
      var k = der.readString(asn1.Ber.OctetString, true);
      k = utils.zeroPadToLength(k, 32);
      var A;
      if (der.peek() === asn1.Ber.BitString) {
        A = utils.readBitString(der);
        A = utils.zeroPadToLength(A, 32);
      } else {
        A = utils.calculateED25519Public(k);
      }
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: utils.zeroPadToLength(k, 32) }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8X25519Private(der) {
      if (der.peek() === 0)
        der.readByte();
      der.readSequence(asn1.Ber.OctetString);
      var k = der.readString(asn1.Ber.OctetString, true);
      k = utils.zeroPadToLength(k, 32);
      var A = utils.calculateX25519Public(k);
      var key = {
        type: "curve25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: utils.zeroPadToLength(k, 32) }
        ]
      };
      return new PrivateKey(key);
    }
    function pkcs8ToBuffer(key) {
      var der = new asn1.BerWriter();
      writePkcs8(der, key);
      return der.buffer;
    }
    function writePkcs8(der, key) {
      der.startSequence();
      if (PrivateKey.isPrivateKey(key)) {
        var sillyInt = Buffer2.from([0]);
        der.writeBuffer(sillyInt, asn1.Ber.Integer);
      }
      der.startSequence();
      switch (key.type) {
        case "rsa":
          der.writeOID("1.2.840.113549.1.1.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8RSAPrivate(key, der);
          else
            writePkcs8RSAPublic(key, der);
          break;
        case "dsa":
          der.writeOID("1.2.840.10040.4.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8DSAPrivate(key, der);
          else
            writePkcs8DSAPublic(key, der);
          break;
        case "ecdsa":
          der.writeOID("1.2.840.10045.2.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8ECDSAPrivate(key, der);
          else
            writePkcs8ECDSAPublic(key, der);
          break;
        case "ed25519":
          der.writeOID("1.3.101.112");
          if (PrivateKey.isPrivateKey(key))
            throw new Error("Ed25519 private keys in pkcs8 format are not supported");
          writePkcs8EdDSAPublic(key, der);
          break;
        default:
          throw new Error("Unsupported key type: " + key.type);
      }
      der.endSequence();
    }
    function writePkcs8RSAPrivate(key, der) {
      der.writeNull();
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.startSequence();
      var version = Buffer2.from([0]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      if (!key.part.dmodp || !key.part.dmodq)
        utils.addRSAMissing(key);
      der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8RSAPublic(key, der) {
      der.writeNull();
      der.endSequence();
      der.startSequence(asn1.Ber.BitString);
      der.writeByte(0);
      der.startSequence();
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8DSAPrivate(key, der) {
      der.startSequence();
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
      der.endSequence();
    }
    function writePkcs8DSAPublic(key, der) {
      der.startSequence();
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
      der.startSequence(asn1.Ber.BitString);
      der.writeByte(0);
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.endSequence();
    }
    function writeECDSACurve(key, der) {
      var curve = algs.curves[key.curve];
      if (curve.pkcs8oid) {
        der.writeOID(curve.pkcs8oid);
      } else {
        der.startSequence();
        var version = Buffer2.from([1]);
        der.writeBuffer(version, asn1.Ber.Integer);
        der.startSequence();
        der.writeOID("1.2.840.10045.1.1");
        der.writeBuffer(curve.p, asn1.Ber.Integer);
        der.endSequence();
        der.startSequence();
        var a = curve.p;
        if (a[0] === 0)
          a = a.slice(1);
        der.writeBuffer(a, asn1.Ber.OctetString);
        der.writeBuffer(curve.b, asn1.Ber.OctetString);
        der.writeBuffer(curve.s, asn1.Ber.BitString);
        der.endSequence();
        der.writeBuffer(curve.G, asn1.Ber.OctetString);
        der.writeBuffer(curve.n, asn1.Ber.Integer);
        var h = curve.h;
        if (!h) {
          h = Buffer2.from([1]);
        }
        der.writeBuffer(h, asn1.Ber.Integer);
        der.endSequence();
      }
    }
    function writePkcs8ECDSAPublic(key, der) {
      writeECDSACurve(key, der);
      der.endSequence();
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
    }
    function writePkcs8ECDSAPrivate(key, der) {
      writeECDSACurve(key, der);
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
      der.startSequence(161);
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
      der.endSequence();
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8EdDSAPublic(key, der) {
      der.endSequence();
      utils.writeBitString(der, key.part.A.data);
    }
  }
});

// node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/sshpk/lib/formats/pkcs1.js"(exports, module) {
    module.exports = {
      read,
      readPkcs1,
      write,
      writePkcs1
    };
    var assert = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var pkcs8 = require_pkcs8();
    var readECDSACurve = pkcs8.readECDSACurve;
    function read(buf, options) {
      return pem.read(buf, options, "pkcs1");
    }
    function write(key, options) {
      return pem.write(key, options, "pkcs1");
    }
    function readMPInt(der, nm) {
      assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function readPkcs1(alg, type, der) {
      switch (alg) {
        case "RSA":
          if (type === "public")
            return readPkcs1RSAPublic(der);
          else if (type === "private")
            return readPkcs1RSAPrivate(der);
          throw new Error("Unknown key type: " + type);
        case "DSA":
          if (type === "public")
            return readPkcs1DSAPublic(der);
          else if (type === "private")
            return readPkcs1DSAPrivate(der);
          throw new Error("Unknown key type: " + type);
        case "EC":
        case "ECDSA":
          if (type === "private")
            return readPkcs1ECDSAPrivate(der);
          else if (type === "public")
            return readPkcs1ECDSAPublic(der);
          throw new Error("Unknown key type: " + type);
        case "EDDSA":
        case "EdDSA":
          if (type === "private")
            return readPkcs1EdDSAPrivate(der);
          throw new Error(type + " keys not supported with EdDSA");
        default:
          throw new Error("Unknown key algo: " + alg);
      }
    }
    function readPkcs1RSAPublic(der) {
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "exponent");
      var key = {
        type: "rsa",
        parts: [
          { name: "e", data: e },
          { name: "n", data: n }
        ]
      };
      return new Key(key);
    }
    function readPkcs1RSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version[0], 0);
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "public exponent");
      var d = readMPInt(der, "private exponent");
      var p = readMPInt(der, "prime1");
      var q2 = readMPInt(der, "prime2");
      var dmodp = readMPInt(der, "exponent1");
      var dmodq = readMPInt(der, "exponent2");
      var iqmp = readMPInt(der, "iqmp");
      var key = {
        type: "rsa",
        parts: [
          { name: "n", data: n },
          { name: "e", data: e },
          { name: "d", data: d },
          { name: "iqmp", data: iqmp },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "dmodp", data: dmodp },
          { name: "dmodq", data: dmodq }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1DSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version.readUInt8(0), 0);
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      var y = readMPInt(der, "y");
      var x = readMPInt(der, "x");
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y },
          { name: "x", data: x }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1EdDSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version.readUInt8(0), 1);
      var k = der.readString(asn1.Ber.OctetString, true);
      der.readSequence(160);
      var oid = der.readOID();
      assert.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
      der.readSequence(161);
      var A = utils.readBitString(der);
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: k }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1DSAPublic(der) {
      var y = readMPInt(der, "y");
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      var key = {
        type: "dsa",
        parts: [
          { name: "y", data: y },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g }
        ]
      };
      return new Key(key);
    }
    function readPkcs1ECDSAPublic(der) {
      der.readSequence();
      var oid = der.readOID();
      assert.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
      var curveOid = der.readOID();
      var curve;
      var curves = Object.keys(algs.curves);
      for (var j = 0; j < curves.length; ++j) {
        var c = curves[j];
        var cd = algs.curves[c];
        if (cd.pkcs8oid === curveOid) {
          curve = c;
          break;
        }
      }
      assert.string(curve, "a known ECDSA named curve");
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: Q }
        ]
      };
      return new Key(key);
    }
    function readPkcs1ECDSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert.strictEqual(version.readUInt8(0), 1);
      var d = der.readString(asn1.Ber.OctetString, true);
      der.readSequence(160);
      var curve = readECDSACurve(der);
      assert.string(curve, "a known elliptic curve");
      der.readSequence(161);
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: Q },
          { name: "d", data: d }
        ]
      };
      return new PrivateKey(key);
    }
    function writePkcs1(der, key) {
      der.startSequence();
      switch (key.type) {
        case "rsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1RSAPrivate(der, key);
          else
            writePkcs1RSAPublic(der, key);
          break;
        case "dsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1DSAPrivate(der, key);
          else
            writePkcs1DSAPublic(der, key);
          break;
        case "ecdsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1ECDSAPrivate(der, key);
          else
            writePkcs1ECDSAPublic(der, key);
          break;
        case "ed25519":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1EdDSAPrivate(der, key);
          else
            writePkcs1EdDSAPublic(der, key);
          break;
        default:
          throw new Error("Unknown key algo: " + key.type);
      }
      der.endSequence();
    }
    function writePkcs1RSAPublic(der, key) {
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    }
    function writePkcs1RSAPrivate(der, key) {
      var ver = Buffer2.from([0]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      if (!key.part.dmodp || !key.part.dmodq)
        utils.addRSAMissing(key);
      der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    }
    function writePkcs1DSAPrivate(der, key) {
      var ver = Buffer2.from([0]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    }
    function writePkcs1DSAPublic(der, key) {
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    }
    function writePkcs1ECDSAPublic(der, key) {
      der.startSequence();
      der.writeOID("1.2.840.10045.2.1");
      var curve = key.part.curve.data.toString();
      var curveOid = algs.curves[curve].pkcs8oid;
      assert.string(curveOid, "a known ECDSA named curve");
      der.writeOID(curveOid);
      der.endSequence();
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
    }
    function writePkcs1ECDSAPrivate(der, key) {
      var ver = Buffer2.from([1]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
      der.startSequence(160);
      var curve = key.part.curve.data.toString();
      var curveOid = algs.curves[curve].pkcs8oid;
      assert.string(curveOid, "a known ECDSA named curve");
      der.writeOID(curveOid);
      der.endSequence();
      der.startSequence(161);
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
      der.endSequence();
    }
    function writePkcs1EdDSAPrivate(der, key) {
      var ver = Buffer2.from([1]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
      der.startSequence(160);
      der.writeOID("1.3.101.112");
      der.endSequence();
      der.startSequence(161);
      utils.writeBitString(der, key.part.A.data);
      der.endSequence();
    }
    function writePkcs1EdDSAPublic(der, key) {
      throw new Error("Public keys are not supported for EdDSA PKCS#1");
    }
  }
});

// node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS({
  "node_modules/sshpk/lib/formats/rfc4253.js"(exports, module) {
    module.exports = {
      read: read.bind(void 0, false, void 0),
      readType: read.bind(void 0, false),
      write,
      readPartial: read.bind(void 0, true),
      readInternal: read,
      keyTypeToAlg,
      algToKeyType
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var SSHBuffer = require_ssh_buffer();
    function algToKeyType(alg) {
      assert.string(alg);
      if (alg === "ssh-dss")
        return "dsa";
      else if (alg === "ssh-rsa")
        return "rsa";
      else if (alg === "ssh-ed25519")
        return "ed25519";
      else if (alg === "ssh-curve25519")
        return "curve25519";
      else if (alg.match(/^ecdsa-sha2-/))
        return "ecdsa";
      else
        throw new Error("Unknown algorithm " + alg);
    }
    function keyTypeToAlg(key) {
      assert.object(key);
      if (key.type === "dsa")
        return "ssh-dss";
      else if (key.type === "rsa")
        return "ssh-rsa";
      else if (key.type === "ed25519")
        return "ssh-ed25519";
      else if (key.type === "curve25519")
        return "ssh-curve25519";
      else if (key.type === "ecdsa")
        return "ecdsa-sha2-" + key.part.curve.data.toString();
      else
        throw new Error("Unknown key type " + key.type);
    }
    function read(partial, type, buf, options) {
      if (typeof buf === "string")
        buf = Buffer2.from(buf);
      assert.buffer(buf, "buf");
      var key = {};
      var parts = key.parts = [];
      var sshbuf = new SSHBuffer({ buffer: buf });
      var alg = sshbuf.readString();
      assert.ok(!sshbuf.atEnd(), "key must have at least one part");
      key.type = algToKeyType(alg);
      var partCount = algs.info[key.type].parts.length;
      if (type && type === "private")
        partCount = algs.privInfo[key.type].parts.length;
      while (!sshbuf.atEnd() && parts.length < partCount)
        parts.push(sshbuf.readPart());
      while (!partial && !sshbuf.atEnd())
        parts.push(sshbuf.readPart());
      assert.ok(parts.length >= 1, "key must have at least one part");
      assert.ok(partial || sshbuf.atEnd(), "leftover bytes at end of key");
      var Constructor = Key;
      var algInfo = algs.info[key.type];
      if (type === "private" || algInfo.parts.length !== parts.length) {
        algInfo = algs.privInfo[key.type];
        Constructor = PrivateKey;
      }
      assert.strictEqual(algInfo.parts.length, parts.length);
      if (key.type === "ecdsa") {
        var res = /^ecdsa-sha2-(.+)$/.exec(alg);
        assert.ok(res !== null);
        assert.strictEqual(res[1], parts[0].data.toString());
      }
      var normalized = true;
      for (var i = 0; i < algInfo.parts.length; ++i) {
        var p = parts[i];
        p.name = algInfo.parts[i];
        if (key.type === "ed25519" && p.name === "k")
          p.data = p.data.slice(0, 32);
        if (p.name !== "curve" && algInfo.normalize !== false) {
          var nd;
          if (key.type === "ed25519") {
            nd = utils.zeroPadToLength(p.data, 32);
          } else {
            nd = utils.mpNormalize(p.data);
          }
          if (nd.toString("binary") !== p.data.toString("binary")) {
            p.data = nd;
            normalized = false;
          }
        }
      }
      if (normalized)
        key._rfc4253Cache = sshbuf.toBuffer();
      if (partial && typeof partial === "object") {
        partial.remainder = sshbuf.remainder();
        partial.consumed = sshbuf._offset;
      }
      return new Constructor(key);
    }
    function write(key, options) {
      assert.object(key);
      var alg = keyTypeToAlg(key);
      var i;
      var algInfo = algs.info[key.type];
      if (PrivateKey.isPrivateKey(key))
        algInfo = algs.privInfo[key.type];
      var parts = algInfo.parts;
      var buf = new SSHBuffer({});
      buf.writeString(alg);
      for (i = 0; i < parts.length; ++i) {
        var data = key.part[parts[i]].data;
        if (algInfo.normalize !== false) {
          if (key.type === "ed25519")
            data = utils.zeroPadToLength(data, 32);
          else
            data = utils.mpNormalize(data);
        }
        if (key.type === "ed25519" && parts[i] === "k")
          data = Buffer2.concat([data, key.part.A.data]);
        buf.writeBuffer(data);
      }
      return buf.toBuffer();
    }
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports, module) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0)
          x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes)
          BLF_J = 0;
        temp = temp << 8 | data[BLF_J];
      }
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data, databytes);
          d[1] ^= stream2word(data, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state.expand0state(sha2salt, 64);
        state.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1)
        return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen)
            break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    module.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS({
  "node_modules/sshpk/lib/formats/ssh-private.js"(exports, module) {
    module.exports = {
      read,
      readSSHPrivate,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var rfc4253 = require_rfc4253();
    var SSHBuffer = require_ssh_buffer();
    var errors = require_errors();
    var bcrypt;
    function read(buf, options) {
      return pem.read(buf, options);
    }
    var MAGIC = "openssh-key-v1";
    function readSSHPrivate(type, buf, options) {
      buf = new SSHBuffer({ buffer: buf });
      var magic = buf.readCString();
      assert.strictEqual(magic, MAGIC, "bad magic string");
      var cipher = buf.readString();
      var kdf = buf.readString();
      var kdfOpts = buf.readBuffer();
      var nkeys = buf.readInt();
      if (nkeys !== 1) {
        throw new Error("OpenSSH-format key file contains multiple keys: this is unsupported.");
      }
      var pubKey = buf.readBuffer();
      if (type === "public") {
        assert.ok(buf.atEnd(), "excess bytes left after key");
        return rfc4253.read(pubKey);
      }
      var privKeyBlob = buf.readBuffer();
      assert.ok(buf.atEnd(), "excess bytes left after key");
      var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
      switch (kdf) {
        case "none":
          if (cipher !== "none") {
            throw new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"');
          }
          break;
        case "bcrypt":
          var salt = kdfOptsBuf.readBuffer();
          var rounds = kdfOptsBuf.readInt();
          var cinf = utils.opensshCipherInfo(cipher);
          if (bcrypt === void 0) {
            bcrypt = require_bcrypt_pbkdf();
          }
          if (typeof options.passphrase === "string") {
            options.passphrase = Buffer2.from(options.passphrase, "utf-8");
          }
          if (!Buffer2.isBuffer(options.passphrase)) {
            throw new errors.KeyEncryptedError(options.filename, "OpenSSH");
          }
          var pass = new Uint8Array(options.passphrase);
          var salti = new Uint8Array(salt);
          var out = new Uint8Array(cinf.keySize + cinf.blockSize);
          var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
          if (res !== 0) {
            throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
          }
          out = Buffer2.from(out);
          var ckey = out.slice(0, cinf.keySize);
          var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
          var cipherStream = crypto.createDecipheriv(cinf.opensslName, ckey, iv);
          cipherStream.setAutoPadding(false);
          var chunk, chunks = [];
          cipherStream.once("error", function(e) {
            if (e.toString().indexOf("bad decrypt") !== -1) {
              throw new Error("Incorrect passphrase supplied, could not decrypt key");
            }
            throw e;
          });
          cipherStream.write(privKeyBlob);
          cipherStream.end();
          while ((chunk = cipherStream.read()) !== null)
            chunks.push(chunk);
          privKeyBlob = Buffer2.concat(chunks);
          break;
        default:
          throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
      }
      buf = new SSHBuffer({ buffer: privKeyBlob });
      var checkInt1 = buf.readInt();
      var checkInt2 = buf.readInt();
      if (checkInt1 !== checkInt2) {
        throw new Error("Incorrect passphrase supplied, could not decrypt key");
      }
      var ret = {};
      var key = rfc4253.readInternal(ret, "private", buf.remainder());
      buf.skip(ret.consumed);
      var comment = buf.readString();
      key.comment = comment;
      return key;
    }
    function write(key, options) {
      var pubKey;
      if (PrivateKey.isPrivateKey(key))
        pubKey = key.toPublic();
      else
        pubKey = key;
      var cipher = "none";
      var kdf = "none";
      var kdfopts = Buffer2.alloc(0);
      var cinf = { blockSize: 8 };
      var passphrase;
      if (options !== void 0) {
        passphrase = options.passphrase;
        if (typeof passphrase === "string")
          passphrase = Buffer2.from(passphrase, "utf-8");
        if (passphrase !== void 0) {
          assert.buffer(passphrase, "options.passphrase");
          assert.optionalString(options.cipher, "options.cipher");
          cipher = options.cipher;
          if (cipher === void 0)
            cipher = "aes128-ctr";
          cinf = utils.opensshCipherInfo(cipher);
          kdf = "bcrypt";
        }
      }
      var privBuf;
      if (PrivateKey.isPrivateKey(key)) {
        privBuf = new SSHBuffer({});
        var checkInt = crypto.randomBytes(4).readUInt32BE(0);
        privBuf.writeInt(checkInt);
        privBuf.writeInt(checkInt);
        privBuf.write(key.toBuffer("rfc4253"));
        privBuf.writeString(key.comment || "");
        var n = 1;
        while (privBuf._offset % cinf.blockSize !== 0)
          privBuf.writeChar(n++);
        privBuf = privBuf.toBuffer();
      }
      switch (kdf) {
        case "none":
          break;
        case "bcrypt":
          var salt = crypto.randomBytes(16);
          var rounds = 16;
          var kdfssh = new SSHBuffer({});
          kdfssh.writeBuffer(salt);
          kdfssh.writeInt(rounds);
          kdfopts = kdfssh.toBuffer();
          if (bcrypt === void 0) {
            bcrypt = require_bcrypt_pbkdf();
          }
          var pass = new Uint8Array(passphrase);
          var salti = new Uint8Array(salt);
          var out = new Uint8Array(cinf.keySize + cinf.blockSize);
          var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
          if (res !== 0) {
            throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
          }
          out = Buffer2.from(out);
          var ckey = out.slice(0, cinf.keySize);
          var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
          var cipherStream = crypto.createCipheriv(cinf.opensslName, ckey, iv);
          cipherStream.setAutoPadding(false);
          var chunk, chunks = [];
          cipherStream.once("error", function(e) {
            throw e;
          });
          cipherStream.write(privBuf);
          cipherStream.end();
          while ((chunk = cipherStream.read()) !== null)
            chunks.push(chunk);
          privBuf = Buffer2.concat(chunks);
          break;
        default:
          throw new Error("Unsupported kdf " + kdf);
      }
      var buf = new SSHBuffer({});
      buf.writeCString(MAGIC);
      buf.writeString(cipher);
      buf.writeString(kdf);
      buf.writeBuffer(kdfopts);
      buf.writeInt(1);
      buf.writeBuffer(pubKey.toBuffer("rfc4253"));
      if (privBuf)
        buf.writeBuffer(privBuf);
      buf = buf.toBuffer();
      var header;
      if (PrivateKey.isPrivateKey(key))
        header = "OPENSSH PRIVATE KEY";
      else
        header = "OPENSSH PUBLIC KEY";
      var tmp = buf.toString("base64");
      var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
      buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 70;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS({
  "node_modules/sshpk/lib/formats/pem.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib2();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pkcs1 = require_pkcs1();
    var pkcs8 = require_pkcs8();
    var sshpriv = require_ssh_private();
    var rfc4253 = require_rfc4253();
    var errors = require_errors();
    var OID_PBES2 = "1.2.840.113549.1.5.13";
    var OID_PBKDF2 = "1.2.840.113549.1.5.12";
    var OID_TO_CIPHER = {
      "1.2.840.113549.3.7": "3des-cbc",
      "2.16.840.1.101.3.4.1.2": "aes128-cbc",
      "2.16.840.1.101.3.4.1.42": "aes256-cbc"
    };
    var CIPHER_TO_OID = {};
    Object.keys(OID_TO_CIPHER).forEach(function(k) {
      CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
    });
    var OID_TO_HASH = {
      "1.2.840.113549.2.7": "sha1",
      "1.2.840.113549.2.9": "sha256",
      "1.2.840.113549.2.11": "sha512"
    };
    var HASH_TO_OID = {};
    Object.keys(OID_TO_HASH).forEach(function(k) {
      HASH_TO_OID[OID_TO_HASH[k]] = k;
    });
    function read(buf, options, forceType) {
      var input = buf;
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.trim().split(/[\r\n]+/g);
      var m;
      var si = -1;
      while (!m && si < lines.length) {
        m = lines[++si].match(/[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
      }
      assert.ok(m, "invalid PEM header");
      var m2;
      var ei = lines.length;
      while (!m2 && ei > 0) {
        m2 = lines[--ei].match(/[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
      }
      assert.ok(m2, "invalid PEM footer");
      assert.equal(m[2], m2[2]);
      var type = m[2].toLowerCase();
      var alg;
      if (m[1]) {
        assert.equal(m[1], m2[1], "PEM header and footer mismatch");
        alg = m[1].trim();
      }
      lines = lines.slice(si, ei + 1);
      var headers = {};
      while (true) {
        lines = lines.slice(1);
        m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
        if (!m)
          break;
        headers[m[1].toLowerCase()] = m[2];
      }
      lines = lines.slice(0, -1).join("");
      buf = Buffer2.from(lines, "base64");
      var cipher, key, iv;
      if (headers["proc-type"]) {
        var parts = headers["proc-type"].split(",");
        if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
          if (typeof options.passphrase === "string") {
            options.passphrase = Buffer2.from(options.passphrase, "utf-8");
          }
          if (!Buffer2.isBuffer(options.passphrase)) {
            throw new errors.KeyEncryptedError(options.filename, "PEM");
          } else {
            parts = headers["dek-info"].split(",");
            assert.ok(parts.length === 2);
            cipher = parts[0].toLowerCase();
            iv = Buffer2.from(parts[1], "hex");
            key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
          }
        }
      }
      if (alg && alg.toLowerCase() === "encrypted") {
        var eder = new asn1.BerReader(buf);
        var pbesEnd;
        eder.readSequence();
        eder.readSequence();
        pbesEnd = eder.offset + eder.length;
        var method = eder.readOID();
        if (method !== OID_PBES2) {
          throw new Error("Unsupported PEM/PKCS8 encryption scheme: " + method);
        }
        eder.readSequence();
        eder.readSequence();
        var kdfEnd = eder.offset + eder.length;
        var kdfOid = eder.readOID();
        if (kdfOid !== OID_PBKDF2)
          throw new Error("Unsupported PBES2 KDF: " + kdfOid);
        eder.readSequence();
        var salt = eder.readString(asn1.Ber.OctetString, true);
        var iterations = eder.readInt();
        var hashAlg = "sha1";
        if (eder.offset < kdfEnd) {
          eder.readSequence();
          var hashAlgOid = eder.readOID();
          hashAlg = OID_TO_HASH[hashAlgOid];
          if (hashAlg === void 0) {
            throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
          }
        }
        eder._offset = kdfEnd;
        eder.readSequence();
        var cipherOid = eder.readOID();
        cipher = OID_TO_CIPHER[cipherOid];
        if (cipher === void 0) {
          throw new Error("Unsupported PBES2 cipher: " + cipherOid);
        }
        iv = eder.readString(asn1.Ber.OctetString, true);
        eder._offset = pbesEnd;
        buf = eder.readString(asn1.Ber.OctetString, true);
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        }
        var cinfo = utils.opensshCipherInfo(cipher);
        cipher = cinfo.opensslName;
        key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize, options.passphrase);
        alg = void 0;
      }
      if (cipher && key && iv) {
        var cipherStream = crypto.createDecipheriv(cipher, key, iv);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(buf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        buf = Buffer2.concat(chunks);
      }
      if (alg && alg.toLowerCase() === "openssh")
        return sshpriv.readSSHPrivate(type, buf, options);
      if (alg && alg.toLowerCase() === "ssh2")
        return rfc4253.readType(type, buf, options);
      var der = new asn1.BerReader(buf);
      der.originalInput = input;
      der.readSequence();
      if (alg) {
        if (forceType)
          assert.strictEqual(forceType, "pkcs1");
        return pkcs1.readPkcs1(alg, type, der);
      } else {
        if (forceType)
          assert.strictEqual(forceType, "pkcs8");
        return pkcs8.readPkcs8(alg, type, der);
      }
    }
    function write(key, options, type) {
      assert.object(key);
      var alg = {
        "ecdsa": "EC",
        "rsa": "RSA",
        "dsa": "DSA",
        "ed25519": "EdDSA"
      }[key.type];
      var header;
      var der = new asn1.BerWriter();
      if (PrivateKey.isPrivateKey(key)) {
        if (type && type === "pkcs8") {
          header = "PRIVATE KEY";
          pkcs8.writePkcs8(der, key);
        } else {
          if (type)
            assert.strictEqual(type, "pkcs1");
          header = alg + " PRIVATE KEY";
          pkcs1.writePkcs1(der, key);
        }
      } else if (Key.isKey(key)) {
        if (type && type === "pkcs1") {
          header = alg + " PUBLIC KEY";
          pkcs1.writePkcs1(der, key);
        } else {
          if (type)
            assert.strictEqual(type, "pkcs8");
          header = "PUBLIC KEY";
          pkcs8.writePkcs8(der, key);
        }
      } else {
        throw new Error("key is not a Key or PrivateKey");
      }
      var tmp = der.buffer.toString("base64");
      var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
      var buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 64;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS({
  "node_modules/sshpk/lib/formats/ssh.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var rfc4253 = require_rfc4253();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var sshpriv = require_ssh_private();
    var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
    var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var trimmed = buf.trim().replace(/[\\\r]/g, "");
      var m = trimmed.match(SSHKEY_RE);
      if (!m)
        m = trimmed.match(SSHKEY_RE2);
      assert.ok(m, "key must match regex");
      var type = rfc4253.algToKeyType(m[1]);
      var kbuf = Buffer2.from(m[2], "base64");
      var key;
      var ret = {};
      if (m[4]) {
        try {
          key = rfc4253.read(kbuf);
        } catch (e) {
          m = trimmed.match(SSHKEY_RE2);
          assert.ok(m, "key must match regex");
          kbuf = Buffer2.from(m[2], "base64");
          key = rfc4253.readInternal(ret, "public", kbuf);
        }
      } else {
        key = rfc4253.readInternal(ret, "public", kbuf);
      }
      assert.strictEqual(type, key.type);
      if (m[4] && m[4].length > 0) {
        key.comment = m[4];
      } else if (ret.consumed) {
        var data = m[2] + (m[3] ? m[3] : "");
        var realOffset = Math.ceil(ret.consumed / 3) * 4;
        data = data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data.slice(realOffset - 2);
        var padding = ret.consumed % 3;
        if (padding > 0 && data.slice(realOffset - 1, realOffset) !== "=")
          realOffset--;
        while (data.slice(realOffset, realOffset + 1) === "=")
          realOffset++;
        var trailer = data.slice(realOffset);
        trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
        if (trailer.match(/^[a-zA-Z0-9]/))
          key.comment = trailer;
      }
      return key;
    }
    function write(key, options) {
      assert.object(key);
      if (!Key.isKey(key))
        throw new Error("Must be a public key");
      var parts = [];
      var alg = rfc4253.keyTypeToAlg(key);
      parts.push(alg);
      var buf = rfc4253.write(key);
      parts.push(buf.toString("base64"));
      if (key.comment)
        parts.push(key.comment);
      return Buffer2.from(parts.join(" "));
    }
  }
});

// node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS({
  "node_modules/sshpk/lib/formats/dnssec.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var Key = require_key();
    var PrivateKey = require_private_key();
    var utils = require_utils();
    var SSHBuffer = require_ssh_buffer();
    var Dhe = require_dhe();
    var supportedAlgos = {
      "rsa-sha1": 5,
      "rsa-sha256": 8,
      "rsa-sha512": 10,
      "ecdsa-p256-sha256": 13,
      "ecdsa-p384-sha384": 14
    };
    var supportedAlgosById = {};
    Object.keys(supportedAlgos).forEach(function(k) {
      supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
    });
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.split("\n");
      if (lines[0].match(/^Private-key-format\: v1/)) {
        var algElems = lines[1].split(" ");
        var algoNum = parseInt(algElems[1], 10);
        var algoName = algElems[2];
        if (!supportedAlgosById[algoNum])
          throw new Error("Unsupported algorithm: " + algoName);
        return readDNSSECPrivateKey(algoNum, lines.slice(2));
      }
      var line = 0;
      while (lines[line].match(/^\;/))
        line++;
      if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
        return readRFC3110(lines[line]);
      }
      throw new Error("Cannot parse dnssec key");
    }
    function readRFC3110(keyString) {
      var elems = keyString.split(" ");
      var algorithm = parseInt(elems[5], 10);
      if (!supportedAlgosById[algorithm])
        throw new Error("Unsupported algorithm: " + algorithm);
      var base64key = elems.slice(6, elems.length).join();
      var keyBuffer = Buffer2.from(base64key, "base64");
      if (supportedAlgosById[algorithm].match(/^RSA-/)) {
        var publicExponentLen = keyBuffer.readUInt8(0);
        if (publicExponentLen != 3 && publicExponentLen != 1)
          throw new Error("Cannot parse dnssec key: unsupported exponent length");
        var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
        publicExponent = utils.mpNormalize(publicExponent);
        var modulus = keyBuffer.slice(1 + publicExponentLen);
        modulus = utils.mpNormalize(modulus);
        var rsaKey = {
          type: "rsa",
          parts: []
        };
        rsaKey.parts.push({ name: "e", data: publicExponent });
        rsaKey.parts.push({ name: "n", data: modulus });
        return new Key(rsaKey);
      }
      if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
        var curve = "nistp384";
        var size = 384;
        if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
          curve = "nistp256";
          size = 256;
        }
        var ecdsaKey = {
          type: "ecdsa",
          curve,
          size,
          parts: [
            { name: "curve", data: Buffer2.from(curve) },
            { name: "Q", data: utils.ecNormalize(keyBuffer) }
          ]
        };
        return new Key(ecdsaKey);
      }
      throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
    }
    function elementToBuf(e) {
      return Buffer2.from(e.split(" ")[1], "base64");
    }
    function readDNSSECRSAPrivateKey(elements) {
      var rsaParams = {};
      elements.forEach(function(element) {
        if (element.split(" ")[0] === "Modulus:")
          rsaParams["n"] = elementToBuf(element);
        else if (element.split(" ")[0] === "PublicExponent:")
          rsaParams["e"] = elementToBuf(element);
        else if (element.split(" ")[0] === "PrivateExponent:")
          rsaParams["d"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Prime1:")
          rsaParams["p"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Prime2:")
          rsaParams["q"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Exponent1:")
          rsaParams["dmodp"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Exponent2:")
          rsaParams["dmodq"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Coefficient:")
          rsaParams["iqmp"] = elementToBuf(element);
      });
      var key = {
        type: "rsa",
        parts: [
          { name: "e", data: utils.mpNormalize(rsaParams["e"]) },
          { name: "n", data: utils.mpNormalize(rsaParams["n"]) },
          { name: "d", data: utils.mpNormalize(rsaParams["d"]) },
          { name: "p", data: utils.mpNormalize(rsaParams["p"]) },
          { name: "q", data: utils.mpNormalize(rsaParams["q"]) },
          {
            name: "dmodp",
            data: utils.mpNormalize(rsaParams["dmodp"])
          },
          {
            name: "dmodq",
            data: utils.mpNormalize(rsaParams["dmodq"])
          },
          {
            name: "iqmp",
            data: utils.mpNormalize(rsaParams["iqmp"])
          }
        ]
      };
      return new PrivateKey(key);
    }
    function readDNSSECPrivateKey(alg, elements) {
      if (supportedAlgosById[alg].match(/^RSA-/)) {
        return readDNSSECRSAPrivateKey(elements);
      }
      if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        var d = Buffer2.from(elements[0].split(" ")[1], "base64");
        var curve = "nistp384";
        var size = 384;
        if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
          curve = "nistp256";
          size = 256;
        }
        var publicKey = utils.publicFromPrivateECDSA(curve, d);
        var Q = publicKey.part["Q"].data;
        var ecdsaKey = {
          type: "ecdsa",
          curve,
          size,
          parts: [
            { name: "curve", data: Buffer2.from(curve) },
            { name: "d", data: d },
            { name: "Q", data: Q }
          ]
        };
        return new PrivateKey(ecdsaKey);
      }
      throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
    }
    function dnssecTimestamp(date) {
      var year = date.getFullYear() + "";
      var month = date.getMonth() + 1;
      var timestampStr = year + month + date.getUTCDate();
      timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
      timestampStr += date.getUTCSeconds();
      return timestampStr;
    }
    function rsaAlgFromOptions(opts) {
      if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
        return "5 (RSASHA1)";
      else if (opts.hashAlgo === "sha256")
        return "8 (RSASHA256)";
      else if (opts.hashAlgo === "sha512")
        return "10 (RSASHA512)";
      else
        throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
    }
    function writeRSA(key, options) {
      if (!key.part.dmodp || !key.part.dmodq) {
        utils.addRSAMissing(key);
      }
      var out = "";
      out += "Private-key-format: v1.3\n";
      out += "Algorithm: " + rsaAlgFromOptions(options) + "\n";
      var n = utils.mpDenormalize(key.part["n"].data);
      out += "Modulus: " + n.toString("base64") + "\n";
      var e = utils.mpDenormalize(key.part["e"].data);
      out += "PublicExponent: " + e.toString("base64") + "\n";
      var d = utils.mpDenormalize(key.part["d"].data);
      out += "PrivateExponent: " + d.toString("base64") + "\n";
      var p = utils.mpDenormalize(key.part["p"].data);
      out += "Prime1: " + p.toString("base64") + "\n";
      var q2 = utils.mpDenormalize(key.part["q"].data);
      out += "Prime2: " + q2.toString("base64") + "\n";
      var dmodp = utils.mpDenormalize(key.part["dmodp"].data);
      out += "Exponent1: " + dmodp.toString("base64") + "\n";
      var dmodq = utils.mpDenormalize(key.part["dmodq"].data);
      out += "Exponent2: " + dmodq.toString("base64") + "\n";
      var iqmp = utils.mpDenormalize(key.part["iqmp"].data);
      out += "Coefficient: " + iqmp.toString("base64") + "\n";
      var timestamp = new Date();
      out += "Created: " + dnssecTimestamp(timestamp) + "\n";
      out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
      out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
      return Buffer2.from(out, "ascii");
    }
    function writeECDSA(key, options) {
      var out = "";
      out += "Private-key-format: v1.3\n";
      if (key.curve === "nistp256") {
        out += "Algorithm: 13 (ECDSAP256SHA256)\n";
      } else if (key.curve === "nistp384") {
        out += "Algorithm: 14 (ECDSAP384SHA384)\n";
      } else {
        throw new Error("Unsupported curve");
      }
      var base64Key = key.part["d"].data.toString("base64");
      out += "PrivateKey: " + base64Key + "\n";
      var timestamp = new Date();
      out += "Created: " + dnssecTimestamp(timestamp) + "\n";
      out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
      out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
      return Buffer2.from(out, "ascii");
    }
    function write(key, options) {
      if (PrivateKey.isPrivateKey(key)) {
        if (key.type === "rsa") {
          return writeRSA(key, options);
        } else if (key.type === "ecdsa") {
          return writeECDSA(key, options);
        } else {
          throw new Error("Unsupported algorithm: " + key.type);
        }
      } else if (Key.isKey(key)) {
        throw new Error('Format "dnssec" only supports writing private keys');
      } else {
        throw new Error("key is not a Key or PrivateKey");
      }
    }
  }
});

// node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS({
  "node_modules/sshpk/lib/formats/putty.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var rfc4253 = require_rfc4253();
    var Key = require_key();
    var SSHBuffer = require_ssh_buffer();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var PrivateKey = require_private_key();
    var errors = require_errors();
    function read(buf, options) {
      var lines = buf.toString("ascii").split(/[\r\n]+/);
      var found = false;
      var parts;
      var si = 0;
      var formatVersion;
      while (si < lines.length) {
        parts = splitHeader(lines[si++]);
        if (parts) {
          formatVersion = {
            "putty-user-key-file-2": 2,
            "putty-user-key-file-3": 3
          }[parts[0].toLowerCase()];
          if (formatVersion) {
            found = true;
            break;
          }
        }
      }
      if (!found) {
        throw new Error("No PuTTY format first line found");
      }
      var alg = parts[1];
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "encryption");
      var encryption = parts[1];
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "comment");
      var comment = parts[1];
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "public-lines");
      var publicLines = parseInt(parts[1], 10);
      if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
        throw new Error("Invalid public-lines count");
      }
      var publicBuf = Buffer2.from(lines.slice(si, si + publicLines).join(""), "base64");
      var keyType = rfc4253.algToKeyType(alg);
      var key = rfc4253.read(publicBuf);
      if (key.type !== keyType) {
        throw new Error("Outer key algorithm mismatch");
      }
      si += publicLines;
      if (lines[si]) {
        parts = splitHeader(lines[si++]);
        assert.equal(parts[0].toLowerCase(), "private-lines");
        var privateLines = parseInt(parts[1], 10);
        if (!isFinite(privateLines) || privateLines < 0 || privateLines > lines.length) {
          throw new Error("Invalid private-lines count");
        }
        var privateBuf = Buffer2.from(lines.slice(si, si + privateLines).join(""), "base64");
        if (encryption !== "none" && formatVersion === 3) {
          throw new Error("Encrypted keys arenot supported for PuTTY format version 3");
        }
        if (encryption === "aes256-cbc") {
          if (!options.passphrase) {
            throw new errors.KeyEncryptedError(options.filename, "PEM");
          }
          var iv = Buffer2.alloc(16, 0);
          var decipher = crypto.createDecipheriv("aes-256-cbc", derivePPK2EncryptionKey(options.passphrase), iv);
          decipher.setAutoPadding(false);
          privateBuf = Buffer2.concat([
            decipher.update(privateBuf),
            decipher.final()
          ]);
        }
        key = new PrivateKey(key);
        if (key.type !== keyType) {
          throw new Error("Outer key algorithm mismatch");
        }
        var sshbuf = new SSHBuffer({ buffer: privateBuf });
        var privateKeyParts;
        if (alg === "ssh-dss") {
          privateKeyParts = [{
            name: "x",
            data: sshbuf.readBuffer()
          }];
        } else if (alg === "ssh-rsa") {
          privateKeyParts = [
            { name: "d", data: sshbuf.readBuffer() },
            { name: "p", data: sshbuf.readBuffer() },
            { name: "q", data: sshbuf.readBuffer() },
            { name: "iqmp", data: sshbuf.readBuffer() }
          ];
        } else if (alg.match(/^ecdsa-sha2-nistp/)) {
          privateKeyParts = [{
            name: "d",
            data: sshbuf.readBuffer()
          }];
        } else if (alg === "ssh-ed25519") {
          privateKeyParts = [{
            name: "k",
            data: sshbuf.readBuffer()
          }];
        } else {
          throw new Error("Unsupported PPK key type: " + alg);
        }
        key = new PrivateKey({
          type: key.type,
          parts: key.parts.concat(privateKeyParts)
        });
      }
      key.comment = comment;
      return key;
    }
    function derivePPK2EncryptionKey(passphrase) {
      var hash1 = crypto.createHash("sha1").update(Buffer2.concat([
        Buffer2.from([0, 0, 0, 0]),
        Buffer2.from(passphrase)
      ])).digest();
      var hash2 = crypto.createHash("sha1").update(Buffer2.concat([
        Buffer2.from([0, 0, 0, 1]),
        Buffer2.from(passphrase)
      ])).digest();
      return Buffer2.concat([hash1, hash2]).slice(0, 32);
    }
    function splitHeader(line) {
      var idx = line.indexOf(":");
      if (idx === -1)
        return null;
      var header = line.slice(0, idx);
      ++idx;
      while (line[idx] === " ")
        ++idx;
      var rest = line.slice(idx);
      return [header, rest];
    }
    function write(key, options) {
      assert.object(key);
      if (!Key.isKey(key))
        throw new Error("Must be a public key");
      var alg = rfc4253.keyTypeToAlg(key);
      var buf = rfc4253.write(key);
      var comment = key.comment || "";
      var b64 = buf.toString("base64");
      var lines = wrap(b64, 64);
      lines.unshift("Public-Lines: " + lines.length);
      lines.unshift("Comment: " + comment);
      lines.unshift("Encryption: none");
      lines.unshift("PuTTY-User-Key-File-2: " + alg);
      return Buffer2.from(lines.join("\n") + "\n");
    }
    function wrap(txt, len) {
      var lines = [];
      var pos = 0;
      while (pos < txt.length) {
        lines.push(txt.slice(pos, pos + 64));
        pos += 64;
      }
      return lines;
    }
  }
});

// node_modules/sshpk/lib/formats/auto.js
var require_auto = __commonJS({
  "node_modules/sshpk/lib/formats/auto.js"(exports, module) {
    module.exports = {
      read,
      write
    };
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var ssh = require_ssh();
    var rfc4253 = require_rfc4253();
    var dnssec = require_dnssec();
    var putty = require_putty();
    var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
    function read(buf, options) {
      if (typeof buf === "string") {
        if (buf.trim().match(/^[-]+[ ]*BEGIN/))
          return pem.read(buf, options);
        if (buf.match(/^\s*ssh-[a-z]/))
          return ssh.read(buf, options);
        if (buf.match(/^\s*ecdsa-/))
          return ssh.read(buf, options);
        if (buf.match(/^putty-user-key-file-2:/i))
          return putty.read(buf, options);
        if (findDNSSECHeader(buf))
          return dnssec.read(buf, options);
        buf = Buffer2.from(buf, "binary");
      } else {
        assert.buffer(buf);
        if (findPEMHeader(buf))
          return pem.read(buf, options);
        if (findSSHHeader(buf))
          return ssh.read(buf, options);
        if (findPuTTYHeader(buf))
          return putty.read(buf, options);
        if (findDNSSECHeader(buf))
          return dnssec.read(buf, options);
      }
      if (buf.readUInt32BE(0) < buf.length)
        return rfc4253.read(buf, options);
      throw new Error("Failed to auto-detect format of key");
    }
    function findPuTTYHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
        ++offset;
      if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
        return true;
      return false;
    }
    function findSSHHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
        ++offset;
      if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
        return true;
      if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
        return true;
      return false;
    }
    function findPEMHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
        ++offset;
      if (buf[offset] !== 45)
        return false;
      while (offset < buf.length && buf[offset] === 45)
        ++offset;
      while (offset < buf.length && buf[offset] === 32)
        ++offset;
      if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
        return false;
      return true;
    }
    function findDNSSECHeader(buf) {
      if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
        return false;
      var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
      if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
        return true;
      if (typeof buf !== "string") {
        buf = buf.toString("ascii");
      }
      var lines = buf.split("\n");
      var line = 0;
      while (lines[line].match(/^\;/))
        line++;
      if (lines[line].toString("ascii").match(/\. IN KEY /))
        return true;
      if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
        return true;
      return false;
    }
    function write(key, options) {
      throw new Error('"auto" format cannot be used for writing');
    }
  }
});

// node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS({
  "node_modules/sshpk/lib/private-key.js"(exports, module) {
    module.exports = PrivateKey;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors();
    var util = (init_util(), __toCommonJS(util_exports));
    var utils = require_utils();
    var dhe = require_dhe();
    var generateECDSA = dhe.generateECDSA;
    var generateED25519 = dhe.generateED25519;
    var edCompat = require_ed_compat();
    var nacl = require_nacl_fast();
    var Key = require_key();
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var KeyParseError = errs.KeyParseError;
    var KeyEncryptedError = errs.KeyEncryptedError;
    var formats = {};
    formats["auto"] = require_auto();
    formats["pem"] = require_pem();
    formats["pkcs1"] = require_pkcs1();
    formats["pkcs8"] = require_pkcs8();
    formats["rfc4253"] = require_rfc4253();
    formats["ssh-private"] = require_ssh_private();
    formats["openssh"] = formats["ssh-private"];
    formats["ssh"] = formats["ssh-private"];
    formats["dnssec"] = require_dnssec();
    formats["putty"] = require_putty();
    function PrivateKey(opts) {
      assert.object(opts, "options");
      Key.call(this, opts);
      this._pubCache = void 0;
    }
    util.inherits(PrivateKey, Key);
    PrivateKey.formats = formats;
    PrivateKey.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "pkcs1";
      assert.string(format, "format");
      assert.object(formats[format], "formats[format]");
      assert.optionalObject(options, "options");
      return formats[format].write(this, options);
    };
    PrivateKey.prototype.hash = function(algo, type) {
      return this.toPublic().hash(algo, type);
    };
    PrivateKey.prototype.fingerprint = function(algo, type) {
      return this.toPublic().fingerprint(algo, type);
    };
    PrivateKey.prototype.toPublic = function() {
      if (this._pubCache)
        return this._pubCache;
      var algInfo = algs.info[this.type];
      var pubParts = [];
      for (var i = 0; i < algInfo.parts.length; ++i) {
        var p = algInfo.parts[i];
        pubParts.push(this.part[p]);
      }
      this._pubCache = new Key({
        type: this.type,
        source: this,
        parts: pubParts
      });
      if (this.comment)
        this._pubCache.comment = this.comment;
      return this._pubCache;
    };
    PrivateKey.prototype.derive = function(newType) {
      assert.string(newType, "type");
      var priv, pub, pair;
      if (this.type === "ed25519" && newType === "curve25519") {
        priv = this.part.k.data;
        if (priv[0] === 0)
          priv = priv.slice(1);
        pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
        pub = Buffer2.from(pair.publicKey);
        return new PrivateKey({
          type: "curve25519",
          parts: [
            { name: "A", data: utils.mpNormalize(pub) },
            { name: "k", data: utils.mpNormalize(priv) }
          ]
        });
      } else if (this.type === "curve25519" && newType === "ed25519") {
        priv = this.part.k.data;
        if (priv[0] === 0)
          priv = priv.slice(1);
        pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
        pub = Buffer2.from(pair.publicKey);
        return new PrivateKey({
          type: "ed25519",
          parts: [
            { name: "A", data: utils.mpNormalize(pub) },
            { name: "k", data: utils.mpNormalize(priv) }
          ]
        });
      }
      throw new Error("Key derivation not supported from " + this.type + " to " + newType);
    };
    PrivateKey.prototype.createVerify = function(hashAlgo) {
      return this.toPublic().createVerify(hashAlgo);
    };
    PrivateKey.prototype.createSign = function(hashAlgo) {
      if (hashAlgo === void 0)
        hashAlgo = this.defaultHashAlgorithm();
      assert.string(hashAlgo, "hash algorithm");
      if (this.type === "ed25519" && edCompat !== void 0)
        return new edCompat.Signer(this, hashAlgo);
      if (this.type === "curve25519")
        throw new Error("Curve25519 keys are not suitable for signing or verification");
      var v, nm, err;
      try {
        nm = hashAlgo.toUpperCase();
        v = crypto.createSign(nm);
      } catch (e) {
        err = e;
      }
      if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
        nm = "RSA-";
        nm += hashAlgo.toUpperCase();
        v = crypto.createSign(nm);
      }
      assert.ok(v, "failed to create verifier");
      var oldSign = v.sign.bind(v);
      var key = this.toBuffer("pkcs1");
      var type = this.type;
      var curve = this.curve;
      v.sign = function() {
        var sig = oldSign(key);
        if (typeof sig === "string")
          sig = Buffer2.from(sig, "binary");
        sig = Signature.parse(sig, type, "asn1");
        sig.hashAlgorithm = hashAlgo;
        sig.curve = curve;
        return sig;
      };
      return v;
    };
    PrivateKey.parse = function(data, format, options) {
      if (typeof data !== "string")
        assert.buffer(data, "data");
      if (format === void 0)
        format = "auto";
      assert.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data, options);
        assert.ok(k instanceof PrivateKey, "key is not a private key");
        if (!k.comment)
          k.comment = options.filename;
        return k;
      } catch (e) {
        if (e.name === "KeyEncryptedError")
          throw e;
        throw new KeyParseError(options.filename, format, e);
      }
    };
    PrivateKey.isPrivateKey = function(obj, ver) {
      return utils.isCompatible(obj, PrivateKey, ver);
    };
    PrivateKey.generate = function(type, options) {
      if (options === void 0)
        options = {};
      assert.object(options, "options");
      switch (type) {
        case "ecdsa":
          if (options.curve === void 0)
            options.curve = "nistp256";
          assert.string(options.curve, "options.curve");
          return generateECDSA(options.curve);
        case "ed25519":
          return generateED25519();
        default:
          throw new Error('Key generation not supported with key type "' + type + '"');
      }
    };
    PrivateKey.prototype._sshpkApiVersion = [1, 6];
    PrivateKey._oldVersionDetect = function(obj) {
      assert.func(obj.toPublic);
      assert.func(obj.createSign);
      if (obj.derive)
        return [1, 3];
      if (obj.defaultHashAlgorithm)
        return [1, 2];
      if (obj.formats["auto"])
        return [1, 1];
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/identity.js
var require_identity = __commonJS({
  "node_modules/sshpk/lib/identity.js"(exports, module) {
    module.exports = Identity;
    var assert = require_assert();
    var algs = require_algs();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors();
    var util = (init_util(), __toCommonJS(util_exports));
    var utils = require_utils();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
    var oids = {};
    oids.cn = "2.5.4.3";
    oids.o = "2.5.4.10";
    oids.ou = "2.5.4.11";
    oids.l = "2.5.4.7";
    oids.s = "2.5.4.8";
    oids.c = "2.5.4.6";
    oids.sn = "2.5.4.4";
    oids.postalCode = "2.5.4.17";
    oids.serialNumber = "2.5.4.5";
    oids.street = "2.5.4.9";
    oids.x500UniqueIdentifier = "2.5.4.45";
    oids.role = "2.5.4.72";
    oids.telephoneNumber = "2.5.4.20";
    oids.description = "2.5.4.13";
    oids.dc = "0.9.2342.19200300.100.1.25";
    oids.uid = "0.9.2342.19200300.100.1.1";
    oids.mail = "0.9.2342.19200300.100.1.3";
    oids.title = "2.5.4.12";
    oids.gn = "2.5.4.42";
    oids.initials = "2.5.4.43";
    oids.pseudonym = "2.5.4.65";
    oids.emailAddress = "1.2.840.113549.1.9.1";
    var unoids = {};
    Object.keys(oids).forEach(function(k) {
      unoids[oids[k]] = k;
    });
    function Identity(opts) {
      var self2 = this;
      assert.object(opts, "options");
      assert.arrayOfObject(opts.components, "options.components");
      this.components = opts.components;
      this.componentLookup = {};
      this.components.forEach(function(c) {
        if (c.name && !c.oid)
          c.oid = oids[c.name];
        if (c.oid && !c.name)
          c.name = unoids[c.oid];
        if (self2.componentLookup[c.name] === void 0)
          self2.componentLookup[c.name] = [];
        self2.componentLookup[c.name].push(c);
      });
      if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
        this.cn = this.componentLookup.cn[0].value;
      }
      assert.optionalString(opts.type, "options.type");
      if (opts.type === void 0) {
        if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
          this.type = "host";
          this.hostname = this.componentLookup.cn[0].value;
        } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
          this.type = "host";
          this.hostname = this.componentLookup.dc.map(function(c) {
            return c.value;
          }).join(".");
        } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
          this.type = "user";
          this.uid = this.componentLookup.uid[0].value;
        } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
          this.type = "host";
          this.hostname = this.componentLookup.cn[0].value;
        } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
          this.type = "user";
          this.uid = this.componentLookup.uid[0].value;
        } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
          this.type = "email";
          this.email = this.componentLookup.mail[0].value;
        } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
          this.type = "user";
          this.uid = this.componentLookup.cn[0].value;
        } else {
          this.type = "unknown";
        }
      } else {
        this.type = opts.type;
        if (this.type === "host")
          this.hostname = opts.hostname;
        else if (this.type === "user")
          this.uid = opts.uid;
        else if (this.type === "email")
          this.email = opts.email;
        else
          throw new Error("Unknown type " + this.type);
      }
    }
    Identity.prototype.toString = function() {
      return this.components.map(function(c) {
        var n = c.name.toUpperCase();
        n = n.replace(/=/g, "\\=");
        var v = c.value;
        v = v.replace(/,/g, "\\,");
        return n + "=" + v;
      }).join(", ");
    };
    Identity.prototype.get = function(name, asArray) {
      assert.string(name, "name");
      var arr = this.componentLookup[name];
      if (arr === void 0 || arr.length === 0)
        return void 0;
      if (!asArray && arr.length > 1)
        throw new Error("Multiple values for attribute " + name);
      if (!asArray)
        return arr[0].value;
      return arr.map(function(c) {
        return c.value;
      });
    };
    Identity.prototype.toArray = function(idx) {
      return this.components.map(function(c) {
        return {
          name: c.name,
          value: c.value
        };
      });
    };
    var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
    var NOT_IA5 = /[^\x00-\x7f]/;
    Identity.prototype.toAsn1 = function(der, tag) {
      der.startSequence(tag);
      this.components.forEach(function(c) {
        der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
        der.startSequence();
        der.writeOID(c.oid);
        if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
          var v = Buffer2.from(c.value, "utf8");
          der.writeBuffer(v, asn1.Ber.Utf8String);
        } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
          der.writeString(c.value, asn1.Ber.IA5String);
        } else {
          var type = asn1.Ber.PrintableString;
          if (c.asn1type !== void 0)
            type = c.asn1type;
          der.writeString(c.value, type);
        }
        der.endSequence();
        der.endSequence();
      });
      der.endSequence();
    };
    function globMatch(a, b) {
      if (a === "**" || b === "**")
        return true;
      var aParts = a.split(".");
      var bParts = b.split(".");
      if (aParts.length !== bParts.length)
        return false;
      for (var i = 0; i < aParts.length; ++i) {
        if (aParts[i] === "*" || bParts[i] === "*")
          continue;
        if (aParts[i] !== bParts[i])
          return false;
      }
      return true;
    }
    Identity.prototype.equals = function(other) {
      if (!Identity.isIdentity(other, [1, 0]))
        return false;
      if (other.components.length !== this.components.length)
        return false;
      for (var i = 0; i < this.components.length; ++i) {
        if (this.components[i].oid !== other.components[i].oid)
          return false;
        if (!globMatch(this.components[i].value, other.components[i].value)) {
          return false;
        }
      }
      return true;
    };
    Identity.forHost = function(hostname) {
      assert.string(hostname, "hostname");
      return new Identity({
        type: "host",
        hostname,
        components: [{ name: "cn", value: hostname }]
      });
    };
    Identity.forUser = function(uid) {
      assert.string(uid, "uid");
      return new Identity({
        type: "user",
        uid,
        components: [{ name: "uid", value: uid }]
      });
    };
    Identity.forEmail = function(email) {
      assert.string(email, "email");
      return new Identity({
        type: "email",
        email,
        components: [{ name: "mail", value: email }]
      });
    };
    Identity.parseDN = function(dn) {
      assert.string(dn, "dn");
      var parts = [""];
      var idx = 0;
      var rem = dn;
      while (rem.length > 0) {
        var m;
        if ((m = /^,/.exec(rem)) !== null) {
          parts[++idx] = "";
          rem = rem.slice(m[0].length);
        } else if ((m = /^\\,/.exec(rem)) !== null) {
          parts[idx] += ",";
          rem = rem.slice(m[0].length);
        } else if ((m = /^\\./.exec(rem)) !== null) {
          parts[idx] += m[0];
          rem = rem.slice(m[0].length);
        } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
          parts[idx] += m[0];
          rem = rem.slice(m[0].length);
        } else {
          throw new Error("Failed to parse DN");
        }
      }
      var cmps = parts.map(function(c) {
        c = c.trim();
        var eqPos = c.indexOf("=");
        while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
          eqPos = c.indexOf("=", eqPos + 1);
        if (eqPos === -1) {
          throw new Error("Failed to parse DN");
        }
        var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
        var value = c.slice(eqPos + 1);
        return { name, value };
      });
      return new Identity({ components: cmps });
    };
    Identity.fromArray = function(components) {
      assert.arrayOfObject(components, "components");
      components.forEach(function(cmp) {
        assert.object(cmp, "component");
        assert.string(cmp.name, "component.name");
        if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
          throw new Error("Invalid component value");
        }
      });
      return new Identity({ components });
    };
    Identity.parseAsn1 = function(der, top) {
      var components = [];
      der.readSequence(top);
      var end = der.offset + der.length;
      while (der.offset < end) {
        der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
        var after = der.offset + der.length;
        der.readSequence();
        var oid = der.readOID();
        var type = der.peek();
        var value;
        switch (type) {
          case asn1.Ber.PrintableString:
          case asn1.Ber.IA5String:
          case asn1.Ber.OctetString:
          case asn1.Ber.T61String:
            value = der.readString(type);
            break;
          case asn1.Ber.Utf8String:
            value = der.readString(type, true);
            value = value.toString("utf8");
            break;
          case asn1.Ber.CharacterString:
          case asn1.Ber.BMPString:
            value = der.readString(type, true);
            value = value.toString("utf16le");
            break;
          default:
            throw new Error("Unknown asn1 type " + type);
        }
        components.push({ oid, asn1type: type, value });
        der._offset = after;
      }
      der._offset = end;
      return new Identity({
        components
      });
    };
    Identity.isIdentity = function(obj, ver) {
      return utils.isCompatible(obj, Identity, ver);
    };
    Identity.prototype._sshpkApiVersion = [1, 0];
    Identity._oldVersionDetect = function(obj) {
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS({
  "node_modules/sshpk/lib/formats/openssh-cert.js"(exports, module) {
    module.exports = {
      read,
      verify,
      sign,
      signAsync,
      write,
      fromBuffer,
      toBuffer
    };
    var assert = require_assert();
    var SSHBuffer = require_ssh_buffer();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Identity = require_identity();
    var rfc4253 = require_rfc4253();
    var Signature = require_signature();
    var utils = require_utils();
    var Certificate = require_certificate();
    function verify(cert, key) {
      return false;
    }
    var TYPES = {
      "user": 1,
      "host": 2
    };
    Object.keys(TYPES).forEach(function(k) {
      TYPES[TYPES[k]] = k;
    });
    var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
    function read(buf, options) {
      if (Buffer2.isBuffer(buf))
        buf = buf.toString("ascii");
      var parts = buf.trim().split(/[ \t\n]+/g);
      if (parts.length < 2 || parts.length > 3)
        throw new Error("Not a valid SSH certificate line");
      var algo = parts[0];
      var data = parts[1];
      data = Buffer2.from(data, "base64");
      return fromBuffer(data, algo);
    }
    function fromBuffer(data, algo, partial) {
      var sshbuf = new SSHBuffer({ buffer: data });
      var innerAlgo = sshbuf.readString();
      if (algo !== void 0 && innerAlgo !== algo)
        throw new Error("SSH certificate algorithm mismatch");
      if (algo === void 0)
        algo = innerAlgo;
      var cert = {};
      cert.signatures = {};
      cert.signatures.openssh = {};
      cert.signatures.openssh.nonce = sshbuf.readBuffer();
      var key = {};
      var parts = key.parts = [];
      key.type = getAlg(algo);
      var partCount = algs.info[key.type].parts.length;
      while (parts.length < partCount)
        parts.push(sshbuf.readPart());
      assert.ok(parts.length >= 1, "key must have at least one part");
      var algInfo = algs.info[key.type];
      if (key.type === "ecdsa") {
        var res = ECDSA_ALGO.exec(algo);
        assert.ok(res !== null);
        assert.strictEqual(res[1], parts[0].data.toString());
      }
      for (var i = 0; i < algInfo.parts.length; ++i) {
        parts[i].name = algInfo.parts[i];
        if (parts[i].name !== "curve" && algInfo.normalize !== false) {
          var p = parts[i];
          p.data = utils.mpNormalize(p.data);
        }
      }
      cert.subjectKey = new Key(key);
      cert.serial = sshbuf.readInt64();
      var type = TYPES[sshbuf.readInt()];
      assert.string(type, "valid cert type");
      cert.signatures.openssh.keyId = sshbuf.readString();
      var principals = [];
      var pbuf = sshbuf.readBuffer();
      var psshbuf = new SSHBuffer({ buffer: pbuf });
      while (!psshbuf.atEnd())
        principals.push(psshbuf.readString());
      if (principals.length === 0)
        principals = ["*"];
      cert.subjects = principals.map(function(pr) {
        if (type === "user")
          return Identity.forUser(pr);
        else if (type === "host")
          return Identity.forHost(pr);
        throw new Error("Unknown identity type " + type);
      });
      cert.validFrom = int64ToDate(sshbuf.readInt64());
      cert.validUntil = int64ToDate(sshbuf.readInt64());
      var exts = [];
      var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
      var ext;
      while (!extbuf.atEnd()) {
        ext = { critical: true };
        ext.name = extbuf.readString();
        ext.data = extbuf.readBuffer();
        exts.push(ext);
      }
      extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
      while (!extbuf.atEnd()) {
        ext = { critical: false };
        ext.name = extbuf.readString();
        ext.data = extbuf.readBuffer();
        exts.push(ext);
      }
      cert.signatures.openssh.exts = exts;
      sshbuf.readBuffer();
      var signingKeyBuf = sshbuf.readBuffer();
      cert.issuerKey = rfc4253.read(signingKeyBuf);
      cert.issuer = Identity.forHost("**");
      var sigBuf = sshbuf.readBuffer();
      cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
      if (partial !== void 0) {
        partial.remainder = sshbuf.remainder();
        partial.consumed = sshbuf._offset;
      }
      return new Certificate(cert);
    }
    function int64ToDate(buf) {
      var i = buf.readUInt32BE(0) * 4294967296;
      i += buf.readUInt32BE(4);
      var d = new Date();
      d.setTime(i * 1e3);
      d.sourceInt64 = buf;
      return d;
    }
    function dateToInt64(date) {
      if (date.sourceInt64 !== void 0)
        return date.sourceInt64;
      var i = Math.round(date.getTime() / 1e3);
      var upper = Math.floor(i / 4294967296);
      var lower = Math.floor(i % 4294967296);
      var buf = Buffer2.alloc(8);
      buf.writeUInt32BE(upper, 0);
      buf.writeUInt32BE(lower, 4);
      return buf;
    }
    function sign(cert, key) {
      if (cert.signatures.openssh === void 0)
        cert.signatures.openssh = {};
      try {
        var blob = toBuffer(cert, true);
      } catch (e) {
        delete cert.signatures.openssh;
        return false;
      }
      var sig = cert.signatures.openssh;
      var hashAlgo = void 0;
      if (key.type === "rsa" || key.type === "dsa")
        hashAlgo = "sha1";
      var signer = key.createSign(hashAlgo);
      signer.write(blob);
      sig.signature = signer.sign();
      return true;
    }
    function signAsync(cert, signer, done) {
      if (cert.signatures.openssh === void 0)
        cert.signatures.openssh = {};
      try {
        var blob = toBuffer(cert, true);
      } catch (e) {
        delete cert.signatures.openssh;
        done(e);
        return;
      }
      var sig = cert.signatures.openssh;
      signer(blob, function(err, signature) {
        if (err) {
          done(err);
          return;
        }
        try {
          signature.toBuffer("ssh");
        } catch (e) {
          done(e);
          return;
        }
        sig.signature = signature;
        done();
      });
    }
    function write(cert, options) {
      if (options === void 0)
        options = {};
      var blob = toBuffer(cert);
      var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
      if (options.comment)
        out = out + " " + options.comment;
      return out;
    }
    function toBuffer(cert, noSig) {
      assert.object(cert.signatures.openssh, "signature for openssh format");
      var sig = cert.signatures.openssh;
      if (sig.nonce === void 0)
        sig.nonce = crypto.randomBytes(16);
      var buf = new SSHBuffer({});
      buf.writeString(getCertType(cert.subjectKey));
      buf.writeBuffer(sig.nonce);
      var key = cert.subjectKey;
      var algInfo = algs.info[key.type];
      algInfo.parts.forEach(function(part) {
        buf.writePart(key.part[part]);
      });
      buf.writeInt64(cert.serial);
      var type = cert.subjects[0].type;
      assert.notStrictEqual(type, "unknown");
      cert.subjects.forEach(function(id) {
        assert.strictEqual(id.type, type);
      });
      type = TYPES[type];
      buf.writeInt(type);
      if (sig.keyId === void 0) {
        sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
      }
      buf.writeString(sig.keyId);
      var sub = new SSHBuffer({});
      cert.subjects.forEach(function(id) {
        if (type === TYPES.host)
          sub.writeString(id.hostname);
        else if (type === TYPES.user)
          sub.writeString(id.uid);
      });
      buf.writeBuffer(sub.toBuffer());
      buf.writeInt64(dateToInt64(cert.validFrom));
      buf.writeInt64(dateToInt64(cert.validUntil));
      var exts = sig.exts;
      if (exts === void 0)
        exts = [];
      var extbuf = new SSHBuffer({});
      exts.forEach(function(ext) {
        if (ext.critical !== true)
          return;
        extbuf.writeString(ext.name);
        extbuf.writeBuffer(ext.data);
      });
      buf.writeBuffer(extbuf.toBuffer());
      extbuf = new SSHBuffer({});
      exts.forEach(function(ext) {
        if (ext.critical === true)
          return;
        extbuf.writeString(ext.name);
        extbuf.writeBuffer(ext.data);
      });
      buf.writeBuffer(extbuf.toBuffer());
      buf.writeBuffer(Buffer2.alloc(0));
      sub = rfc4253.write(cert.issuerKey);
      buf.writeBuffer(sub);
      if (!noSig)
        buf.writeBuffer(sig.signature.toBuffer("ssh"));
      return buf.toBuffer();
    }
    function getAlg(certType) {
      if (certType === "ssh-rsa-cert-v01@openssh.com")
        return "rsa";
      if (certType === "ssh-dss-cert-v01@openssh.com")
        return "dsa";
      if (certType.match(ECDSA_ALGO))
        return "ecdsa";
      if (certType === "ssh-ed25519-cert-v01@openssh.com")
        return "ed25519";
      throw new Error("Unsupported cert type " + certType);
    }
    function getCertType(key) {
      if (key.type === "rsa")
        return "ssh-rsa-cert-v01@openssh.com";
      if (key.type === "dsa")
        return "ssh-dss-cert-v01@openssh.com";
      if (key.type === "ecdsa")
        return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
      if (key.type === "ed25519")
        return "ssh-ed25519-cert-v01@openssh.com";
      throw new Error("Unsupported key type " + key.type);
    }
  }
});

// node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS({
  "node_modules/sshpk/lib/formats/x509.js"(exports, module) {
    module.exports = {
      read,
      verify,
      sign,
      signAsync,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var Identity = require_identity();
    var Signature = require_signature();
    var Certificate = require_certificate();
    var pkcs8 = require_pkcs8();
    function readMPInt(der, nm) {
      assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function verify(cert, key) {
      var sig = cert.signatures.x509;
      assert.object(sig, "x509 signature");
      var algParts = sig.algo.split("-");
      if (algParts[0] !== key.type)
        return false;
      var blob = sig.cache;
      if (blob === void 0) {
        var der = new asn1.BerWriter();
        writeTBSCert(cert, der);
        blob = der.buffer;
      }
      var verifier = key.createVerify(algParts[1]);
      verifier.write(blob);
      return verifier.verify(sig.signature);
    }
    function Local(i) {
      return asn1.Ber.Context | asn1.Ber.Constructor | i;
    }
    function Context(i) {
      return asn1.Ber.Context | i;
    }
    var SIGN_ALGS = {
      "rsa-md5": "1.2.840.113549.1.1.4",
      "rsa-sha1": "1.2.840.113549.1.1.5",
      "rsa-sha256": "1.2.840.113549.1.1.11",
      "rsa-sha384": "1.2.840.113549.1.1.12",
      "rsa-sha512": "1.2.840.113549.1.1.13",
      "dsa-sha1": "1.2.840.10040.4.3",
      "dsa-sha256": "2.16.840.1.101.3.4.3.2",
      "ecdsa-sha1": "1.2.840.10045.4.1",
      "ecdsa-sha256": "1.2.840.10045.4.3.2",
      "ecdsa-sha384": "1.2.840.10045.4.3.3",
      "ecdsa-sha512": "1.2.840.10045.4.3.4",
      "ed25519-sha512": "1.3.101.112"
    };
    Object.keys(SIGN_ALGS).forEach(function(k) {
      SIGN_ALGS[SIGN_ALGS[k]] = k;
    });
    SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
    SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
    var EXTS = {
      "issuerKeyId": "2.5.29.35",
      "altName": "2.5.29.17",
      "basicConstraints": "2.5.29.19",
      "keyUsage": "2.5.29.15",
      "extKeyUsage": "2.5.29.37"
    };
    function read(buf, options) {
      if (typeof buf === "string") {
        buf = Buffer2.from(buf, "binary");
      }
      assert.buffer(buf, "buf");
      var der = new asn1.BerReader(buf);
      der.readSequence();
      if (Math.abs(der.length - der.remain) > 1) {
        throw new Error("DER sequence does not contain whole byte stream");
      }
      var tbsStart = der.offset;
      der.readSequence();
      var sigOffset = der.offset + der.length;
      var tbsEnd = sigOffset;
      if (der.peek() === Local(0)) {
        der.readSequence(Local(0));
        var version = der.readInt();
        assert.ok(version <= 3, "only x.509 versions up to v3 supported");
      }
      var cert = {};
      cert.signatures = {};
      var sig = cert.signatures.x509 = {};
      sig.extras = {};
      cert.serial = readMPInt(der, "serial");
      der.readSequence();
      var after = der.offset + der.length;
      var certAlgOid = der.readOID();
      var certAlg = SIGN_ALGS[certAlgOid];
      if (certAlg === void 0)
        throw new Error("unknown signature algorithm " + certAlgOid);
      der._offset = after;
      cert.issuer = Identity.parseAsn1(der);
      der.readSequence();
      cert.validFrom = readDate(der);
      cert.validUntil = readDate(der);
      cert.subjects = [Identity.parseAsn1(der)];
      der.readSequence();
      after = der.offset + der.length;
      cert.subjectKey = pkcs8.readPkcs8(void 0, "public", der);
      der._offset = after;
      if (der.peek() === Local(1)) {
        der.readSequence(Local(1));
        sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
      }
      if (der.peek() === Local(2)) {
        der.readSequence(Local(2));
        sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
      }
      if (der.peek() === Local(3)) {
        der.readSequence(Local(3));
        var extEnd = der.offset + der.length;
        der.readSequence();
        while (der.offset < extEnd)
          readExtension(cert, buf, der);
        assert.strictEqual(der.offset, extEnd);
      }
      assert.strictEqual(der.offset, sigOffset);
      der.readSequence();
      after = der.offset + der.length;
      var sigAlgOid = der.readOID();
      var sigAlg = SIGN_ALGS[sigAlgOid];
      if (sigAlg === void 0)
        throw new Error("unknown signature algorithm " + sigAlgOid);
      der._offset = after;
      var sigData = der.readString(asn1.Ber.BitString, true);
      if (sigData[0] === 0)
        sigData = sigData.slice(1);
      var algParts = sigAlg.split("-");
      sig.signature = Signature.parse(sigData, algParts[0], "asn1");
      sig.signature.hashAlgorithm = algParts[1];
      sig.algo = sigAlg;
      sig.cache = buf.slice(tbsStart, tbsEnd);
      return new Certificate(cert);
    }
    function readDate(der) {
      if (der.peek() === asn1.Ber.UTCTime) {
        return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
      } else if (der.peek() === asn1.Ber.GeneralizedTime) {
        return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
      } else {
        throw new Error("Unsupported date format");
      }
    }
    function writeDate(der, date) {
      if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
        der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
      } else {
        der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
      }
    }
    var ALTNAME = {
      OtherName: Local(0),
      RFC822Name: Context(1),
      DNSName: Context(2),
      X400Address: Local(3),
      DirectoryName: Local(4),
      EDIPartyName: Local(5),
      URI: Context(6),
      IPAddress: Context(7),
      OID: Context(8)
    };
    var EXTPURPOSE = {
      "serverAuth": "1.3.6.1.5.5.7.3.1",
      "clientAuth": "1.3.6.1.5.5.7.3.2",
      "codeSigning": "1.3.6.1.5.5.7.3.3",
      "joyentDocker": "1.3.6.1.4.1.38678.1.4.1",
      "joyentCmon": "1.3.6.1.4.1.38678.1.4.2"
    };
    var EXTPURPOSE_REV = {};
    Object.keys(EXTPURPOSE).forEach(function(k) {
      EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
    });
    var KEYUSEBITS = [
      "signature",
      "identity",
      "keyEncryption",
      "encryption",
      "keyAgreement",
      "ca",
      "crl"
    ];
    function readExtension(cert, buf, der) {
      der.readSequence();
      var after = der.offset + der.length;
      var extId = der.readOID();
      var id;
      var sig = cert.signatures.x509;
      if (!sig.extras.exts)
        sig.extras.exts = [];
      var critical;
      if (der.peek() === asn1.Ber.Boolean)
        critical = der.readBoolean();
      switch (extId) {
        case EXTS.basicConstraints:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          var bcEnd = der.offset + der.length;
          var ca = false;
          if (der.peek() === asn1.Ber.Boolean)
            ca = der.readBoolean();
          if (cert.purposes === void 0)
            cert.purposes = [];
          if (ca === true)
            cert.purposes.push("ca");
          var bc = { oid: extId, critical };
          if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
            bc.pathLen = der.readInt();
          sig.extras.exts.push(bc);
          break;
        case EXTS.extKeyUsage:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          if (cert.purposes === void 0)
            cert.purposes = [];
          var ekEnd = der.offset + der.length;
          while (der.offset < ekEnd) {
            var oid = der.readOID();
            cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
          }
          if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
            cert.subjects.forEach(function(ide) {
              if (ide.type !== "host") {
                ide.type = "host";
                ide.hostname = ide.uid || ide.email || ide.components[0].value;
              }
            });
          } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
            cert.subjects.forEach(function(ide) {
              if (ide.type !== "user") {
                ide.type = "user";
                ide.uid = ide.hostname || ide.email || ide.components[0].value;
              }
            });
          }
          sig.extras.exts.push({ oid: extId, critical });
          break;
        case EXTS.keyUsage:
          der.readSequence(asn1.Ber.OctetString);
          var bits = der.readString(asn1.Ber.BitString, true);
          var setBits = readBitField(bits, KEYUSEBITS);
          setBits.forEach(function(bit) {
            if (cert.purposes === void 0)
              cert.purposes = [];
            if (cert.purposes.indexOf(bit) === -1)
              cert.purposes.push(bit);
          });
          sig.extras.exts.push({
            oid: extId,
            critical,
            bits
          });
          break;
        case EXTS.altName:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          var aeEnd = der.offset + der.length;
          while (der.offset < aeEnd) {
            switch (der.peek()) {
              case ALTNAME.OtherName:
              case ALTNAME.EDIPartyName:
                der.readSequence();
                der._offset += der.length;
                break;
              case ALTNAME.OID:
                der.readOID(ALTNAME.OID);
                break;
              case ALTNAME.RFC822Name:
                var email = der.readString(ALTNAME.RFC822Name);
                id = Identity.forEmail(email);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              case ALTNAME.DirectoryName:
                der.readSequence(ALTNAME.DirectoryName);
                id = Identity.parseAsn1(der);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              case ALTNAME.DNSName:
                var host = der.readString(ALTNAME.DNSName);
                id = Identity.forHost(host);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              default:
                der.readString(der.peek());
                break;
            }
          }
          sig.extras.exts.push({ oid: extId, critical });
          break;
        default:
          sig.extras.exts.push({
            oid: extId,
            critical,
            data: der.readString(asn1.Ber.OctetString, true)
          });
          break;
      }
      der._offset = after;
    }
    var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
    function utcTimeToDate(t) {
      var m = t.match(UTCTIME_RE);
      assert.ok(m, "timestamps must be in UTC");
      var d = new Date();
      var thisYear = d.getUTCFullYear();
      var century = Math.floor(thisYear / 100) * 100;
      var year = parseInt(m[1], 10);
      if (thisYear % 100 < 50 && year >= 60)
        year += century - 1;
      else
        year += century;
      d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
      d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
      if (m[6] && m[6].length > 0)
        d.setUTCSeconds(parseInt(m[6], 10));
      return d;
    }
    var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
    function gTimeToDate(t) {
      var m = t.match(GTIME_RE);
      assert.ok(m);
      var d = new Date();
      d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
      d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
      if (m[6] && m[6].length > 0)
        d.setUTCSeconds(parseInt(m[6], 10));
      return d;
    }
    function zeroPad(n, m) {
      if (m === void 0)
        m = 2;
      var s = "" + n;
      while (s.length < m)
        s = "0" + s;
      return s;
    }
    function dateToUTCTime(d) {
      var s = "";
      s += zeroPad(d.getUTCFullYear() % 100);
      s += zeroPad(d.getUTCMonth() + 1);
      s += zeroPad(d.getUTCDate());
      s += zeroPad(d.getUTCHours());
      s += zeroPad(d.getUTCMinutes());
      s += zeroPad(d.getUTCSeconds());
      s += "Z";
      return s;
    }
    function dateToGTime(d) {
      var s = "";
      s += zeroPad(d.getUTCFullYear(), 4);
      s += zeroPad(d.getUTCMonth() + 1);
      s += zeroPad(d.getUTCDate());
      s += zeroPad(d.getUTCHours());
      s += zeroPad(d.getUTCMinutes());
      s += zeroPad(d.getUTCSeconds());
      s += "Z";
      return s;
    }
    function sign(cert, key) {
      if (cert.signatures.x509 === void 0)
        cert.signatures.x509 = {};
      var sig = cert.signatures.x509;
      sig.algo = key.type + "-" + key.defaultHashAlgorithm();
      if (SIGN_ALGS[sig.algo] === void 0)
        return false;
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      var blob = der.buffer;
      sig.cache = blob;
      var signer = key.createSign();
      signer.write(blob);
      cert.signatures.x509.signature = signer.sign();
      return true;
    }
    function signAsync(cert, signer, done) {
      if (cert.signatures.x509 === void 0)
        cert.signatures.x509 = {};
      var sig = cert.signatures.x509;
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      var blob = der.buffer;
      sig.cache = blob;
      signer(blob, function(err, signature) {
        if (err) {
          done(err);
          return;
        }
        sig.algo = signature.type + "-" + signature.hashAlgorithm;
        if (SIGN_ALGS[sig.algo] === void 0) {
          done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
          return;
        }
        sig.signature = signature;
        done();
      });
    }
    function write(cert, options) {
      var sig = cert.signatures.x509;
      assert.object(sig, "x509 signature");
      var der = new asn1.BerWriter();
      der.startSequence();
      if (sig.cache) {
        der._ensure(sig.cache.length);
        sig.cache.copy(der._buf, der._offset);
        der._offset += sig.cache.length;
      } else {
        writeTBSCert(cert, der);
      }
      der.startSequence();
      der.writeOID(SIGN_ALGS[sig.algo]);
      if (sig.algo.match(/^rsa-/))
        der.writeNull();
      der.endSequence();
      var sigData = sig.signature.toBuffer("asn1");
      var data = Buffer2.alloc(sigData.length + 1);
      data[0] = 0;
      sigData.copy(data, 1);
      der.writeBuffer(data, asn1.Ber.BitString);
      der.endSequence();
      return der.buffer;
    }
    function writeTBSCert(cert, der) {
      var sig = cert.signatures.x509;
      assert.object(sig, "x509 signature");
      der.startSequence();
      der.startSequence(Local(0));
      der.writeInt(2);
      der.endSequence();
      der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
      der.startSequence();
      der.writeOID(SIGN_ALGS[sig.algo]);
      if (sig.algo.match(/^rsa-/))
        der.writeNull();
      der.endSequence();
      cert.issuer.toAsn1(der);
      der.startSequence();
      writeDate(der, cert.validFrom);
      writeDate(der, cert.validUntil);
      der.endSequence();
      var subject = cert.subjects[0];
      var altNames = cert.subjects.slice(1);
      subject.toAsn1(der);
      pkcs8.writePkcs8(der, cert.subjectKey);
      if (sig.extras && sig.extras.issuerUniqueID) {
        der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
      }
      if (sig.extras && sig.extras.subjectUniqueID) {
        der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
      }
      if (altNames.length > 0 || subject.type === "host" || cert.purposes !== void 0 && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
        der.startSequence(Local(3));
        der.startSequence();
        var exts = [];
        if (cert.purposes !== void 0 && cert.purposes.length > 0) {
          exts.push({
            oid: EXTS.basicConstraints,
            critical: true
          });
          exts.push({
            oid: EXTS.keyUsage,
            critical: true
          });
          exts.push({
            oid: EXTS.extKeyUsage,
            critical: true
          });
        }
        exts.push({ oid: EXTS.altName });
        if (sig.extras && sig.extras.exts)
          exts = sig.extras.exts;
        for (var i = 0; i < exts.length; ++i) {
          der.startSequence();
          der.writeOID(exts[i].oid);
          if (exts[i].critical !== void 0)
            der.writeBoolean(exts[i].critical);
          if (exts[i].oid === EXTS.altName) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            if (subject.type === "host") {
              der.writeString(subject.hostname, Context(2));
            }
            for (var j = 0; j < altNames.length; ++j) {
              if (altNames[j].type === "host") {
                der.writeString(altNames[j].hostname, ALTNAME.DNSName);
              } else if (altNames[j].type === "email") {
                der.writeString(altNames[j].email, ALTNAME.RFC822Name);
              } else {
                der.startSequence(ALTNAME.DirectoryName);
                altNames[j].toAsn1(der);
                der.endSequence();
              }
            }
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.basicConstraints) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            var ca = cert.purposes.indexOf("ca") !== -1;
            var pathLen = exts[i].pathLen;
            der.writeBoolean(ca);
            if (pathLen !== void 0)
              der.writeInt(pathLen);
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.extKeyUsage) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            cert.purposes.forEach(function(purpose) {
              if (purpose === "ca")
                return;
              if (KEYUSEBITS.indexOf(purpose) !== -1)
                return;
              var oid = purpose;
              if (EXTPURPOSE[purpose] !== void 0)
                oid = EXTPURPOSE[purpose];
              der.writeOID(oid);
            });
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.keyUsage) {
            der.startSequence(asn1.Ber.OctetString);
            if (exts[i].bits !== void 0) {
              der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
            } else {
              var bits = writeBitField(cert.purposes, KEYUSEBITS);
              der.writeBuffer(bits, asn1.Ber.BitString);
            }
            der.endSequence();
          } else {
            der.writeBuffer(exts[i].data, asn1.Ber.OctetString);
          }
          der.endSequence();
        }
        der.endSequence();
        der.endSequence();
      }
      der.endSequence();
    }
    function readBitField(bits, bitIndex) {
      var bitLen = 8 * (bits.length - 1) - bits[0];
      var setBits = {};
      for (var i = 0; i < bitLen; ++i) {
        var byteN = 1 + Math.floor(i / 8);
        var bit = 7 - i % 8;
        var mask = 1 << bit;
        var bitVal = (bits[byteN] & mask) !== 0;
        var name = bitIndex[i];
        if (bitVal && typeof name === "string") {
          setBits[name] = true;
        }
      }
      return Object.keys(setBits);
    }
    function writeBitField(setBits, bitIndex) {
      var bitLen = bitIndex.length;
      var blen = Math.ceil(bitLen / 8);
      var unused = blen * 8 - bitLen;
      var bits = Buffer2.alloc(1 + blen);
      bits[0] = unused;
      for (var i = 0; i < bitLen; ++i) {
        var byteN = 1 + Math.floor(i / 8);
        var bit = 7 - i % 8;
        var mask = 1 << bit;
        var name = bitIndex[i];
        if (name === void 0)
          continue;
        var bitVal = setBits.indexOf(name) !== -1;
        if (bitVal) {
          bits[byteN] |= mask;
        }
      }
      return bits;
    }
  }
});

// node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS({
  "node_modules/sshpk/lib/formats/x509-pem.js"(exports, module) {
    var x509 = require_x509();
    module.exports = {
      read,
      verify: x509.verify,
      sign: x509.sign,
      write
    };
    var assert = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var Identity = require_identity();
    var Signature = require_signature();
    var Certificate = require_certificate();
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.trim().split(/[\r\n]+/g);
      var m;
      var si = -1;
      while (!m && si < lines.length) {
        m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
      }
      assert.ok(m, "invalid PEM header");
      var m2;
      var ei = lines.length;
      while (!m2 && ei > 0) {
        m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
      }
      assert.ok(m2, "invalid PEM footer");
      lines = lines.slice(si, ei + 1);
      var headers = {};
      while (true) {
        lines = lines.slice(1);
        m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
        if (!m)
          break;
        headers[m[1].toLowerCase()] = m[2];
      }
      lines = lines.slice(0, -1).join("");
      buf = Buffer2.from(lines, "base64");
      return x509.read(buf, options);
    }
    function write(cert, options) {
      var dbuf = x509.write(cert, options);
      var header = "CERTIFICATE";
      var tmp = dbuf.toString("base64");
      var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
      var buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 64;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS({
  "node_modules/sshpk/lib/certificate.js"(exports, module) {
    module.exports = Certificate;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors();
    var util = (init_util(), __toCommonJS(util_exports));
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Identity = require_identity();
    var formats = {};
    formats["openssh"] = require_openssh_cert();
    formats["x509"] = require_x509();
    formats["pem"] = require_x509_pem();
    var CertificateParseError = errs.CertificateParseError;
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    function Certificate(opts) {
      assert.object(opts, "options");
      assert.arrayOfObject(opts.subjects, "options.subjects");
      utils.assertCompatible(opts.subjects[0], Identity, [1, 0], "options.subjects");
      utils.assertCompatible(opts.subjectKey, Key, [1, 0], "options.subjectKey");
      utils.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
      if (opts.issuerKey !== void 0) {
        utils.assertCompatible(opts.issuerKey, Key, [1, 0], "options.issuerKey");
      }
      assert.object(opts.signatures, "options.signatures");
      assert.buffer(opts.serial, "options.serial");
      assert.date(opts.validFrom, "options.validFrom");
      assert.date(opts.validUntil, "optons.validUntil");
      assert.optionalArrayOfString(opts.purposes, "options.purposes");
      this._hashCache = {};
      this.subjects = opts.subjects;
      this.issuer = opts.issuer;
      this.subjectKey = opts.subjectKey;
      this.issuerKey = opts.issuerKey;
      this.signatures = opts.signatures;
      this.serial = opts.serial;
      this.validFrom = opts.validFrom;
      this.validUntil = opts.validUntil;
      this.purposes = opts.purposes;
    }
    Certificate.formats = formats;
    Certificate.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "x509";
      assert.string(format, "format");
      assert.object(formats[format], "formats[format]");
      assert.optionalObject(options, "options");
      return formats[format].write(this, options);
    };
    Certificate.prototype.toString = function(format, options) {
      if (format === void 0)
        format = "pem";
      return this.toBuffer(format, options).toString();
    };
    Certificate.prototype.fingerprint = function(algo) {
      if (algo === void 0)
        algo = "sha256";
      assert.string(algo, "algorithm");
      var opts = {
        type: "certificate",
        hash: this.hash(algo),
        algorithm: algo
      };
      return new Fingerprint(opts);
    };
    Certificate.prototype.hash = function(algo) {
      assert.string(algo, "algorithm");
      algo = algo.toLowerCase();
      if (algs.hashAlgs[algo] === void 0)
        throw new InvalidAlgorithmError(algo);
      if (this._hashCache[algo])
        return this._hashCache[algo];
      var hash = crypto.createHash(algo).update(this.toBuffer("x509")).digest();
      this._hashCache[algo] = hash;
      return hash;
    };
    Certificate.prototype.isExpired = function(when) {
      if (when === void 0)
        when = new Date();
      return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
    };
    Certificate.prototype.isSignedBy = function(issuerCert) {
      utils.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
      if (!this.issuer.equals(issuerCert.subjects[0]))
        return false;
      if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
        return false;
      }
      return this.isSignedByKey(issuerCert.subjectKey);
    };
    Certificate.prototype.getExtension = function(keyOrOid) {
      assert.string(keyOrOid, "keyOrOid");
      var ext = this.getExtensions().filter(function(maybeExt) {
        if (maybeExt.format === "x509")
          return maybeExt.oid === keyOrOid;
        if (maybeExt.format === "openssh")
          return maybeExt.name === keyOrOid;
        return false;
      })[0];
      return ext;
    };
    Certificate.prototype.getExtensions = function() {
      var exts = [];
      var x509 = this.signatures.x509;
      if (x509 && x509.extras && x509.extras.exts) {
        x509.extras.exts.forEach(function(ext) {
          ext.format = "x509";
          exts.push(ext);
        });
      }
      var openssh = this.signatures.openssh;
      if (openssh && openssh.exts) {
        openssh.exts.forEach(function(ext) {
          ext.format = "openssh";
          exts.push(ext);
        });
      }
      return exts;
    };
    Certificate.prototype.isSignedByKey = function(issuerKey) {
      utils.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
      if (this.issuerKey !== void 0) {
        return this.issuerKey.fingerprint("sha512").matches(issuerKey);
      }
      var fmt = Object.keys(this.signatures)[0];
      var valid = formats[fmt].verify(this, issuerKey);
      if (valid)
        this.issuerKey = issuerKey;
      return valid;
    };
    Certificate.prototype.signWith = function(key) {
      utils.assertCompatible(key, PrivateKey, [1, 2], "key");
      var fmts = Object.keys(formats);
      var didOne = false;
      for (var i = 0; i < fmts.length; ++i) {
        if (fmts[i] !== "pem") {
          var ret = formats[fmts[i]].sign(this, key);
          if (ret === true)
            didOne = true;
        }
      }
      if (!didOne) {
        throw new Error("Failed to sign the certificate for any available certificate formats");
      }
    };
    Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
      var subjects;
      if (Array.isArray(subjectOrSubjects))
        subjects = subjectOrSubjects;
      else
        subjects = [subjectOrSubjects];
      assert.arrayOfObject(subjects);
      subjects.forEach(function(subject) {
        utils.assertCompatible(subject, Identity, [1, 0], "subject");
      });
      utils.assertCompatible(key, PrivateKey, [1, 2], "private key");
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalObject(options.validFrom, "options.validFrom");
      assert.optionalObject(options.validUntil, "options.validUntil");
      var validFrom = options.validFrom;
      var validUntil = options.validUntil;
      if (validFrom === void 0)
        validFrom = new Date();
      if (validUntil === void 0) {
        assert.optionalNumber(options.lifetime, "options.lifetime");
        var lifetime = options.lifetime;
        if (lifetime === void 0)
          lifetime = 10 * 365 * 24 * 3600;
        validUntil = new Date();
        validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
      }
      assert.optionalBuffer(options.serial, "options.serial");
      var serial = options.serial;
      if (serial === void 0)
        serial = Buffer2.from("0000000000000001", "hex");
      var purposes = options.purposes;
      if (purposes === void 0)
        purposes = [];
      if (purposes.indexOf("signature") === -1)
        purposes.push("signature");
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
      if (purposes.length <= 3) {
        var hostSubjects = subjects.filter(function(subject) {
          return subject.type === "host";
        });
        var userSubjects = subjects.filter(function(subject) {
          return subject.type === "user";
        });
        if (hostSubjects.length > 0) {
          if (purposes.indexOf("serverAuth") === -1)
            purposes.push("serverAuth");
        }
        if (userSubjects.length > 0) {
          if (purposes.indexOf("clientAuth") === -1)
            purposes.push("clientAuth");
        }
        if (userSubjects.length > 0 || hostSubjects.length > 0) {
          if (purposes.indexOf("keyAgreement") === -1)
            purposes.push("keyAgreement");
          if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
            purposes.push("encryption");
        }
      }
      var cert = new Certificate({
        subjects,
        issuer: subjects[0],
        subjectKey: key.toPublic(),
        issuerKey: key.toPublic(),
        signatures: {},
        serial,
        validFrom,
        validUntil,
        purposes
      });
      cert.signWith(key);
      return cert;
    };
    Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
      var subjects;
      if (Array.isArray(subjectOrSubjects))
        subjects = subjectOrSubjects;
      else
        subjects = [subjectOrSubjects];
      assert.arrayOfObject(subjects);
      subjects.forEach(function(subject) {
        utils.assertCompatible(subject, Identity, [1, 0], "subject");
      });
      utils.assertCompatible(key, Key, [1, 0], "key");
      if (PrivateKey.isPrivateKey(key))
        key = key.toPublic();
      utils.assertCompatible(issuer, Identity, [1, 0], "issuer");
      utils.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalObject(options.validFrom, "options.validFrom");
      assert.optionalObject(options.validUntil, "options.validUntil");
      var validFrom = options.validFrom;
      var validUntil = options.validUntil;
      if (validFrom === void 0)
        validFrom = new Date();
      if (validUntil === void 0) {
        assert.optionalNumber(options.lifetime, "options.lifetime");
        var lifetime = options.lifetime;
        if (lifetime === void 0)
          lifetime = 10 * 365 * 24 * 3600;
        validUntil = new Date();
        validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
      }
      assert.optionalBuffer(options.serial, "options.serial");
      var serial = options.serial;
      if (serial === void 0)
        serial = Buffer2.from("0000000000000001", "hex");
      var purposes = options.purposes;
      if (purposes === void 0)
        purposes = [];
      if (purposes.indexOf("signature") === -1)
        purposes.push("signature");
      if (options.ca === true) {
        if (purposes.indexOf("ca") === -1)
          purposes.push("ca");
        if (purposes.indexOf("crl") === -1)
          purposes.push("crl");
      }
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
      var cert = new Certificate({
        subjects,
        issuer,
        subjectKey: key,
        issuerKey: issuerKey.toPublic(),
        signatures: {},
        serial,
        validFrom,
        validUntil,
        purposes
      });
      cert.signWith(issuerKey);
      return cert;
    };
    Certificate.parse = function(data, format, options) {
      if (typeof data !== "string")
        assert.buffer(data, "data");
      if (format === void 0)
        format = "auto";
      assert.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data, options);
        return k;
      } catch (e) {
        throw new CertificateParseError(options.filename, format, e);
      }
    };
    Certificate.isCertificate = function(obj, ver) {
      return utils.isCompatible(obj, Certificate, ver);
    };
    Certificate.prototype._sshpkApiVersion = [1, 1];
    Certificate._oldVersionDetect = function(obj) {
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS({
  "node_modules/sshpk/lib/fingerprint.js"(exports, module) {
    module.exports = Fingerprint;
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var errs = require_errors();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Certificate = require_certificate();
    var utils = require_utils();
    var FingerprintFormatError = errs.FingerprintFormatError;
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    function Fingerprint(opts) {
      assert.object(opts, "options");
      assert.string(opts.type, "options.type");
      assert.buffer(opts.hash, "options.hash");
      assert.string(opts.algorithm, "options.algorithm");
      this.algorithm = opts.algorithm.toLowerCase();
      if (algs.hashAlgs[this.algorithm] !== true)
        throw new InvalidAlgorithmError(this.algorithm);
      this.hash = opts.hash;
      this.type = opts.type;
      this.hashType = opts.hashType;
    }
    Fingerprint.prototype.toString = function(format) {
      if (format === void 0) {
        if (this.algorithm === "md5" || this.hashType === "spki")
          format = "hex";
        else
          format = "base64";
      }
      assert.string(format);
      switch (format) {
        case "hex":
          if (this.hashType === "spki")
            return this.hash.toString("hex");
          return addColons(this.hash.toString("hex"));
        case "base64":
          if (this.hashType === "spki")
            return this.hash.toString("base64");
          return sshBase64Format(this.algorithm, this.hash.toString("base64"));
        default:
          throw new FingerprintFormatError(void 0, format);
      }
    };
    Fingerprint.prototype.matches = function(other) {
      assert.object(other, "key or certificate");
      if (this.type === "key" && this.hashType !== "ssh") {
        utils.assertCompatible(other, Key, [1, 7], "key with spki");
        if (PrivateKey.isPrivateKey(other)) {
          utils.assertCompatible(other, PrivateKey, [1, 6], "privatekey with spki support");
        }
      } else if (this.type === "key") {
        utils.assertCompatible(other, Key, [1, 0], "key");
      } else {
        utils.assertCompatible(other, Certificate, [1, 0], "certificate");
      }
      var theirHash = other.hash(this.algorithm, this.hashType);
      var theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest("base64");
      if (this.hash2 === void 0)
        this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest("base64");
      return this.hash2 === theirHash2;
    };
    var base64RE = /^[A-Za-z0-9+\/=]+$/;
    var hexRE = /^[a-fA-F0-9]+$/;
    Fingerprint.parse = function(fp, options) {
      assert.string(fp, "fingerprint");
      var alg, hash, enAlgs;
      if (Array.isArray(options)) {
        enAlgs = options;
        options = {};
      }
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      if (options.enAlgs !== void 0)
        enAlgs = options.enAlgs;
      if (options.algorithms !== void 0)
        enAlgs = options.algorithms;
      assert.optionalArrayOfString(enAlgs, "algorithms");
      var hashType = "ssh";
      if (options.hashType !== void 0)
        hashType = options.hashType;
      assert.string(hashType, "options.hashType");
      var parts = fp.split(":");
      if (parts.length == 2) {
        alg = parts[0].toLowerCase();
        if (!base64RE.test(parts[1]))
          throw new FingerprintFormatError(fp);
        try {
          hash = Buffer2.from(parts[1], "base64");
        } catch (e) {
          throw new FingerprintFormatError(fp);
        }
      } else if (parts.length > 2) {
        alg = "md5";
        if (parts[0].toLowerCase() === "md5")
          parts = parts.slice(1);
        parts = parts.map(function(p) {
          while (p.length < 2)
            p = "0" + p;
          if (p.length > 2)
            throw new FingerprintFormatError(fp);
          return p;
        });
        parts = parts.join("");
        if (!hexRE.test(parts) || parts.length % 2 !== 0)
          throw new FingerprintFormatError(fp);
        try {
          hash = Buffer2.from(parts, "hex");
        } catch (e) {
          throw new FingerprintFormatError(fp);
        }
      } else {
        if (hexRE.test(fp)) {
          hash = Buffer2.from(fp, "hex");
        } else if (base64RE.test(fp)) {
          hash = Buffer2.from(fp, "base64");
        } else {
          throw new FingerprintFormatError(fp);
        }
        switch (hash.length) {
          case 32:
            alg = "sha256";
            break;
          case 16:
            alg = "md5";
            break;
          case 20:
            alg = "sha1";
            break;
          case 64:
            alg = "sha512";
            break;
          default:
            throw new FingerprintFormatError(fp);
        }
        if (options.hashType === void 0)
          hashType = "spki";
      }
      if (alg === void 0)
        throw new FingerprintFormatError(fp);
      if (algs.hashAlgs[alg] === void 0)
        throw new InvalidAlgorithmError(alg);
      if (enAlgs !== void 0) {
        enAlgs = enAlgs.map(function(a) {
          return a.toLowerCase();
        });
        if (enAlgs.indexOf(alg) === -1)
          throw new InvalidAlgorithmError(alg);
      }
      return new Fingerprint({
        algorithm: alg,
        hash,
        type: options.type || "key",
        hashType
      });
    };
    function addColons(s) {
      return s.replace(/(.{2})(?=.)/g, "$1:");
    }
    function base64Strip(s) {
      return s.replace(/=*$/, "");
    }
    function sshBase64Format(alg, h) {
      return alg.toUpperCase() + ":" + base64Strip(h);
    }
    Fingerprint.isFingerprint = function(obj, ver) {
      return utils.isCompatible(obj, Fingerprint, ver);
    };
    Fingerprint.prototype._sshpkApiVersion = [1, 2];
    Fingerprint._oldVersionDetect = function(obj) {
      assert.func(obj.toString);
      assert.func(obj.matches);
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/key.js
var require_key = __commonJS({
  "node_modules/sshpk/lib/key.js"(exports, module) {
    module.exports = Key;
    var assert = require_assert();
    var algs = require_algs();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var DiffieHellman = require_dhe().DiffieHellman;
    var errs = require_errors();
    var utils = require_utils();
    var PrivateKey = require_private_key();
    var edCompat;
    try {
      edCompat = require_ed_compat();
    } catch (e) {
    }
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var KeyParseError = errs.KeyParseError;
    var formats = {};
    formats["auto"] = require_auto();
    formats["pem"] = require_pem();
    formats["pkcs1"] = require_pkcs1();
    formats["pkcs8"] = require_pkcs8();
    formats["rfc4253"] = require_rfc4253();
    formats["ssh"] = require_ssh();
    formats["ssh-private"] = require_ssh_private();
    formats["openssh"] = formats["ssh-private"];
    formats["dnssec"] = require_dnssec();
    formats["putty"] = require_putty();
    formats["ppk"] = formats["putty"];
    function Key(opts) {
      assert.object(opts, "options");
      assert.arrayOfObject(opts.parts, "options.parts");
      assert.string(opts.type, "options.type");
      assert.optionalString(opts.comment, "options.comment");
      var algInfo = algs.info[opts.type];
      if (typeof algInfo !== "object")
        throw new InvalidAlgorithmError(opts.type);
      var partLookup = {};
      for (var i = 0; i < opts.parts.length; ++i) {
        var part = opts.parts[i];
        partLookup[part.name] = part;
      }
      this.type = opts.type;
      this.parts = opts.parts;
      this.part = partLookup;
      this.comment = void 0;
      this.source = opts.source;
      this._rfc4253Cache = opts._rfc4253Cache;
      this._hashCache = {};
      var sz;
      this.curve = void 0;
      if (this.type === "ecdsa") {
        var curve = this.part.curve.data.toString();
        this.curve = curve;
        sz = algs.curves[curve].size;
      } else if (this.type === "ed25519" || this.type === "curve25519") {
        sz = 256;
        this.curve = "curve25519";
      } else {
        var szPart = this.part[algInfo.sizePart];
        sz = szPart.data.length;
        sz = sz * 8 - utils.countZeros(szPart.data);
      }
      this.size = sz;
    }
    Key.formats = formats;
    Key.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "ssh";
      assert.string(format, "format");
      assert.object(formats[format], "formats[format]");
      assert.optionalObject(options, "options");
      if (format === "rfc4253") {
        if (this._rfc4253Cache === void 0)
          this._rfc4253Cache = formats["rfc4253"].write(this);
        return this._rfc4253Cache;
      }
      return formats[format].write(this, options);
    };
    Key.prototype.toString = function(format, options) {
      return this.toBuffer(format, options).toString();
    };
    Key.prototype.hash = function(algo, type) {
      assert.string(algo, "algorithm");
      assert.optionalString(type, "type");
      if (type === void 0)
        type = "ssh";
      algo = algo.toLowerCase();
      if (algs.hashAlgs[algo] === void 0)
        throw new InvalidAlgorithmError(algo);
      var cacheKey = algo + "||" + type;
      if (this._hashCache[cacheKey])
        return this._hashCache[cacheKey];
      var buf;
      if (type === "ssh") {
        buf = this.toBuffer("rfc4253");
      } else if (type === "spki") {
        buf = formats.pkcs8.pkcs8ToBuffer(this);
      } else {
        throw new Error("Hash type " + type + " not supported");
      }
      var hash = crypto.createHash(algo).update(buf).digest();
      this._hashCache[cacheKey] = hash;
      return hash;
    };
    Key.prototype.fingerprint = function(algo, type) {
      if (algo === void 0)
        algo = "sha256";
      if (type === void 0)
        type = "ssh";
      assert.string(algo, "algorithm");
      assert.string(type, "type");
      var opts = {
        type: "key",
        hash: this.hash(algo, type),
        algorithm: algo,
        hashType: type
      };
      return new Fingerprint(opts);
    };
    Key.prototype.defaultHashAlgorithm = function() {
      var hashAlgo = "sha1";
      if (this.type === "rsa")
        hashAlgo = "sha256";
      if (this.type === "dsa" && this.size > 1024)
        hashAlgo = "sha256";
      if (this.type === "ed25519")
        hashAlgo = "sha512";
      if (this.type === "ecdsa") {
        if (this.size <= 256)
          hashAlgo = "sha256";
        else if (this.size <= 384)
          hashAlgo = "sha384";
        else
          hashAlgo = "sha512";
      }
      return hashAlgo;
    };
    Key.prototype.createVerify = function(hashAlgo) {
      if (hashAlgo === void 0)
        hashAlgo = this.defaultHashAlgorithm();
      assert.string(hashAlgo, "hash algorithm");
      if (this.type === "ed25519" && edCompat !== void 0)
        return new edCompat.Verifier(this, hashAlgo);
      if (this.type === "curve25519")
        throw new Error("Curve25519 keys are not suitable for signing or verification");
      var v, nm, err;
      try {
        nm = hashAlgo.toUpperCase();
        v = crypto.createVerify(nm);
      } catch (e) {
        err = e;
      }
      if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
        nm = "RSA-";
        nm += hashAlgo.toUpperCase();
        v = crypto.createVerify(nm);
      }
      assert.ok(v, "failed to create verifier");
      var oldVerify = v.verify.bind(v);
      var key = this.toBuffer("pkcs8");
      var curve = this.curve;
      var self2 = this;
      v.verify = function(signature, fmt) {
        if (Signature.isSignature(signature, [2, 0])) {
          if (signature.type !== self2.type)
            return false;
          if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
            return false;
          if (signature.curve && self2.type === "ecdsa" && signature.curve !== curve)
            return false;
          return oldVerify(key, signature.toBuffer("asn1"));
        } else if (typeof signature === "string" || Buffer.isBuffer(signature)) {
          return oldVerify(key, signature, fmt);
        } else if (Signature.isSignature(signature, [1, 0])) {
          throw new Error("signature was created by too old a version of sshpk and cannot be verified");
        } else {
          throw new TypeError("signature must be a string, Buffer, or Signature object");
        }
      };
      return v;
    };
    Key.prototype.createDiffieHellman = function() {
      if (this.type === "rsa")
        throw new Error("RSA keys do not support Diffie-Hellman");
      return new DiffieHellman(this);
    };
    Key.prototype.createDH = Key.prototype.createDiffieHellman;
    Key.parse = function(data, format, options) {
      if (typeof data !== "string")
        assert.buffer(data, "data");
      if (format === void 0)
        format = "auto";
      assert.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data, options);
        if (k instanceof PrivateKey)
          k = k.toPublic();
        if (!k.comment)
          k.comment = options.filename;
        return k;
      } catch (e) {
        if (e.name === "KeyEncryptedError")
          throw e;
        throw new KeyParseError(options.filename, format, e);
      }
    };
    Key.isKey = function(obj, ver) {
      return utils.isCompatible(obj, Key, ver);
    };
    Key.prototype._sshpkApiVersion = [1, 7];
    Key._oldVersionDetect = function(obj) {
      assert.func(obj.toBuffer);
      assert.func(obj.fingerprint);
      if (obj.createDH)
        return [1, 4];
      if (obj.defaultHashAlgorithm)
        return [1, 3];
      if (obj.formats["auto"])
        return [1, 2];
      if (obj.formats["pkcs1"])
        return [1, 1];
      return [1, 0];
    };
  }
});

// node_modules/sshpk/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/sshpk/lib/index.js"(exports, module) {
    var Key = require_key();
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var PrivateKey = require_private_key();
    var Certificate = require_certificate();
    var Identity = require_identity();
    var errs = require_errors();
    module.exports = {
      Key,
      parseKey: Key.parse,
      Fingerprint,
      parseFingerprint: Fingerprint.parse,
      Signature,
      parseSignature: Signature.parse,
      PrivateKey,
      parsePrivateKey: PrivateKey.parse,
      generatePrivateKey: PrivateKey.generate,
      Certificate,
      parseCertificate: Certificate.parse,
      createSelfSignedCertificate: Certificate.createSelfSigned,
      createCertificate: Certificate.create,
      Identity,
      identityFromDN: Identity.parseDN,
      identityForHost: Identity.forHost,
      identityForUser: Identity.forUser,
      identityForEmail: Identity.forEmail,
      identityFromArray: Identity.fromArray,
      FingerprintFormatError: errs.FingerprintFormatError,
      InvalidAlgorithmError: errs.InvalidAlgorithmError,
      KeyParseError: errs.KeyParseError,
      SignatureParseError: errs.SignatureParseError,
      KeyEncryptedError: errs.KeyEncryptedError,
      CertificateParseError: errs.CertificateParseError
    };
  }
});

// node_modules/http-signature/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/http-signature/lib/utils.js"(exports, module) {
    var assert = require_assert();
    var sshpk = require_lib3();
    var util = (init_util(), __toCommonJS(util_exports));
    var HASH_ALGOS = {
      "sha1": true,
      "sha256": true,
      "sha512": true
    };
    var PK_ALGOS = {
      "rsa": true,
      "dsa": true,
      "ecdsa": true
    };
    function HttpSignatureError(message, caller) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, caller || HttpSignatureError);
      this.message = message;
      this.name = caller.name;
    }
    util.inherits(HttpSignatureError, Error);
    function InvalidAlgorithmError(message) {
      HttpSignatureError.call(this, message, InvalidAlgorithmError);
    }
    util.inherits(InvalidAlgorithmError, HttpSignatureError);
    function validateAlgorithm(algorithm) {
      var alg = algorithm.toLowerCase().split("-");
      if (alg.length !== 2) {
        throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a valid algorithm");
      }
      if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
        throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys are not supported");
      }
      if (!HASH_ALGOS[alg[1]]) {
        throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a supported hash algorithm");
      }
      return alg;
    }
    module.exports = {
      HASH_ALGOS,
      PK_ALGOS,
      HttpSignatureError,
      InvalidAlgorithmError,
      validateAlgorithm,
      sshKeyToPEM: function sshKeyToPEM(key) {
        assert.string(key, "ssh_key");
        var k = sshpk.parseKey(key, "ssh");
        return k.toString("pem");
      },
      fingerprint: function fingerprint(key) {
        assert.string(key, "ssh_key");
        var k = sshpk.parseKey(key, "ssh");
        return k.fingerprint("md5").toString("hex");
      },
      pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
        assert.equal("string", typeof pem, "typeof pem");
        var k = sshpk.parseKey(pem, "pem");
        k.comment = comment;
        return k.toString("ssh");
      }
    };
  }
});

// node_modules/http-signature/lib/parser.js
var require_parser = __commonJS({
  "node_modules/http-signature/lib/parser.js"(exports, module) {
    var assert = require_assert();
    var util = (init_util(), __toCommonJS(util_exports));
    var utils = require_utils2();
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var HttpSignatureError = utils.HttpSignatureError;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var validateAlgorithm = utils.validateAlgorithm;
    var State = {
      New: 0,
      Params: 1
    };
    var ParamsState = {
      Name: 0,
      Quote: 1,
      Value: 2,
      Comma: 3
    };
    function ExpiredRequestError(message) {
      HttpSignatureError.call(this, message, ExpiredRequestError);
    }
    util.inherits(ExpiredRequestError, HttpSignatureError);
    function InvalidHeaderError(message) {
      HttpSignatureError.call(this, message, InvalidHeaderError);
    }
    util.inherits(InvalidHeaderError, HttpSignatureError);
    function InvalidParamsError(message) {
      HttpSignatureError.call(this, message, InvalidParamsError);
    }
    util.inherits(InvalidParamsError, HttpSignatureError);
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util.inherits(MissingHeaderError, HttpSignatureError);
    function StrictParsingError(message) {
      HttpSignatureError.call(this, message, StrictParsingError);
    }
    util.inherits(StrictParsingError, HttpSignatureError);
    module.exports = {
      parseRequest: function parseRequest(request, options) {
        assert.object(request, "request");
        assert.object(request.headers, "request.headers");
        if (options === void 0) {
          options = {};
        }
        if (options.headers === void 0) {
          options.headers = [request.headers["x-date"] ? "x-date" : "date"];
        }
        assert.object(options, "options");
        assert.arrayOfString(options.headers, "options.headers");
        assert.optionalFinite(options.clockSkew, "options.clockSkew");
        var authzHeaderName = options.authorizationHeaderName || "authorization";
        if (!request.headers[authzHeaderName]) {
          throw new MissingHeaderError("no " + authzHeaderName + " header present in the request");
        }
        options.clockSkew = options.clockSkew || 300;
        var i = 0;
        var state = State.New;
        var substate = ParamsState.Name;
        var tmpName = "";
        var tmpValue = "";
        var parsed = {
          scheme: "",
          params: {},
          signingString: ""
        };
        var authz = request.headers[authzHeaderName];
        for (i = 0; i < authz.length; i++) {
          var c = authz.charAt(i);
          switch (Number(state)) {
            case State.New:
              if (c !== " ")
                parsed.scheme += c;
              else
                state = State.Params;
              break;
            case State.Params:
              switch (Number(substate)) {
                case ParamsState.Name:
                  var code = c.charCodeAt(0);
                  if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
                    tmpName += c;
                  } else if (c === "=") {
                    if (tmpName.length === 0)
                      throw new InvalidHeaderError("bad param format");
                    substate = ParamsState.Quote;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                case ParamsState.Quote:
                  if (c === '"') {
                    tmpValue = "";
                    substate = ParamsState.Value;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                case ParamsState.Value:
                  if (c === '"') {
                    parsed.params[tmpName] = tmpValue;
                    substate = ParamsState.Comma;
                  } else {
                    tmpValue += c;
                  }
                  break;
                case ParamsState.Comma:
                  if (c === ",") {
                    tmpName = "";
                    substate = ParamsState.Name;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                default:
                  throw new Error("Invalid substate");
              }
              break;
            default:
              throw new Error("Invalid substate");
          }
        }
        if (!parsed.params.headers || parsed.params.headers === "") {
          if (request.headers["x-date"]) {
            parsed.params.headers = ["x-date"];
          } else {
            parsed.params.headers = ["date"];
          }
        } else {
          parsed.params.headers = parsed.params.headers.split(" ");
        }
        if (!parsed.scheme || parsed.scheme !== "Signature")
          throw new InvalidHeaderError('scheme was not "Signature"');
        if (!parsed.params.keyId)
          throw new InvalidHeaderError("keyId was not specified");
        if (!parsed.params.algorithm)
          throw new InvalidHeaderError("algorithm was not specified");
        if (!parsed.params.signature)
          throw new InvalidHeaderError("signature was not specified");
        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
        try {
          validateAlgorithm(parsed.params.algorithm);
        } catch (e) {
          if (e instanceof InvalidAlgorithmError)
            throw new InvalidParamsError(parsed.params.algorithm + " is not supported");
          else
            throw e;
        }
        for (i = 0; i < parsed.params.headers.length; i++) {
          var h = parsed.params.headers[i].toLowerCase();
          parsed.params.headers[i] = h;
          if (h === "request-line") {
            if (!options.strict) {
              parsed.signingString += request.method + " " + request.url + " HTTP/" + request.httpVersion;
            } else {
              throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
            }
          } else if (h === "(request-target)") {
            parsed.signingString += "(request-target): " + request.method.toLowerCase() + " " + request.url;
          } else {
            var value = request.headers[h];
            if (value === void 0)
              throw new MissingHeaderError(h + " was not in the request");
            parsed.signingString += h + ": " + value;
          }
          if (i + 1 < parsed.params.headers.length)
            parsed.signingString += "\n";
        }
        var date;
        if (request.headers.date || request.headers["x-date"]) {
          if (request.headers["x-date"]) {
            date = new Date(request.headers["x-date"]);
          } else {
            date = new Date(request.headers.date);
          }
          var now = new Date();
          var skew = Math.abs(now.getTime() - date.getTime());
          if (skew > options.clockSkew * 1e3) {
            throw new ExpiredRequestError("clock skew of " + skew / 1e3 + "s was greater than " + options.clockSkew + "s");
          }
        }
        options.headers.forEach(function(hdr) {
          if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
            throw new MissingHeaderError(hdr + " was not a signed header");
        });
        if (options.algorithms) {
          if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
            throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
        }
        parsed.algorithm = parsed.params.algorithm.toUpperCase();
        parsed.keyId = parsed.params.keyId;
        return parsed;
      }
    };
  }
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS({
  "node_modules/extsprintf/lib/extsprintf.js"(exports) {
    var mod_assert = (init_assert(), __toCommonJS(assert_exports));
    var mod_util = (init_util(), __toCommonJS(util_exports));
    exports.sprintf = jsSprintf;
    exports.printf = jsPrintf;
    exports.fprintf = jsFprintf;
    function jsSprintf(fmt) {
      var regex = [
        "([^%]*)",
        "%",
        "(['\\-+ #0]*?)",
        "([1-9]\\d*)?",
        "(\\.([1-9]\\d*))?",
        "[lhjztL]*?",
        "([diouxXfFeEgGaAcCsSp%jr])"
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var flags, width, precision, conversion;
      var left, pad, sign, arg, match;
      var ret = "";
      var argn = 1;
      mod_assert.equal("string", typeof fmt);
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0)
          throw new Error("too few args to sprintf");
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/))
          throw new Error("unsupported flags: " + flags);
        if (precision.length > 0)
          throw new Error("non-zero precision not supported");
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null)
              throw new Error("argument " + argn + ": attempted to print undefined or null as a string");
            ret += doPad(pad, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(pad, width, left, arg.toString());
            break;
          case "x":
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw new Error("unsupported conversion: " + conversion);
        }
      }
      ret += fmt;
      return ret;
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/verror/lib/verror.js
var require_verror = __commonJS({
  "node_modules/verror/lib/verror.js"(exports, module) {
    var mod_assertplus = require_assert();
    var mod_util = (init_util(), __toCommonJS(util_exports));
    var mod_extsprintf = require_extsprintf();
    var mod_isError = require_util().isError;
    var sprintf = mod_extsprintf.sprintf;
    module.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(argv[0], "first argument to VError, SError, or WError constructor must be a string, object, or Error");
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError)) {
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(parsed.options.name, `error's "name" must be a string`);
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = "VError";
    VError.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError.prototype.cause = function ve_cause() {
      var cause = VError.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError.cause(err);
      if (cause !== null) {
        rv = VError.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError.hasCauseWithName = function(err, name) {
      return VError.findCauseByName(err, name) !== null;
    };
    VError.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError.fullStack(cause);
      }
      return err.stack;
    };
    VError.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError)) {
        obj = Object.create(WError.prototype);
        WError.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = "WError";
    WError.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// node_modules/json-schema/lib/validate.js
var require_validate = __commonJS({
  "node_modules/json-schema/lib/validate.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return factory();
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.jsonSchema = factory();
      }
    })(exports, function() {
      var exports2 = validate;
      exports2.Integer = { type: "integer" };
      var primitiveConstructors = {
        String,
        Boolean,
        Number,
        Object,
        Array,
        Date
      };
      exports2.validate = validate;
      function validate(instance, schema) {
        return validate(instance, schema, { changing: false });
      }
      ;
      exports2.checkPropertyChange = function(value, schema, property) {
        return validate(value, schema, { changing: property || "property" });
      };
      var validate = exports2._validate = function(instance, schema, options) {
        if (!options)
          options = {};
        var _changing = options.changing;
        function getType(schema2) {
          return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
        }
        var errors = [];
        function checkProp(value, schema2, path, i) {
          var l;
          path += path ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
          function addError(message) {
            errors.push({ property: path, message });
          }
          if ((typeof schema2 != "object" || schema2 instanceof Array) && (path || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
            if (typeof schema2 == "function") {
              if (!(value instanceof schema2)) {
                addError("is not an instance of the class/constructor " + schema2.name);
              }
            } else if (schema2) {
              addError("Invalid schema/property definition " + schema2);
            }
            return null;
          }
          if (_changing && schema2.readonly) {
            addError("is a readonly field, it can not be changed");
          }
          if (schema2["extends"]) {
            checkProp(value, schema2["extends"], path, i);
          }
          function checkType(type, value2) {
            if (type) {
              if (typeof type == "string" && type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && !(value2 instanceof Date && type == "date") && !(type == "integer" && value2 % 1 === 0)) {
                return [{ property: path, message: value2 + " - " + typeof value2 + " value found, but a " + type + " is required" }];
              }
              if (type instanceof Array) {
                var unionErrors = [];
                for (var j2 = 0; j2 < type.length; j2++) {
                  if (!(unionErrors = checkType(type[j2], value2)).length) {
                    break;
                  }
                }
                if (unionErrors.length) {
                  return unionErrors;
                }
              } else if (typeof type == "object") {
                var priorErrors = errors;
                errors = [];
                checkProp(value2, type, path);
                var theseErrors = errors;
                errors = priorErrors;
                return theseErrors;
              }
            }
            return [];
          }
          if (value === void 0) {
            if (schema2.required) {
              addError("is missing and it is required");
            }
          } else {
            errors = errors.concat(checkType(getType(schema2), value));
            if (schema2.disallow && !checkType(schema2.disallow, value).length) {
              addError(" disallowed value was matched");
            }
            if (value !== null) {
              if (value instanceof Array) {
                if (schema2.items) {
                  var itemsIsArray = schema2.items instanceof Array;
                  var propDef = schema2.items;
                  for (i = 0, l = value.length; i < l; i += 1) {
                    if (itemsIsArray)
                      propDef = schema2.items[i];
                    if (options.coerce)
                      value[i] = options.coerce(value[i], propDef);
                    errors.concat(checkProp(value[i], propDef, path, i));
                  }
                }
                if (schema2.minItems && value.length < schema2.minItems) {
                  addError("There must be a minimum of " + schema2.minItems + " in the array");
                }
                if (schema2.maxItems && value.length > schema2.maxItems) {
                  addError("There must be a maximum of " + schema2.maxItems + " in the array");
                }
              } else if (schema2.properties || schema2.additionalProperties) {
                errors.concat(checkObj(value, schema2.properties, path, schema2.additionalProperties));
              }
              if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
                addError("does not match the regex pattern " + schema2.pattern);
              }
              if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
                addError("may only be " + schema2.maxLength + " characters long");
              }
              if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
                addError("must be at least " + schema2.minLength + " characters long");
              }
              if (typeof schema2.minimum !== "undefined" && typeof value == typeof schema2.minimum && schema2.minimum > value) {
                addError("must have a minimum value of " + schema2.minimum);
              }
              if (typeof schema2.maximum !== "undefined" && typeof value == typeof schema2.maximum && schema2.maximum < value) {
                addError("must have a maximum value of " + schema2.maximum);
              }
              if (schema2["enum"]) {
                var enumer = schema2["enum"];
                l = enumer.length;
                var found;
                for (var j = 0; j < l; j++) {
                  if (enumer[j] === value) {
                    found = 1;
                    break;
                  }
                }
                if (!found) {
                  addError("does not have a value in the enumeration " + enumer.join(", "));
                }
              }
              if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
                addError("may only have " + schema2.maxDecimal + " digits of decimal places");
              }
            }
          }
          return null;
        }
        function checkObj(instance2, objTypeDef, path, additionalProp) {
          if (typeof objTypeDef == "object") {
            if (typeof instance2 != "object" || instance2 instanceof Array) {
              errors.push({ property: path, message: "an object is required" });
            }
            for (var i in objTypeDef) {
              if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
                var value = instance2.hasOwnProperty(i) ? instance2[i] : void 0;
                if (value === void 0 && options.existingOnly)
                  continue;
                var propDef = objTypeDef[i];
                if (value === void 0 && propDef["default"]) {
                  value = instance2[i] = propDef["default"];
                }
                if (options.coerce && i in instance2) {
                  value = instance2[i] = options.coerce(value, propDef);
                }
                checkProp(value, propDef, path, i);
              }
            }
          }
          for (i in instance2) {
            if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
              if (options.filter) {
                delete instance2[i];
                continue;
              } else {
                errors.push({ property: path, message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
              }
            }
            var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
            if (requires && !(requires in instance2)) {
              errors.push({ property: path, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
            }
            value = instance2[i];
            if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
              if (options.coerce) {
                value = instance2[i] = options.coerce(value, additionalProp);
              }
              checkProp(value, additionalProp, path, i);
            }
            if (!_changing && value && value.$schema) {
              errors = errors.concat(checkProp(value, value.$schema, path, i));
            }
          }
          return errors;
        }
        if (schema) {
          checkProp(instance, schema, "", _changing || "");
        }
        if (!_changing && instance && instance.$schema) {
          checkProp(instance, instance.$schema, "", "");
        }
        return { valid: !errors.length, errors };
      };
      exports2.mustBeValid = function(result) {
        if (!result.valid) {
          throw new TypeError(result.errors.map(function(error) {
            return "for property " + error.property + ": " + error.message;
          }).join(", \n"));
        }
      };
      return exports2;
    });
  }
});

// node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS({
  "node_modules/jsprim/lib/jsprim.js"(exports) {
    var mod_assert = require_assert();
    var mod_util = (init_util(), __toCommonJS(util_exports));
    var mod_extsprintf = require_extsprintf();
    var mod_verror = require_verror();
    var mod_jsonschema = require_validate();
    exports.deepCopy = deepCopy;
    exports.deepEqual = deepEqual;
    exports.isEmpty = isEmpty;
    exports.hasKey = hasKey;
    exports.forEachKey = forEachKey;
    exports.pluck = pluck;
    exports.flattenObject = flattenObject;
    exports.flattenIter = flattenIter;
    exports.validateJsonObject = validateJsonObjectJS;
    exports.validateJsonObjectJS = validateJsonObjectJS;
    exports.randElt = randElt;
    exports.extraProperties = extraProperties;
    exports.mergeObjects = mergeObjects;
    exports.startsWith = startsWith;
    exports.endsWith = endsWith;
    exports.parseInteger = parseInteger;
    exports.iso8601 = iso8601;
    exports.rfc1123 = rfc1123;
    exports.parseDateTime = parseDateTime;
    exports.hrtimediff = hrtimeDiff;
    exports.hrtimeDiff = hrtimeDiff;
    exports.hrtimeAccum = hrtimeAccum;
    exports.hrtimeAdd = hrtimeAdd;
    exports.hrtimeNanosec = hrtimeNanosec;
    exports.hrtimeMicrosec = hrtimeMicrosec;
    exports.hrtimeMillisec = hrtimeMillisec;
    function deepCopy(obj) {
      var ret, key;
      var marker = "__deepCopy";
      if (obj && obj[marker])
        throw new Error("attempted deep copy of cyclic object");
      if (obj && obj.constructor == Object) {
        ret = {};
        obj[marker] = true;
        for (key in obj) {
          if (key == marker)
            continue;
          ret[key] = deepCopy(obj[key]);
        }
        delete obj[marker];
        return ret;
      }
      if (obj && obj.constructor == Array) {
        ret = [];
        obj[marker] = true;
        for (key = 0; key < obj.length; key++)
          ret.push(deepCopy(obj[key]));
        delete obj[marker];
        return ret;
      }
      return obj;
    }
    function deepEqual(obj1, obj2) {
      if (typeof obj1 != typeof obj2)
        return false;
      if (obj1 === null || obj2 === null || typeof obj1 != "object")
        return obj1 === obj2;
      if (obj1.constructor != obj2.constructor)
        return false;
      var k;
      for (k in obj1) {
        if (!obj2.hasOwnProperty(k))
          return false;
        if (!deepEqual(obj1[k], obj2[k]))
          return false;
      }
      for (k in obj2) {
        if (!obj1.hasOwnProperty(k))
          return false;
      }
      return true;
    }
    function isEmpty(obj) {
      var key;
      for (key in obj)
        return false;
      return true;
    }
    function hasKey(obj, key) {
      mod_assert.equal(typeof key, "string");
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function forEachKey(obj, callback) {
      for (var key in obj) {
        if (hasKey(obj, key)) {
          callback(key, obj[key]);
        }
      }
    }
    function pluck(obj, key) {
      mod_assert.equal(typeof key, "string");
      return pluckv(obj, key);
    }
    function pluckv(obj, key) {
      if (obj === null || typeof obj !== "object")
        return void 0;
      if (obj.hasOwnProperty(key))
        return obj[key];
      var i = key.indexOf(".");
      if (i == -1)
        return void 0;
      var key1 = key.substr(0, i);
      if (!obj.hasOwnProperty(key1))
        return void 0;
      return pluckv(obj[key1], key.substr(i + 1));
    }
    function flattenIter(data, depth, callback) {
      doFlattenIter(data, depth, [], callback);
    }
    function doFlattenIter(data, depth, accum, callback) {
      var each;
      var key;
      if (depth === 0) {
        each = accum.slice(0);
        each.push(data);
        callback(each);
        return;
      }
      mod_assert.ok(data !== null);
      mod_assert.equal(typeof data, "object");
      mod_assert.equal(typeof depth, "number");
      mod_assert.ok(depth >= 0);
      for (key in data) {
        each = accum.slice(0);
        each.push(key);
        doFlattenIter(data[key], depth - 1, each, callback);
      }
    }
    function flattenObject(data, depth) {
      if (depth === 0)
        return [data];
      mod_assert.ok(data !== null);
      mod_assert.equal(typeof data, "object");
      mod_assert.equal(typeof depth, "number");
      mod_assert.ok(depth >= 0);
      var rv = [];
      var key;
      for (key in data) {
        flattenObject(data[key], depth - 1).forEach(function(p) {
          rv.push([key].concat(p));
        });
      }
      return rv;
    }
    function startsWith(str, prefix) {
      return str.substr(0, prefix.length) == prefix;
    }
    function endsWith(str, suffix) {
      return str.substr(str.length - suffix.length, suffix.length) == suffix;
    }
    function iso8601(d) {
      if (typeof d == "number")
        d = new Date(d);
      mod_assert.ok(d.constructor === Date);
      return mod_extsprintf.sprintf("%4d-%02d-%02dT%02d:%02d:%02d.%03dZ", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    }
    var RFC1123_MONTHS = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var RFC1123_DAYS = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    function rfc1123(date) {
      return mod_extsprintf.sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
    }
    function parseDateTime(str) {
      var numeric = +str;
      if (!isNaN(numeric)) {
        return new Date(numeric);
      } else {
        return new Date(str);
      }
    }
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var PI_DEFAULTS = {
      base: 10,
      allowSign: true,
      allowPrefix: false,
      allowTrailing: false,
      allowImprecise: false,
      trimWhitespace: false,
      leadingZeroIsOctal: false
    };
    var CP_0 = 48;
    var CP_9 = 57;
    var CP_A = 65;
    var CP_B = 66;
    var CP_O = 79;
    var CP_T = 84;
    var CP_X = 88;
    var CP_Z = 90;
    var CP_a = 97;
    var CP_b = 98;
    var CP_o = 111;
    var CP_t = 116;
    var CP_x = 120;
    var CP_z = 122;
    var PI_CONV_DEC = 48;
    var PI_CONV_UC = 55;
    var PI_CONV_LC = 87;
    function parseInteger(str, uopts) {
      mod_assert.string(str, "str");
      mod_assert.optionalObject(uopts, "options");
      var baseOverride = false;
      var options = PI_DEFAULTS;
      if (uopts) {
        baseOverride = hasKey(uopts, "base");
        options = mergeObjects(options, uopts);
        mod_assert.number(options.base, "options.base");
        mod_assert.ok(options.base >= 2, "options.base >= 2");
        mod_assert.ok(options.base <= 36, "options.base <= 36");
        mod_assert.bool(options.allowSign, "options.allowSign");
        mod_assert.bool(options.allowPrefix, "options.allowPrefix");
        mod_assert.bool(options.allowTrailing, "options.allowTrailing");
        mod_assert.bool(options.allowImprecise, "options.allowImprecise");
        mod_assert.bool(options.trimWhitespace, "options.trimWhitespace");
        mod_assert.bool(options.leadingZeroIsOctal, "options.leadingZeroIsOctal");
        if (options.leadingZeroIsOctal) {
          mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are mutually exclusive');
        }
      }
      var c;
      var pbase = -1;
      var base = options.base;
      var start;
      var mult = 1;
      var value = 0;
      var idx = 0;
      var len = str.length;
      if (options.trimWhitespace) {
        while (idx < len && isSpace(str.charCodeAt(idx))) {
          ++idx;
        }
      }
      if (options.allowSign) {
        if (str[idx] === "-") {
          idx += 1;
          mult = -1;
        } else if (str[idx] === "+") {
          idx += 1;
        }
      }
      if (str[idx] === "0") {
        if (options.allowPrefix) {
          pbase = prefixToBase(str.charCodeAt(idx + 1));
          if (pbase !== -1 && (!baseOverride || pbase === base)) {
            base = pbase;
            idx += 2;
          }
        }
        if (pbase === -1 && options.leadingZeroIsOctal) {
          base = 8;
        }
      }
      for (start = idx; idx < len; ++idx) {
        c = translateDigit(str.charCodeAt(idx));
        if (c !== -1 && c < base) {
          value *= base;
          value += c;
        } else {
          break;
        }
      }
      if (start === idx) {
        return new Error("invalid number: " + JSON.stringify(str));
      }
      if (options.trimWhitespace) {
        while (idx < len && isSpace(str.charCodeAt(idx))) {
          ++idx;
        }
      }
      if (idx < len && !options.allowTrailing) {
        return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
      }
      if (value === 0) {
        return 0;
      }
      var result = value * mult;
      if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
        return new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx)));
      }
      return result;
    }
    function translateDigit(d) {
      if (d >= CP_0 && d <= CP_9) {
        return d - PI_CONV_DEC;
      } else if (d >= CP_A && d <= CP_Z) {
        return d - PI_CONV_UC;
      } else if (d >= CP_a && d <= CP_z) {
        return d - PI_CONV_LC;
      } else {
        return -1;
      }
    }
    function isSpace(c) {
      return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
    }
    function prefixToBase(c) {
      if (c === CP_b || c === CP_B) {
        return 2;
      } else if (c === CP_o || c === CP_O) {
        return 8;
      } else if (c === CP_t || c === CP_T) {
        return 10;
      } else if (c === CP_x || c === CP_X) {
        return 16;
      } else {
        return -1;
      }
    }
    function validateJsonObjectJS(schema, input) {
      var report = mod_jsonschema.validate(input, schema);
      if (report.errors.length === 0)
        return null;
      var error = report.errors[0];
      var propname = error["property"];
      var reason = error["message"].toLowerCase();
      var i, j;
      if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the schema does not allow additional properties")) != -1) {
        i += "the property ".length;
        if (propname === "")
          propname = reason.substr(i, j - i);
        else
          propname = propname + "." + reason.substr(i, j - i);
        reason = "unsupported property";
      }
      var rv = new mod_verror.VError('property "%s": %s', propname, reason);
      rv.jsv_details = error;
      return rv;
    }
    function randElt(arr) {
      mod_assert.ok(Array.isArray(arr) && arr.length > 0, "randElt argument must be a non-empty array");
      return arr[Math.floor(Math.random() * arr.length)];
    }
    function assertHrtime(a) {
      mod_assert.ok(a[0] >= 0 && a[1] >= 0, "negative numbers not allowed in hrtimes");
      mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
    }
    function hrtimeDiff(a, b) {
      assertHrtime(a);
      assertHrtime(b);
      mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], "negative differences not allowed");
      var rv = [a[0] - b[0], 0];
      if (a[1] >= b[1]) {
        rv[1] = a[1] - b[1];
      } else {
        rv[0]--;
        rv[1] = 1e9 - (b[1] - a[1]);
      }
      return rv;
    }
    function hrtimeNanosec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e9 + a[1]);
    }
    function hrtimeMicrosec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e6 + a[1] / 1e3);
    }
    function hrtimeMillisec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e3 + a[1] / 1e6);
    }
    function hrtimeAccum(a, b) {
      assertHrtime(a);
      assertHrtime(b);
      a[1] += b[1];
      if (a[1] >= 1e9) {
        a[0]++;
        a[1] -= 1e9;
      }
      a[0] += b[0];
      return a;
    }
    function hrtimeAdd(a, b) {
      assertHrtime(a);
      var rv = [a[0], a[1]];
      return hrtimeAccum(rv, b);
    }
    function extraProperties(obj, allowed) {
      mod_assert.ok(typeof obj === "object" && obj !== null, "obj argument must be a non-null object");
      mod_assert.ok(Array.isArray(allowed), "allowed argument must be an array of strings");
      for (var i = 0; i < allowed.length; i++) {
        mod_assert.ok(typeof allowed[i] === "string", "allowed argument must be an array of strings");
      }
      return Object.keys(obj).filter(function(key) {
        return allowed.indexOf(key) === -1;
      });
    }
    function mergeObjects(provided, overrides, defaults) {
      var rv, k;
      rv = {};
      if (defaults) {
        for (k in defaults)
          rv[k] = defaults[k];
      }
      if (provided) {
        for (k in provided)
          rv[k] = provided[k];
      }
      if (overrides) {
        for (k in overrides)
          rv[k] = overrides[k];
      }
      return rv;
    }
  }
});

// node_modules/http-signature/lib/signer.js
var require_signer = __commonJS({
  "node_modules/http-signature/lib/signer.js"(exports, module) {
    var assert = require_assert();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var http = (init_http(), __toCommonJS(http_exports));
    var util = (init_util(), __toCommonJS(util_exports));
    var sshpk = require_lib3();
    var jsprim = require_jsprim();
    var utils = require_utils2();
    var sprintf = (init_util(), __toCommonJS(util_exports)).format;
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var HttpSignatureError = utils.HttpSignatureError;
    var validateAlgorithm = utils.validateAlgorithm;
    var AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util.inherits(MissingHeaderError, HttpSignatureError);
    function StrictParsingError(message) {
      HttpSignatureError.call(this, message, StrictParsingError);
    }
    util.inherits(StrictParsingError, HttpSignatureError);
    function RequestSigner(options) {
      assert.object(options, "options");
      var alg = [];
      if (options.algorithm !== void 0) {
        assert.string(options.algorithm, "options.algorithm");
        alg = validateAlgorithm(options.algorithm);
      }
      this.rs_alg = alg;
      if (options.sign !== void 0) {
        assert.func(options.sign, "options.sign");
        this.rs_signFunc = options.sign;
      } else if (alg[0] === "hmac" && options.key !== void 0) {
        assert.string(options.keyId, "options.keyId");
        this.rs_keyId = options.keyId;
        if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
          throw new TypeError("options.key for HMAC must be a string or Buffer");
        this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
        this.rs_signer.sign = function() {
          var digest = this.digest("base64");
          return {
            hashAlgorithm: alg[1],
            toString: function() {
              return digest;
            }
          };
        };
      } else if (options.key !== void 0) {
        var key = options.key;
        if (typeof key === "string" || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(key);
        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
        this.rs_key = key;
        assert.string(options.keyId, "options.keyId");
        this.rs_keyId = options.keyId;
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
        }
        if (alg[0] !== void 0 && key.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
        }
        this.rs_signer = key.createSign(alg[1]);
      } else {
        throw new TypeError("options.sign (func) or options.key is required");
      }
      this.rs_headers = [];
      this.rs_lines = [];
    }
    RequestSigner.prototype.writeHeader = function(header, value) {
      assert.string(header, "header");
      header = header.toLowerCase();
      assert.string(value, "value");
      this.rs_headers.push(header);
      if (this.rs_signFunc) {
        this.rs_lines.push(header + ": " + value);
      } else {
        var line = header + ": " + value;
        if (this.rs_headers.length > 0)
          line = "\n" + line;
        this.rs_signer.update(line);
      }
      return value;
    };
    RequestSigner.prototype.writeDateHeader = function() {
      return this.writeHeader("date", jsprim.rfc1123(new Date()));
    };
    RequestSigner.prototype.writeTarget = function(method, path) {
      assert.string(method, "method");
      assert.string(path, "path");
      method = method.toLowerCase();
      this.writeHeader("(request-target)", method + " " + path);
    };
    RequestSigner.prototype.sign = function(cb) {
      assert.func(cb, "callback");
      if (this.rs_headers.length < 1)
        throw new Error("At least one header must be signed");
      var alg, authz;
      if (this.rs_signFunc) {
        var data = this.rs_lines.join("\n");
        var self2 = this;
        this.rs_signFunc(data, function(err, sig) {
          if (err) {
            cb(err);
            return;
          }
          try {
            assert.object(sig, "signature");
            assert.string(sig.keyId, "signature.keyId");
            assert.string(sig.algorithm, "signature.algorithm");
            assert.string(sig.signature, "signature.signature");
            alg = validateAlgorithm(sig.algorithm);
            authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self2.rs_headers.join(" "), sig.signature);
          } catch (e) {
            cb(e);
            return;
          }
          cb(null, authz);
        });
      } else {
        try {
          var sigObj = this.rs_signer.sign();
        } catch (e) {
          cb(e);
          return;
        }
        alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
        var signature = sigObj.toString();
        authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(" "), signature);
        cb(null, authz);
      }
    };
    module.exports = {
      isSigner: function(obj) {
        if (typeof obj === "object" && obj instanceof RequestSigner)
          return true;
        return false;
      },
      createSigner: function createSigner(options) {
        return new RequestSigner(options);
      },
      signRequest: function signRequest(request, options) {
        assert.object(request, "request");
        assert.object(options, "options");
        assert.optionalString(options.algorithm, "options.algorithm");
        assert.string(options.keyId, "options.keyId");
        assert.optionalArrayOfString(options.headers, "options.headers");
        assert.optionalString(options.httpVersion, "options.httpVersion");
        if (!request.getHeader("Date"))
          request.setHeader("Date", jsprim.rfc1123(new Date()));
        if (!options.headers)
          options.headers = ["date"];
        if (!options.httpVersion)
          options.httpVersion = "1.1";
        var alg = [];
        if (options.algorithm) {
          options.algorithm = options.algorithm.toLowerCase();
          alg = validateAlgorithm(options.algorithm);
        }
        var i;
        var stringToSign = "";
        for (i = 0; i < options.headers.length; i++) {
          if (typeof options.headers[i] !== "string")
            throw new TypeError("options.headers must be an array of Strings");
          var h = options.headers[i].toLowerCase();
          if (h === "request-line") {
            if (!options.strict) {
              stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion;
            } else {
              throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
            }
          } else if (h === "(request-target)") {
            stringToSign += "(request-target): " + request.method.toLowerCase() + " " + request.path;
          } else {
            var value = request.getHeader(h);
            if (value === void 0 || value === "") {
              throw new MissingHeaderError(h + " was not in the request");
            }
            stringToSign += h + ": " + value;
          }
          if (i + 1 < options.headers.length)
            stringToSign += "\n";
        }
        if (request.hasOwnProperty("_stringToSign")) {
          request._stringToSign = stringToSign;
        }
        var signature;
        if (alg[0] === "hmac") {
          if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
            throw new TypeError("options.key must be a string or Buffer");
          var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
          hmac.update(stringToSign);
          signature = hmac.digest("base64");
        } else {
          var key = options.key;
          if (typeof key === "string" || Buffer.isBuffer(key))
            key = sshpk.parsePrivateKey(options.key);
          assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
          if (!PK_ALGOS[key.type]) {
            throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
          }
          if (alg[0] !== void 0 && key.type !== alg[0]) {
            throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
          }
          var signer = key.createSign(alg[1]);
          signer.update(stringToSign);
          var sigObj = signer.sign();
          if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
            throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
          }
          options.algorithm = key.type + "-" + sigObj.hashAlgorithm;
          signature = sigObj.toString();
          assert.notStrictEqual(signature, "", "empty signature produced");
        }
        var authzHeaderName = options.authorizationHeaderName || "Authorization";
        request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(" "), signature));
        return true;
      }
    };
  }
});

// node_modules/http-signature/lib/verify.js
var require_verify = __commonJS({
  "node_modules/http-signature/lib/verify.js"(exports, module) {
    var assert = require_assert();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var sshpk = require_lib3();
    var utils = require_utils2();
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var HttpSignatureError = utils.HttpSignatureError;
    var validateAlgorithm = utils.validateAlgorithm;
    module.exports = {
      verifySignature: function verifySignature(parsedSignature, pubkey) {
        assert.object(parsedSignature, "parsedSignature");
        if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
          pubkey = sshpk.parseKey(pubkey);
        assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
        var alg = validateAlgorithm(parsedSignature.algorithm);
        if (alg[0] === "hmac" || alg[0] !== pubkey.type)
          return false;
        var v = pubkey.createVerify(alg[1]);
        v.update(parsedSignature.signingString);
        return v.verify(parsedSignature.params.signature, "base64");
      },
      verifyHMAC: function verifyHMAC(parsedSignature, secret) {
        assert.object(parsedSignature, "parsedHMAC");
        assert.string(secret, "secret");
        var alg = validateAlgorithm(parsedSignature.algorithm);
        if (alg[0] !== "hmac")
          return false;
        var hashAlg = alg[1].toUpperCase();
        var hmac = crypto.createHmac(hashAlg, secret);
        hmac.update(parsedSignature.signingString);
        var h1 = crypto.createHmac(hashAlg, secret);
        h1.update(hmac.digest());
        h1 = h1.digest();
        var h2 = crypto.createHmac(hashAlg, secret);
        h2.update(new Buffer(parsedSignature.params.signature, "base64"));
        h2 = h2.digest();
        if (typeof h1 === "string")
          return h1 === h2;
        if (Buffer.isBuffer(h1) && !h1.equals)
          return h1.toString("binary") === h2.toString("binary");
        return h1.equals(h2);
      }
    };
  }
});

// node_modules/http-signature/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/http-signature/lib/index.js"(exports, module) {
    var parser = require_parser();
    var signer = require_signer();
    var verify = require_verify();
    var utils = require_utils2();
    module.exports = {
      parse: parser.parseRequest,
      parseRequest: parser.parseRequest,
      sign: signer.signRequest,
      signRequest: signer.signRequest,
      createSigner: signer.createSigner,
      isSigner: signer.isSigner,
      sshKeyToPEM: utils.sshKeyToPEM,
      sshKeyFingerprint: utils.fingerprint,
      pemToRsaSSHKey: utils.pemToRsaSSHKey,
      verify: verify.verifySignature,
      verifySignature: verify.verifySignature,
      verifyHMAC: verify.verifyHMAC
    };
  }
});

// node_modules/caseless/index.js
var require_caseless = __commonJS({
  "node_modules/caseless/index.js"(exports, module) {
    function Caseless(dict) {
      this.dict = dict || {};
    }
    Caseless.prototype.set = function(name, value, clobber) {
      if (typeof name === "object") {
        for (var i in name) {
          this.set(i, name[i], value);
        }
      } else {
        if (typeof clobber === "undefined")
          clobber = true;
        var has = this.has(name);
        if (!clobber && has)
          this.dict[has] = this.dict[has] + "," + value;
        else
          this.dict[has || name] = value;
        return has;
      }
    };
    Caseless.prototype.has = function(name) {
      var keys = Object.keys(this.dict), name = name.toLowerCase();
      for (var i = 0; i < keys.length; i++) {
        if (keys[i].toLowerCase() === name)
          return keys[i];
      }
      return false;
    };
    Caseless.prototype.get = function(name) {
      name = name.toLowerCase();
      var result, _key;
      var headers = this.dict;
      Object.keys(headers).forEach(function(key) {
        _key = key.toLowerCase();
        if (name === _key)
          result = headers[key];
      });
      return result;
    };
    Caseless.prototype.swap = function(name) {
      var has = this.has(name);
      if (has === name)
        return;
      if (!has)
        throw new Error('There is no header than matches "' + name + '"');
      this.dict[name] = this.dict[has];
      delete this.dict[has];
    };
    Caseless.prototype.del = function(name) {
      var has = this.has(name);
      return delete this.dict[has || name];
    };
    module.exports = function(dict) {
      return new Caseless(dict);
    };
    module.exports.httpify = function(resp, headers) {
      var c = new Caseless(headers);
      resp.setHeader = function(key, value, clobber) {
        if (typeof value === "undefined")
          return;
        return c.set(key, value, clobber);
      };
      resp.hasHeader = function(key) {
        return c.has(key);
      };
      resp.getHeader = function(key) {
        return c.get(key);
      };
      resp.removeHeader = function(key) {
        return c.del(key);
      };
      resp.headers = c.dict;
      return c;
    };
  }
});

// browser-external:tls
var tls_exports = {};
__export(tls_exports, {
  default: () => tls_default
});
var tls_default;
var init_tls = __esm({
  "browser-external:tls"() {
    tls_default = new Proxy({}, {
      get() {
        throw new Error('Module "tls" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/forever-agent/index.js
var require_forever_agent = __commonJS({
  "node_modules/forever-agent/index.js"(exports, module) {
    module.exports = ForeverAgent;
    ForeverAgent.SSL = ForeverAgentSSL;
    var util = (init_util(), __toCommonJS(util_exports));
    var Agent = (init_http(), __toCommonJS(http_exports)).Agent;
    var net = (init_net(), __toCommonJS(net_exports));
    var tls = (init_tls(), __toCommonJS(tls_exports));
    var AgentSSL = (init_https(), __toCommonJS(https_exports)).Agent;
    function getConnectionName(host, port) {
      var name = "";
      if (typeof host === "string") {
        name = host + ":" + port;
      } else {
        name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
      }
      return name;
    }
    function ForeverAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.requests = {};
      self2.sockets = {};
      self2.freeSockets = {};
      self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
      self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
      self2.on("free", function(socket, host, port) {
        var name = getConnectionName(host, port);
        if (self2.requests[name] && self2.requests[name].length) {
          self2.requests[name].shift().onSocket(socket);
        } else if (self2.sockets[name].length < self2.minSockets) {
          if (!self2.freeSockets[name])
            self2.freeSockets[name] = [];
          self2.freeSockets[name].push(socket);
          var onIdleError = function() {
            socket.destroy();
          };
          socket._onIdleError = onIdleError;
          socket.on("error", onIdleError);
        } else {
          socket.destroy();
        }
      });
    }
    util.inherits(ForeverAgent, Agent);
    ForeverAgent.defaultMinSockets = 5;
    ForeverAgent.prototype.createConnection = net.createConnection;
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
    ForeverAgent.prototype.addRequest = function(req, host, port) {
      var name = getConnectionName(host, port);
      if (typeof host !== "string") {
        var options = host;
        port = options.port;
        host = options.host;
      }
      if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
        var idleSocket = this.freeSockets[name].pop();
        idleSocket.removeListener("error", idleSocket._onIdleError);
        delete idleSocket._onIdleError;
        req._reusedSocket = true;
        req.onSocket(idleSocket);
      } else {
        this.addRequestNoreuse(req, host, port);
      }
    };
    ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
      if (this.sockets[name]) {
        var index = this.sockets[name].indexOf(s);
        if (index !== -1) {
          this.sockets[name].splice(index, 1);
        }
      } else if (this.sockets[name] && this.sockets[name].length === 0) {
        delete this.sockets[name];
        delete this.requests[name];
      }
      if (this.freeSockets[name]) {
        var index = this.freeSockets[name].indexOf(s);
        if (index !== -1) {
          this.freeSockets[name].splice(index, 1);
          if (this.freeSockets[name].length === 0) {
            delete this.freeSockets[name];
          }
        }
      }
      if (this.requests[name] && this.requests[name].length) {
        this.createSocket(name, host, port).emit("free");
      }
    };
    function ForeverAgentSSL(options) {
      ForeverAgent.call(this, options);
    }
    util.inherits(ForeverAgentSSL, ForeverAgent);
    ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
    ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
    function createConnectionSSL(port, host, options) {
      if (typeof port === "object") {
        options = port;
      } else if (typeof host === "object") {
        options = host;
      } else if (typeof options === "object") {
        options = options;
      } else {
        options = {};
      }
      if (typeof port === "number") {
        options.port = port;
      }
      if (typeof host === "string") {
        options.host = host;
      }
      return tls.connect(options);
    }
  }
});

// node_modules/request/node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/request/node_modules/form-data/lib/browser.js"(exports, module) {
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS({
  "node_modules/isstream/isstream.js"(exports, module) {
    var stream = (init_stream(), __toCommonJS(stream_exports));
    function isStream(obj) {
      return obj instanceof stream.Stream;
    }
    function isReadable(obj) {
      return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
    }
    function isWritable(obj) {
      return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
    }
    function isDuplex(obj) {
      return isReadable(obj) && isWritable(obj);
    }
    module.exports = isStream;
    module.exports.isReadable = isReadable;
    module.exports.isWritable = isWritable;
    module.exports.isDuplex = isDuplex;
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS({
  "node_modules/request/lib/getProxyFromURI.js"(exports, module) {
    "use strict";
    function formatHostname(hostname) {
      return hostname.replace(/^\.*/, ".").toLowerCase();
    }
    function parseNoProxyZone(zone) {
      zone = zone.trim().toLowerCase();
      var zoneParts = zone.split(":", 2);
      var zoneHost = formatHostname(zoneParts[0]);
      var zonePort = zoneParts[1];
      var hasPort = zone.indexOf(":") > -1;
      return { hostname: zoneHost, port: zonePort, hasPort };
    }
    function uriInNoProxy(uri, noProxy) {
      var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
      var hostname = formatHostname(uri.hostname);
      var noProxyList = noProxy.split(",");
      return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
        var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
        var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
        if (noProxyZone.hasPort) {
          return port === noProxyZone.port && hostnameMatched;
        }
        return hostnameMatched;
      });
    }
    function getProxyFromURI(uri) {
      var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
      if (noProxy === "*") {
        return null;
      }
      if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
        return null;
      }
      if (uri.protocol === "http:") {
        return process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      if (uri.protocol === "https:") {
        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      return null;
    }
    module.exports = getProxyFromURI;
  }
});

// node_modules/request/node_modules/qs/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/request/node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      var obj;
      while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];
        if (Array.isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
      return obj;
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (Array.isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str) {
      try {
        return decodeURIComponent(str.replace(/\+/g, " "));
      } catch (e) {
        return str;
      }
    };
    var encode = function encode2(str) {
      if (str.length === 0) {
        return str;
      }
      var string = typeof str === "string" ? str : String(str);
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      return compactQueue(queue);
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    module.exports = {
      arrayToObject,
      assign,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      merge
    };
  }
});

// node_modules/request/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/request/node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    module.exports = {
      "default": "RFC3986",
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
  }
});

// node_modules/request/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/request/node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var formats = require_formats();
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaults = {
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
      var obj = object;
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }
        obj = "";
      }
      if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        if (isArray(obj)) {
          pushToArray(values, stringify2(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
        } else {
          pushToArray(values, stringify2(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
        }
      }
      return values;
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = opts ? utils.assign({}, opts) : {};
      if (options.encoder !== null && typeof options.encoder !== "undefined" && typeof options.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
      var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
      var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
      var encode = typeof options.encode === "boolean" ? options.encode : defaults.encode;
      var encoder = typeof options.encoder === "function" ? options.encoder : defaults.encoder;
      var sort = typeof options.sort === "function" ? options.sort : null;
      var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
      var serializeDate = typeof options.serializeDate === "function" ? options.serializeDate : defaults.serializeDate;
      var encodeValuesOnly = typeof options.encodeValuesOnly === "boolean" ? options.encodeValuesOnly : defaults.encodeValuesOnly;
      if (typeof options.format === "undefined") {
        options.format = formats["default"];
      } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      var formatter = formats.formatters[options.format];
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
      } else if ("indices" in options) {
        arrayFormat = options.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (sort) {
        objKeys.sort(sort);
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
      }
      var joined = keys.join(delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/request/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/request/node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var has = Object.prototype.hasOwnProperty;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      arrayLimit: 20,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      parameterLimit: 1e3,
      plainObjects: false,
      strictNullHandling: false
    };
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder);
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder);
          val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
          obj[key] = [].concat(obj[key]).concat(val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options) {
      var leaf = val;
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options);
    };
    module.exports = function(str, opts) {
      var options = opts ? utils.assign({}, opts) : {};
      if (options.decoder !== null && options.decoder !== void 0 && typeof options.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
      options.delimiter = typeof options.delimiter === "string" || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
      options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
      options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
      options.parseArrays = options.parseArrays !== false;
      options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
      options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
      options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
      options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
      options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
      options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/request/node_modules/qs/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/request/node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify2();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/request/lib/querystring.js
var require_querystring = __commonJS({
  "node_modules/request/lib/querystring.js"(exports) {
    "use strict";
    var qs = require_lib5();
    var querystring = (init_querystring(), __toCommonJS(querystring_exports));
    function Querystring(request) {
      this.request = request;
      this.lib = null;
      this.useQuerystring = null;
      this.parseOptions = null;
      this.stringifyOptions = null;
    }
    Querystring.prototype.init = function(options) {
      if (this.lib) {
        return;
      }
      this.useQuerystring = options.useQuerystring;
      this.lib = this.useQuerystring ? querystring : qs;
      this.parseOptions = options.qsParseOptions || {};
      this.stringifyOptions = options.qsStringifyOptions || {};
    };
    Querystring.prototype.stringify = function(obj) {
      return this.useQuerystring ? this.rfc3986(this.lib.stringify(obj, this.stringifyOptions.sep || null, this.stringifyOptions.eq || null, this.stringifyOptions)) : this.lib.stringify(obj, this.stringifyOptions);
    };
    Querystring.prototype.parse = function(str) {
      return this.useQuerystring ? this.lib.parse(str, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions) : this.lib.parse(str, this.parseOptions);
    };
    Querystring.prototype.rfc3986 = function(str) {
      return str.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    };
    Querystring.prototype.unescape = querystring.unescape;
    exports.Querystring = Querystring;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    var isArray = Array.isArray;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      var arrA = isArray(a), arrB = isArray(b), i, length, key;
      if (arrA && arrB) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = 0; i < length; i++)
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (arrA != arrB)
        return false;
      var dateA = a instanceof Date, dateB = b instanceof Date;
      if (dateA != dateB)
        return false;
      if (dateA && dateB)
        return a.getTime() == b.getTime();
      var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
      if (regexpA != regexpB)
        return false;
      if (regexpA && regexpB)
        return a.toString() == b.toString();
      if (a instanceof Object && b instanceof Object) {
        var keys = keyList(a);
        length = keys.length;
        if (length !== keyList(b).length)
          return false;
        for (i = 0; i < length; i++)
          if (!hasProp.call(b, keys[i]))
            return false;
        for (i = 0; i < length; i++) {
          key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return false;
    };
  }
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
    "use strict";
    module.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// node_modules/ajv/lib/compile/util.js
var require_util2 = __commonJS({
  "node_modules/ajv/lib/compile/util.js"(exports, module) {
    "use strict";
    module.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      cleanUpCode,
      finalCleanUpCode,
      schemaHasRules,
      schemaHasRulesExcept,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number)
            delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t])
            types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array")
            types[types.length] = t;
        }
        if (types.length)
          return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    var EMPTY_ELSE = /else\s*{\s*}/g;
    var EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g;
    var EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
    function cleanUpCode(out) {
      return out.replace(EMPTY_ELSE, "").replace(EMPTY_IF_NO_ELSE, "").replace(EMPTY_IF_WITH_ELSE, "if (!($1))");
    }
    var ERRORS_REGEXP = /[^v.]errors/g;
    var REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g;
    var REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g;
    var RETURN_VALID = "return errors === 0;";
    var RETURN_TRUE = "validate.errors = null; return true;";
    var RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/;
    var RETURN_DATA_ASYNC = "return data;";
    var ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g;
    var REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;
    function finalCleanUpCode(out, async) {
      var matches = out.match(ERRORS_REGEXP);
      if (matches && matches.length == 2) {
        out = async ? out.replace(REMOVE_ERRORS_ASYNC, "").replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, "").replace(RETURN_VALID, RETURN_TRUE);
      }
      matches = out.match(ROOTDATA_REGEXP);
      if (!matches || matches.length !== 3)
        return out;
      return out.replace(REMOVE_ROOTDATA, "");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/' \+ '/g, "");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
    "use strict";
    var util = require_util2();
    module.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      _traverse(opts, cb, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, cb, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, cb, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, cb, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/lib/compile/resolve.js"(exports, module) {
    "use strict";
    var url = (init_url(), __toCommonJS(url_exports));
    var equal = require_fast_deep_equal();
    var util = require_util2();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = url.parse(ref, false, true), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema)
          return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.hash = parsedRef.hash || "";
      if (parsedRef.hash.slice(0, 2) != "#/")
        return;
      var parts = parsedRef.hash.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = url.parse(id, false, true);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      var protocolSeparator = p.protocol || p.href.slice(0, 2) == "//" ? "//" : "";
      return (p.protocol || "") + protocolSeparator + (p.host || "") + (p.path || "") + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return url.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string")
            refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
    "use strict";
    var resolve = require_resolve();
    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate2 = __commonJS({
  "node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
    "use strict";
    module.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.isTop) {
        if ($async) {
          it.async = true;
          var $es7 = it.opts.async == "es7";
          it.yieldAwait = $es7 ? "await" : "yield";
        }
        out += " var validate = ";
        if ($async) {
          if ($es7) {
            out += " (async function ";
          } else {
            if (it.opts.async != "*") {
              out += "co.wrap";
            }
            out += "(function* ";
          }
        } else {
          out += " (function ";
        }
        out += " (data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }); return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [void 0];
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ")) " + $dataType + " = 'array'; ";
            }
            out += " var " + $coerced + " = undefined; ";
            var $bracesCoercion = "";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($i) {
                  out += " if (" + $coerced + " === undefined) { ";
                  $bracesCoercion += "}";
                }
                if (it.opts.coerceTypes == "array" && $type != "array") {
                  out += " if (" + $dataType + " == 'array' && " + $data + ".length == 1) { " + $coerced + " = " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + ";  } ";
                }
                if ($type == "string") {
                  out += " if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " " + $bracesCoercion + " if (" + $coerced + " === undefined) {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        if (it.opts.v5 && it.schema.patternGroups) {
          it.logger.warn('keyword "patternGroups" is deprecated and disabled. Use option patternGroups: true to enable.');
        }
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data) + ") { ";
              }
              if (it.opts.useDefaults && !it.compositeRule) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        out += "  if (" + $passData + " === undefined) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        out += "  if (" + $passData + " === undefined) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }); return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      out = it.util.cleanUpCode(out);
      if ($top) {
        out = it.util.finalCleanUpCode(out, $async);
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// node_modules/co/index.js
var require_co = __commonJS({
  "node_modules/co/index.js"(exports, module) {
    var slice = Array.prototype.slice;
    module.exports = co["default"] = co.co = co;
    co.wrap = function(fn) {
      createPromise.__generatorFunction__ = fn;
      return createPromise;
      function createPromise() {
        return co.call(this, fn.apply(this, arguments));
      }
    };
    function co(gen) {
      var ctx = this;
      var args = slice.call(arguments, 1);
      return new Promise(function(resolve, reject) {
        if (typeof gen === "function")
          gen = gen.apply(ctx, args);
        if (!gen || typeof gen.next !== "function")
          return resolve(gen);
        onFulfilled();
        function onFulfilled(res) {
          var ret;
          try {
            ret = gen.next(res);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }
        function onRejected(err) {
          var ret;
          try {
            ret = gen.throw(err);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }
        function next(ret) {
          if (ret.done)
            return resolve(ret.value);
          var value = toPromise.call(ctx, ret.value);
          if (value && isPromise(value))
            return value.then(onFulfilled, onRejected);
          return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, but the following object was passed: "' + String(ret.value) + '"'));
        }
      });
    }
    function toPromise(obj) {
      if (!obj)
        return obj;
      if (isPromise(obj))
        return obj;
      if (isGeneratorFunction(obj) || isGenerator(obj))
        return co.call(this, obj);
      if (typeof obj == "function")
        return thunkToPromise.call(this, obj);
      if (Array.isArray(obj))
        return arrayToPromise.call(this, obj);
      if (isObject(obj))
        return objectToPromise.call(this, obj);
      return obj;
    }
    function thunkToPromise(fn) {
      var ctx = this;
      return new Promise(function(resolve, reject) {
        fn.call(ctx, function(err, res) {
          if (err)
            return reject(err);
          if (arguments.length > 2)
            res = slice.call(arguments, 1);
          resolve(res);
        });
      });
    }
    function arrayToPromise(obj) {
      return Promise.all(obj.map(toPromise, this));
    }
    function objectToPromise(obj) {
      var results = new obj.constructor();
      var keys = Object.keys(obj);
      var promises = [];
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var promise = toPromise.call(this, obj[key]);
        if (promise && isPromise(promise))
          defer(promise, key);
        else
          results[key] = obj[key];
      }
      return Promise.all(promises).then(function() {
        return results;
      });
      function defer(promise2, key2) {
        results[key2] = void 0;
        promises.push(promise2.then(function(res) {
          results[key2] = res;
        }));
      }
    }
    function isPromise(obj) {
      return typeof obj.then == "function";
    }
    function isGenerator(obj) {
      return typeof obj.next == "function" && typeof obj.throw == "function";
    }
    function isGeneratorFunction(obj) {
      var constructor = obj.constructor;
      if (!constructor)
        return false;
      if (constructor.name === "GeneratorFunction" || constructor.displayName === "GeneratorFunction")
        return true;
      return isGenerator(constructor.prototype);
    }
    function isObject(val) {
      return Object == val.constructor;
    }
  }
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/lib/compile/index.js"(exports, module) {
    "use strict";
    var resolve = require_resolve();
    var util = require_util2();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate2();
    var co = require_co();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(null, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode);
        var validate;
        try {
          var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "co", "equal", "ucs2length", "ValidationError", sourceCode);
          validate = makeValidate(self2, RULES, formats, root, refVal, defaults, customRules, co, equal, ucs2length, ValidationError);
          refVal[0] = validate;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async)
          validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && refVal2.$async };
      }
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null)
              return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema && self2._opts.validateSchema !== false) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log")
              self2.logger.error(message);
            else
              throw new Error(message);
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self2.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate)
            return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
          code: "customRule" + index,
          validate
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0)
        return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "node_modules/ajv/lib/cache.js"(exports, module) {
    "use strict";
    var Cache = module.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS({
  "node_modules/ajv/lib/compile/formats.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
    var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$|^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
      uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\/)\/?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
      "uri-template": URITEMPLATE,
      url: URL,
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function date(str) {
      var matches = str.match(DATE);
      if (!matches)
        return false;
      var month = +matches[1];
      var day = +matches[2];
      return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches)
        return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function hostname(str) {
      return str.length <= 255 && HOSTNAME.test(str);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
    "use strict";
    module.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { " + it.yieldAwait + " " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
        out = it.util.cleanUpCode(out);
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "node_modules/ajv/lib/dotjs/const.js"(exports, module) {
    "use strict";
    module.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
    "use strict";
    module.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
    "use strict";
    module.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
    "use strict";
    module.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "node_modules/ajv/lib/dotjs/format.js"(exports, module) {
    "use strict";
    module.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? " + it.yieldAwait + " " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(" + it.yieldAwait + " " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "node_modules/ajv/lib/dotjs/items.js"(exports, module) {
    "use strict";
    module.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
    "use strict";
    module.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "=';";
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "less";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "less";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "node_modules/ajv/lib/dotjs/not.js"(exports, module) {
    "use strict";
    module.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;var prevValid" + $lvl + " = false;var " + $valid + " = false;";
      var $currentBaseId = $it.baseId;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && prevValid" + $lvl + ") " + $valid + " = false; else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") " + $valid + " = prevValid" + $lvl + " = true;";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
    "use strict";
    module.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
    "use strict";
    module.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired)
        var $requiredHash = it.util.toHash($required);
      if (it.opts.patternGroups) {
        var $pgProperties = it.schema.patternGroups || {}, $pgPropertyKeys = Object.keys($pgProperties);
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 5) {
              out += " || validate.schema" + $schemaPath + "[" + $key + "] ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          if (it.opts.patternGroups && $pgPropertyKeys.length) {
            var arr3 = $pgPropertyKeys;
            if (arr3) {
              var $pgProperty, $i = -1, l3 = arr3.length - 1;
              while ($i < l3) {
                $pgProperty = arr3[$i += 1];
                out += " || " + it.usePattern($pgProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should NOT have additional properties' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr4 = $schemaKeys;
        if (arr4) {
          var $propertyKey, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $propertyKey = arr4[i4 += 1];
            var $sch = $schema[$propertyKey];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr5 = $pPropertyKeys;
        if (arr5) {
          var $pProperty, i5 = -1, l5 = arr5.length - 1;
          while (i5 < l5) {
            $pProperty = arr5[i5 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if (it.opts.patternGroups && $pgPropertyKeys.length) {
        var arr6 = $pgPropertyKeys;
        if (arr6) {
          var $pgProperty, i6 = -1, l6 = arr6.length - 1;
          while (i6 < l6) {
            $pgProperty = arr6[i6 += 1];
            var $pgSchema = $pgProperties[$pgProperty], $sch = $pgSchema.schema;
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternGroups" + it.util.getProperty($pgProperty) + ".schema";
              $it.errSchemaPath = it.errSchemaPath + "/patternGroups/" + it.util.escapeFragment($pgProperty) + "/schema";
              out += " var pgPropCount" + $lvl + " = 0;  ";
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pgProperty) + ".test(" + $key + ")) { pgPropCount" + $lvl + "++; ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
              var $pgMin = $pgSchema.minimum, $pgMax = $pgSchema.maximum;
              if ($pgMin !== void 0 || $pgMax !== void 0) {
                out += " var " + $valid + " = true; ";
                var $currErrSchemaPath = $errSchemaPath;
                if ($pgMin !== void 0) {
                  var $limit = $pgMin, $reason = "minimum", $moreOrLess = "less";
                  out += " " + $valid + " = pgPropCount" + $lvl + " >= " + $pgMin + "; ";
                  $errSchemaPath = it.errSchemaPath + "/patternGroups/minimum";
                  out += "  if (!" + $valid + ") {   ";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'patternGroups' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { reason: '" + $reason + "', limit: " + $limit + ", pattern: '" + it.util.escapeQuotes($pgProperty) + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should NOT have " + $moreOrLess + " than " + $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + `"' `;
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                  if ($pgMax !== void 0) {
                    out += " else ";
                  }
                }
                if ($pgMax !== void 0) {
                  var $limit = $pgMax, $reason = "maximum", $moreOrLess = "more";
                  out += " " + $valid + " = pgPropCount" + $lvl + " <= " + $pgMax + "; ";
                  $errSchemaPath = it.errSchemaPath + "/patternGroups/maximum";
                  out += "  if (!" + $valid + ") {   ";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'patternGroups' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { reason: '" + $reason + "', limit: " + $limit + ", pattern: '" + it.util.escapeQuotes($pgProperty) + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should NOT have " + $moreOrLess + " than " + $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + `"' `;
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  out += " if (" + $valid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
    "use strict";
    module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        out += " var " + $errs + " = errors; ";
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "node_modules/ajv/lib/dotjs/required.js"(exports, module) {
    "use strict";
    module.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
    "use strict";
    module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var " + $valid + " = true; if (" + $data + ".length > 1) { var i = " + $data + ".length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/compile/_rules.js
var require_rules = __commonJS({
  "node_modules/ajv/lib/compile/_rules.js"(exports, module) {
    "use strict";
    module.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate2()
    };
  }
});

// node_modules/ajv/lib/compile/rules.js
var require_rules2 = __commonJS({
  "node_modules/ajv/lib/compile/rules.js"(exports, module) {
    "use strict";
    var ruleModules = require_rules();
    var toHash = require_util2().toHash;
    module.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "uniqueItems", "contains", "items"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf"] }
      ];
      var ALL = ["type"];
      var KEYWORDS = [
        "additionalItems",
        "$schema",
        "$id",
        "id",
        "title",
        "description",
        "default",
        "definitions"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// node_modules/ajv/lib/$data.js
var require_data = __commonJS({
  "node_modules/ajv/lib/$data.js"(exports, module) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// node_modules/ajv/lib/patternGroups.js
var require_patternGroups = __commonJS({
  "node_modules/ajv/lib/patternGroups.js"(exports, module) {
    "use strict";
    var META_SCHEMA_ID = "http://json-schema.org/draft-06/schema";
    module.exports = function(ajv) {
      var defaultMeta = ajv._opts.defaultMeta;
      var metaSchemaRef = typeof defaultMeta == "string" ? { $ref: defaultMeta } : ajv.getSchema(META_SCHEMA_ID) ? { $ref: META_SCHEMA_ID } : {};
      ajv.addKeyword("patternGroups", {
        metaSchema: {
          type: "object",
          additionalProperties: {
            type: "object",
            required: ["schema"],
            properties: {
              maximum: {
                type: "integer",
                minimum: 0
              },
              minimum: {
                type: "integer",
                minimum: 0
              },
              schema: metaSchemaRef
            },
            additionalProperties: false
          }
        }
      });
      ajv.RULES.all.properties.implements.push("patternGroups");
    };
  }
});

// node_modules/ajv/lib/compile/async.js
var require_async = __commonJS({
  "node_modules/ajv/lib/compile/async.js"(exports, module) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(function(v) {
          callback(null, v);
        }, callback);
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
    "use strict";
    module.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "" + it.yieldAwait;
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = " + it.yieldAwait + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/lib/keyword.js"(exports, module) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        if (definition.macro && definition.valid !== void 0)
          throw new Error('"valid" option cannot be used with macro keywords');
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          var i, len = dataType.length;
          for (i = 0; i < len; i++)
            checkDataType(dataType[i]);
          for (i = 0; i < len; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          if (dataType)
            checkDataType(dataType);
          _addRule(keyword, dataType, definition);
        }
        var $data = definition.$data === true && this._opts.$data;
        if ($data && !definition.validate)
          throw new Error('$data support: "validate" function is not defined');
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if ($data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      function checkDataType(dataType2) {
        if (!RULES.types[dataType2])
          throw new Error("Unknown type " + dataType2);
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
  }
});

// node_modules/ajv/lib/refs/$data.json
var require_data2 = __commonJS({
  "node_modules/ajv/lib/refs/$data.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-06/schema#",
      $id: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#",
      description: "Meta-schema for $data reference (JSON-schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv/lib/refs/json-schema-draft-06.json
var require_json_schema_draft_06 = __commonJS({
  "node_modules/ajv/lib/refs/json-schema-draft-06.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-06/schema#",
      $id: "http://json-schema.org/draft-06/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: {},
        examples: {
          type: "array",
          items: {}
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: {}
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: {},
        enum: {
          type: "array",
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: {}
    };
  }
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/lib/ajv.js"(exports, module) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats2();
    var rules = require_rules2();
    var $dataMetaSchema = require_data();
    var patternGroups = require_patternGroups();
    var util = require_util2();
    var co = require_co();
    module.exports = Ajv;
    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-06/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      var schemaUriFormat = this._schemaUriFormat = this._formats["uri-reference"];
      this._schemaUriFormatFunc = function(str) {
        return schemaUriFormat.test(str);
      };
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      addDraft6MetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas(this);
      if (opts.patternGroups)
        patternGroups(this);
    }
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async === true)
        return this._opts.async == "*" ? co(valid) : valid;
      this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var currentUriFormat = this._formats.uri;
      this._formats.uri = typeof currentUriFormat == "function" ? this._schemaUriFormatFunc : this._schemaUriFormat;
      var valid;
      try {
        valid = this.validate($schema, schema);
      } finally {
        this._formats.uri = currentUriFormat;
      }
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(null, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "$id":
          return _get$Id;
        case "id":
          return _getId;
        default:
          return _get$IdOrId;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDraft6MetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_06();
      if (self2._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self2.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0)
          logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// node_modules/har-validator/lib/error.js
var require_error = __commonJS({
  "node_modules/har-validator/lib/error.js"(exports, module) {
    function HARError(errors) {
      var message = "validation failed";
      this.name = "HARError";
      this.message = message;
      this.errors = errors;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
    HARError.prototype = Error.prototype;
    module.exports = HARError;
  }
});

// node_modules/har-schema/lib/afterRequest.json
var require_afterRequest = __commonJS({
  "node_modules/har-schema/lib/afterRequest.json"(exports, module) {
    module.exports = {
      $id: "afterRequest.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "lastAccess",
        "eTag",
        "hitCount"
      ],
      properties: {
        expires: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        lastAccess: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        eTag: {
          type: "string"
        },
        hitCount: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/beforeRequest.json
var require_beforeRequest = __commonJS({
  "node_modules/har-schema/lib/beforeRequest.json"(exports, module) {
    module.exports = {
      $id: "beforeRequest.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "lastAccess",
        "eTag",
        "hitCount"
      ],
      properties: {
        expires: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        lastAccess: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        eTag: {
          type: "string"
        },
        hitCount: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/browser.json
var require_browser2 = __commonJS({
  "node_modules/har-schema/lib/browser.json"(exports, module) {
    module.exports = {
      $id: "browser.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "version"
      ],
      properties: {
        name: {
          type: "string"
        },
        version: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/cache.json
var require_cache2 = __commonJS({
  "node_modules/har-schema/lib/cache.json"(exports, module) {
    module.exports = {
      $id: "cache.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      properties: {
        beforeRequest: {
          oneOf: [
            { type: "null" },
            { $ref: "beforeRequest.json#" }
          ]
        },
        afterRequest: {
          oneOf: [
            { type: "null" },
            { $ref: "afterRequest.json#" }
          ]
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/content.json
var require_content = __commonJS({
  "node_modules/har-schema/lib/content.json"(exports, module) {
    module.exports = {
      $id: "content.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "size",
        "mimeType"
      ],
      properties: {
        size: {
          type: "integer"
        },
        compression: {
          type: "integer"
        },
        mimeType: {
          type: "string"
        },
        text: {
          type: "string"
        },
        encoding: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/cookie.json
var require_cookie2 = __commonJS({
  "node_modules/har-schema/lib/cookie.json"(exports, module) {
    module.exports = {
      $id: "cookie.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        path: {
          type: "string"
        },
        domain: {
          type: "string"
        },
        expires: {
          type: ["string", "null"],
          format: "date-time"
        },
        httpOnly: {
          type: "boolean"
        },
        secure: {
          type: "boolean"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/creator.json
var require_creator = __commonJS({
  "node_modules/har-schema/lib/creator.json"(exports, module) {
    module.exports = {
      $id: "creator.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "version"
      ],
      properties: {
        name: {
          type: "string"
        },
        version: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/entry.json
var require_entry = __commonJS({
  "node_modules/har-schema/lib/entry.json"(exports, module) {
    module.exports = {
      $id: "entry.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "startedDateTime",
        "time",
        "request",
        "response",
        "cache",
        "timings"
      ],
      properties: {
        pageref: {
          type: "string"
        },
        startedDateTime: {
          type: "string",
          format: "date-time",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
        },
        time: {
          type: "number",
          min: 0
        },
        request: {
          $ref: "request.json#"
        },
        response: {
          $ref: "response.json#"
        },
        cache: {
          $ref: "cache.json#"
        },
        timings: {
          $ref: "timings.json#"
        },
        serverIPAddress: {
          type: "string",
          oneOf: [
            { format: "ipv4" },
            { format: "ipv6" }
          ]
        },
        connection: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/har.json
var require_har = __commonJS({
  "node_modules/har-schema/lib/har.json"(exports, module) {
    module.exports = {
      $id: "har.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "log"
      ],
      properties: {
        log: {
          $ref: "log.json#"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/header.json
var require_header = __commonJS({
  "node_modules/har-schema/lib/header.json"(exports, module) {
    module.exports = {
      $id: "header.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/log.json
var require_log = __commonJS({
  "node_modules/har-schema/lib/log.json"(exports, module) {
    module.exports = {
      $id: "log.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "version",
        "creator",
        "entries"
      ],
      properties: {
        version: {
          type: "string"
        },
        creator: {
          $ref: "creator.json#"
        },
        browser: {
          $ref: "browser.json#"
        },
        pages: {
          type: "array",
          items: {
            $ref: "page.json#"
          }
        },
        entries: {
          type: "array",
          items: {
            $ref: "entry.json#"
          }
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/page.json
var require_page = __commonJS({
  "node_modules/har-schema/lib/page.json"(exports, module) {
    module.exports = {
      $id: "page.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "startedDateTime",
        "id",
        "title",
        "pageTimings"
      ],
      properties: {
        startedDateTime: {
          type: "string",
          format: "date-time",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
        },
        id: {
          type: "string",
          unique: true
        },
        title: {
          type: "string"
        },
        pageTimings: {
          $ref: "pageTimings.json#"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/pageTimings.json
var require_pageTimings = __commonJS({
  "node_modules/har-schema/lib/pageTimings.json"(exports, module) {
    module.exports = {
      $id: "pageTimings.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      properties: {
        onContentLoad: {
          type: "number",
          min: -1
        },
        onLoad: {
          type: "number",
          min: -1
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/postData.json
var require_postData = __commonJS({
  "node_modules/har-schema/lib/postData.json"(exports, module) {
    module.exports = {
      $id: "postData.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "mimeType"
      ],
      properties: {
        mimeType: {
          type: "string"
        },
        text: {
          type: "string"
        },
        params: {
          type: "array",
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            value: {
              type: "string"
            },
            fileName: {
              type: "string"
            },
            contentType: {
              type: "string"
            },
            comment: {
              type: "string"
            }
          }
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/query.json
var require_query = __commonJS({
  "node_modules/har-schema/lib/query.json"(exports, module) {
    module.exports = {
      $id: "query.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/request.json
var require_request = __commonJS({
  "node_modules/har-schema/lib/request.json"(exports, module) {
    module.exports = {
      $id: "request.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "method",
        "url",
        "httpVersion",
        "cookies",
        "headers",
        "queryString",
        "headersSize",
        "bodySize"
      ],
      properties: {
        method: {
          type: "string"
        },
        url: {
          type: "string",
          format: "uri"
        },
        httpVersion: {
          type: "string"
        },
        cookies: {
          type: "array",
          items: {
            $ref: "cookie.json#"
          }
        },
        headers: {
          type: "array",
          items: {
            $ref: "header.json#"
          }
        },
        queryString: {
          type: "array",
          items: {
            $ref: "query.json#"
          }
        },
        postData: {
          $ref: "postData.json#"
        },
        headersSize: {
          type: "integer"
        },
        bodySize: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/response.json
var require_response = __commonJS({
  "node_modules/har-schema/lib/response.json"(exports, module) {
    module.exports = {
      $id: "response.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "status",
        "statusText",
        "httpVersion",
        "cookies",
        "headers",
        "content",
        "redirectURL",
        "headersSize",
        "bodySize"
      ],
      properties: {
        status: {
          type: "integer"
        },
        statusText: {
          type: "string"
        },
        httpVersion: {
          type: "string"
        },
        cookies: {
          type: "array",
          items: {
            $ref: "cookie.json#"
          }
        },
        headers: {
          type: "array",
          items: {
            $ref: "header.json#"
          }
        },
        content: {
          $ref: "content.json#"
        },
        redirectURL: {
          type: "string"
        },
        headersSize: {
          type: "integer"
        },
        bodySize: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/timings.json
var require_timings = __commonJS({
  "node_modules/har-schema/lib/timings.json"(exports, module) {
    module.exports = {
      $id: "timings.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      required: [
        "send",
        "wait",
        "receive"
      ],
      properties: {
        dns: {
          type: "number",
          min: -1
        },
        connect: {
          type: "number",
          min: -1
        },
        blocked: {
          type: "number",
          min: -1
        },
        send: {
          type: "number",
          min: -1
        },
        wait: {
          type: "number",
          min: -1
        },
        receive: {
          type: "number",
          min: -1
        },
        ssl: {
          type: "number",
          min: -1
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// node_modules/har-schema/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/har-schema/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      afterRequest: require_afterRequest(),
      beforeRequest: require_beforeRequest(),
      browser: require_browser2(),
      cache: require_cache2(),
      content: require_content(),
      cookie: require_cookie2(),
      creator: require_creator(),
      entry: require_entry(),
      har: require_har(),
      header: require_header(),
      log: require_log(),
      page: require_page(),
      pageTimings: require_pageTimings(),
      postData: require_postData(),
      query: require_query(),
      request: require_request(),
      response: require_response(),
      timings: require_timings()
    };
  }
});

// node_modules/har-validator/lib/promise.js
var require_promise = __commonJS({
  "node_modules/har-validator/lib/promise.js"(exports) {
    var Ajv = require_ajv();
    var HARError = require_error();
    var schemas = require_lib6();
    var ajv;
    function validate(name, data) {
      data = data || {};
      ajv = ajv || new Ajv({
        allErrors: true,
        schemas
      });
      var validate2 = ajv.getSchema(name + ".json");
      return new Promise(function(resolve, reject) {
        var valid = validate2(data);
        !valid ? reject(new HARError(validate2.errors)) : resolve(data);
      });
    }
    exports.afterRequest = function(data) {
      return validate("afterRequest", data);
    };
    exports.beforeRequest = function(data) {
      return validate("beforeRequest", data);
    };
    exports.browser = function(data) {
      return validate("browser", data);
    };
    exports.cache = function(data) {
      return validate("cache", data);
    };
    exports.content = function(data) {
      return validate("content", data);
    };
    exports.cookie = function(data) {
      return validate("cookie", data);
    };
    exports.creator = function(data) {
      return validate("creator", data);
    };
    exports.entry = function(data) {
      return validate("entry", data);
    };
    exports.har = function(data) {
      return validate("har", data);
    };
    exports.header = function(data) {
      return validate("header", data);
    };
    exports.log = function(data) {
      return validate("log", data);
    };
    exports.page = function(data) {
      return validate("page", data);
    };
    exports.pageTimings = function(data) {
      return validate("pageTimings", data);
    };
    exports.postData = function(data) {
      return validate("postData", data);
    };
    exports.query = function(data) {
      return validate("query", data);
    };
    exports.request = function(data) {
      return validate("request", data);
    };
    exports.response = function(data) {
      return validate("response", data);
    };
    exports.timings = function(data) {
      return validate("timings", data);
    };
  }
});

// node_modules/request/lib/har.js
var require_har2 = __commonJS({
  "node_modules/request/lib/har.js"(exports) {
    "use strict";
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var qs = (init_querystring(), __toCommonJS(querystring_exports));
    var validate = require_promise();
    var extend = require_extend();
    function Har(request) {
      this.request = request;
    }
    Har.prototype.reducer = function(obj, pair) {
      if (obj[pair.name] === void 0) {
        obj[pair.name] = pair.value;
        return obj;
      }
      var arr = [
        obj[pair.name],
        pair.value
      ];
      obj[pair.name] = arr;
      return obj;
    };
    Har.prototype.prep = function(data) {
      data.queryObj = {};
      data.headersObj = {};
      data.postData.jsonObj = false;
      data.postData.paramsObj = false;
      if (data.queryString && data.queryString.length) {
        data.queryObj = data.queryString.reduce(this.reducer, {});
      }
      if (data.headers && data.headers.length) {
        data.headersObj = data.headers.reduceRight(function(headers, header) {
          headers[header.name] = header.value;
          return headers;
        }, {});
      }
      if (data.cookies && data.cookies.length) {
        var cookies = data.cookies.map(function(cookie) {
          return cookie.name + "=" + cookie.value;
        });
        if (cookies.length) {
          data.headersObj.cookie = cookies.join("; ");
        }
      }
      function some(arr) {
        return arr.some(function(type) {
          return data.postData.mimeType.indexOf(type) === 0;
        });
      }
      if (some([
        "multipart/mixed",
        "multipart/related",
        "multipart/form-data",
        "multipart/alternative"
      ])) {
        data.postData.mimeType = "multipart/form-data";
      } else if (some([
        "application/x-www-form-urlencoded"
      ])) {
        if (!data.postData.params) {
          data.postData.text = "";
        } else {
          data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});
          data.postData.text = qs.stringify(data.postData.paramsObj);
        }
      } else if (some([
        "text/json",
        "text/x-json",
        "application/json",
        "application/x-json"
      ])) {
        data.postData.mimeType = "application/json";
        if (data.postData.text) {
          try {
            data.postData.jsonObj = JSON.parse(data.postData.text);
          } catch (e) {
            this.request.debug(e);
            data.postData.mimeType = "text/plain";
          }
        }
      }
      return data;
    };
    Har.prototype.options = function(options) {
      if (!options.har) {
        return options;
      }
      var har = {};
      extend(har, options.har);
      if (har.log && har.log.entries) {
        har = har.log.entries[0];
      }
      har.url = har.url || options.url || options.uri || options.baseUrl || "/";
      har.httpVersion = har.httpVersion || "HTTP/1.1";
      har.queryString = har.queryString || [];
      har.headers = har.headers || [];
      har.cookies = har.cookies || [];
      har.postData = har.postData || {};
      har.postData.mimeType = har.postData.mimeType || "application/octet-stream";
      har.bodySize = 0;
      har.headersSize = 0;
      har.postData.size = 0;
      if (!validate.request(har)) {
        return options;
      }
      var req = this.prep(har);
      if (req.url) {
        options.url = req.url;
      }
      if (req.method) {
        options.method = req.method;
      }
      if (Object.keys(req.queryObj).length) {
        options.qs = req.queryObj;
      }
      if (Object.keys(req.headersObj).length) {
        options.headers = req.headersObj;
      }
      function test(type) {
        return req.postData.mimeType.indexOf(type) === 0;
      }
      if (test("application/x-www-form-urlencoded")) {
        options.form = req.postData.paramsObj;
      } else if (test("application/json")) {
        if (req.postData.jsonObj) {
          options.body = req.postData.jsonObj;
          options.json = true;
        }
      } else if (test("multipart/form-data")) {
        options.formData = {};
        req.postData.params.forEach(function(param) {
          var attachment = {};
          if (!param.fileName && !param.fileName && !param.contentType) {
            options.formData[param.name] = param.value;
            return;
          }
          if (param.fileName && !param.value) {
            attachment.value = fs.createReadStream(param.fileName);
          } else if (param.value) {
            attachment.value = param.value;
          }
          if (param.fileName) {
            attachment.options = {
              filename: param.fileName,
              contentType: param.contentType ? param.contentType : null
            };
          }
          options.formData[param.name] = attachment;
        });
      } else {
        if (req.postData.text) {
          options.body = req.postData.text;
        }
      }
      return options;
    };
    exports.Har = Har;
  }
});

// node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/v1.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v1;
  }
});

// node_modules/uuid/index.js
var require_uuid = __commonJS({
  "node_modules/uuid/index.js"(exports, module) {
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module.exports = uuid;
  }
});

// node_modules/request/lib/auth.js
var require_auth = __commonJS({
  "node_modules/request/lib/auth.js"(exports) {
    "use strict";
    var caseless = require_caseless();
    var uuid = require_uuid();
    var helpers = require_helpers();
    var md5 = helpers.md5;
    var toBase64 = helpers.toBase64;
    function Auth(request) {
      this.request = request;
      this.hasAuth = false;
      this.sentAuth = false;
      this.bearerToken = null;
      this.user = null;
      this.pass = null;
    }
    Auth.prototype.basic = function(user, pass, sendImmediately) {
      var self2 = this;
      if (typeof user !== "string" || pass !== void 0 && typeof pass !== "string") {
        self2.request.emit("error", new Error("auth() received invalid user or password"));
      }
      self2.user = user;
      self2.pass = pass;
      self2.hasAuth = true;
      var header = user + ":" + (pass || "");
      if (sendImmediately || typeof sendImmediately === "undefined") {
        var authHeader = "Basic " + toBase64(header);
        self2.sentAuth = true;
        return authHeader;
      }
    };
    Auth.prototype.bearer = function(bearer, sendImmediately) {
      var self2 = this;
      self2.bearerToken = bearer;
      self2.hasAuth = true;
      if (sendImmediately || typeof sendImmediately === "undefined") {
        if (typeof bearer === "function") {
          bearer = bearer();
        }
        var authHeader = "Bearer " + (bearer || "");
        self2.sentAuth = true;
        return authHeader;
      }
    };
    Auth.prototype.digest = function(method, path, authHeader) {
      var self2 = this;
      var challenge = {};
      var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
      for (; ; ) {
        var match = re.exec(authHeader);
        if (!match) {
          break;
        }
        challenge[match[1]] = match[2] || match[3];
      }
      var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
        var ha12 = md5(user + ":" + realm + ":" + pass);
        if (algorithm && algorithm.toLowerCase() === "md5-sess") {
          return md5(ha12 + ":" + nonce + ":" + cnonce2);
        } else {
          return ha12;
        }
      };
      var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
      var nc = qop && "00000001";
      var cnonce = qop && uuid().replace(/-/g, "");
      var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
      var ha2 = md5(method + ":" + path);
      var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
      var authValues = {
        username: self2.user,
        realm: challenge.realm,
        nonce: challenge.nonce,
        uri: path,
        qop,
        response: digestResponse,
        nc,
        cnonce,
        algorithm: challenge.algorithm,
        opaque: challenge.opaque
      };
      authHeader = [];
      for (var k in authValues) {
        if (authValues[k]) {
          if (k === "qop" || k === "nc" || k === "algorithm") {
            authHeader.push(k + "=" + authValues[k]);
          } else {
            authHeader.push(k + '="' + authValues[k] + '"');
          }
        }
      }
      authHeader = "Digest " + authHeader.join(", ");
      self2.sentAuth = true;
      return authHeader;
    };
    Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
      var self2 = this;
      var request = self2.request;
      var authHeader;
      if (bearer === void 0 && user === void 0) {
        self2.request.emit("error", new Error("no auth mechanism defined"));
      } else if (bearer !== void 0) {
        authHeader = self2.bearer(bearer, sendImmediately);
      } else {
        authHeader = self2.basic(user, pass, sendImmediately);
      }
      if (authHeader) {
        request.setHeader("authorization", authHeader);
      }
    };
    Auth.prototype.onResponse = function(response) {
      var self2 = this;
      var request = self2.request;
      if (!self2.hasAuth || self2.sentAuth) {
        return null;
      }
      var c = caseless(response.headers);
      var authHeader = c.get("www-authenticate");
      var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
      request.debug("reauth", authVerb);
      switch (authVerb) {
        case "basic":
          return self2.basic(self2.user, self2.pass, true);
        case "bearer":
          return self2.bearer(self2.bearerToken, true);
        case "digest":
          return self2.digest(request.method, request.path, authHeader);
      }
    };
    exports.Auth = Auth;
  }
});

// node_modules/oauth-sign/index.js
var require_oauth_sign = __commonJS({
  "node_modules/oauth-sign/index.js"(exports) {
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var qs = (init_querystring(), __toCommonJS(querystring_exports));
    function sha1(key, body) {
      return crypto.createHmac("sha1", key).update(body).digest("base64");
    }
    function rsa(key, body) {
      return crypto.createSign("RSA-SHA1").update(body).sign(key, "base64");
    }
    function rfc3986(str) {
      return encodeURIComponent(str).replace(/!/g, "%21").replace(/\*/g, "%2A").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27");
    }
    function map(obj) {
      var key, val, arr = [];
      for (key in obj) {
        val = obj[key];
        if (Array.isArray(val))
          for (var i = 0; i < val.length; i++)
            arr.push([key, val[i]]);
        else if (typeof val === "object")
          for (var prop in val)
            arr.push([key + "[" + prop + "]", val[prop]]);
        else
          arr.push([key, val]);
      }
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function generateBase(httpMethod, base_uri, params) {
      var normalized = map(params).map(function(p) {
        return [rfc3986(p[0]), rfc3986(p[1] || "")];
      }).sort(function(a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1]);
      }).map(function(p) {
        return p.join("=");
      }).join("&");
      var base = [
        rfc3986(httpMethod ? httpMethod.toUpperCase() : "GET"),
        rfc3986(base_uri),
        rfc3986(normalized)
      ].join("&");
      return base;
    }
    function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return sha1(key, base);
    }
    function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = private_key || "";
      return rsa(key, base);
    }
    function plaintext(consumer_secret, token_secret) {
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return key;
    }
    function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
      var method;
      var skipArgs = 1;
      switch (signMethod) {
        case "RSA-SHA1":
          method = rsasign;
          break;
        case "HMAC-SHA1":
          method = hmacsign;
          break;
        case "PLAINTEXT":
          method = plaintext;
          skipArgs = 4;
          break;
        default:
          throw new Error("Signature method not supported: " + signMethod);
      }
      return method.apply(null, [].slice.call(arguments, skipArgs));
    }
    exports.hmacsign = hmacsign;
    exports.rsasign = rsasign;
    exports.plaintext = plaintext;
    exports.sign = sign;
    exports.rfc3986 = rfc3986;
    exports.generateBase = generateBase;
  }
});

// node_modules/request/lib/oauth.js
var require_oauth = __commonJS({
  "node_modules/request/lib/oauth.js"(exports) {
    "use strict";
    var url = (init_url(), __toCommonJS(url_exports));
    var qs = require_lib5();
    var caseless = require_caseless();
    var uuid = require_uuid();
    var oauth = require_oauth_sign();
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    var Buffer2 = require_safe_buffer().Buffer;
    function OAuth(request) {
      this.request = request;
      this.params = null;
    }
    OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
      var oa = {};
      for (var i in _oauth) {
        oa["oauth_" + i] = _oauth[i];
      }
      if (!oa.oauth_version) {
        oa.oauth_version = "1.0";
      }
      if (!oa.oauth_timestamp) {
        oa.oauth_timestamp = Math.floor(Date.now() / 1e3).toString();
      }
      if (!oa.oauth_nonce) {
        oa.oauth_nonce = uuid().replace(/-/g, "");
      }
      if (!oa.oauth_signature_method) {
        oa.oauth_signature_method = "HMAC-SHA1";
      }
      var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key;
      delete oa.oauth_consumer_secret;
      delete oa.oauth_private_key;
      var token_secret = oa.oauth_token_secret;
      delete oa.oauth_token_secret;
      var realm = oa.oauth_realm;
      delete oa.oauth_realm;
      delete oa.oauth_transport_method;
      var baseurl = uri.protocol + "//" + uri.host + uri.pathname;
      var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join("&"));
      oa.oauth_signature = oauth.sign(oa.oauth_signature_method, method, baseurl, params, consumer_secret_or_private_key, token_secret);
      if (realm) {
        oa.realm = realm;
      }
      return oa;
    };
    OAuth.prototype.buildBodyHash = function(_oauth, body) {
      if (["HMAC-SHA1", "RSA-SHA1"].indexOf(_oauth.signature_method || "HMAC-SHA1") < 0) {
        this.request.emit("error", new Error("oauth: " + _oauth.signature_method + " signature_method not supported with body_hash signing."));
      }
      var shasum = crypto.createHash("sha1");
      shasum.update(body || "");
      var sha1 = shasum.digest("hex");
      return Buffer2.from(sha1, "hex").toString("base64");
    };
    OAuth.prototype.concatParams = function(oa, sep, wrap) {
      wrap = wrap || "";
      var params = Object.keys(oa).filter(function(i) {
        return i !== "realm" && i !== "oauth_signature";
      }).sort();
      if (oa.realm) {
        params.splice(0, 0, "realm");
      }
      params.push("oauth_signature");
      return params.map(function(i) {
        return i + "=" + wrap + oauth.rfc3986(oa[i]) + wrap;
      }).join(sep);
    };
    OAuth.prototype.onRequest = function(_oauth) {
      var self2 = this;
      self2.params = _oauth;
      var uri = self2.request.uri || {};
      var method = self2.request.method || "";
      var headers = caseless(self2.request.headers);
      var body = self2.request.body || "";
      var qsLib = self2.request.qsLib || qs;
      var form;
      var query;
      var contentType = headers.get("content-type") || "";
      var formContentType = "application/x-www-form-urlencoded";
      var transport = _oauth.transport_method || "header";
      if (contentType.slice(0, formContentType.length) === formContentType) {
        contentType = formContentType;
        form = body;
      }
      if (uri.query) {
        query = uri.query;
      }
      if (transport === "body" && (method !== "POST" || contentType !== formContentType)) {
        self2.request.emit("error", new Error("oauth: transport_method of body requires POST and content-type " + formContentType));
      }
      if (!form && typeof _oauth.body_hash === "boolean") {
        _oauth.body_hash = self2.buildBodyHash(_oauth, self2.request.body.toString());
      }
      var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
      switch (transport) {
        case "header":
          self2.request.setHeader("Authorization", "OAuth " + self2.concatParams(oa, ",", '"'));
          break;
        case "query":
          var href = self2.request.uri.href += (query ? "&" : "?") + self2.concatParams(oa, "&");
          self2.request.uri = url.parse(href);
          self2.request.path = self2.request.uri.path;
          break;
        case "body":
          self2.request.body = (form ? form + "&" : "") + self2.concatParams(oa, "&");
          break;
        default:
          self2.request.emit("error", new Error("oauth: transport_method invalid"));
      }
    };
    exports.OAuth = OAuth;
  }
});

// node_modules/request/lib/hawk.js
var require_hawk = __commonJS({
  "node_modules/request/lib/hawk.js"(exports) {
    "use strict";
    var crypto = (init_crypto(), __toCommonJS(crypto_exports));
    function randomString(size) {
      var bits = (size + 1) * 6;
      var buffer = crypto.randomBytes(Math.ceil(bits / 8));
      var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      return string.slice(0, size);
    }
    function calculatePayloadHash(payload, algorithm, contentType) {
      var hash = crypto.createHash(algorithm);
      hash.update("hawk.1.payload\n");
      hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + "\n");
      hash.update(payload || "");
      hash.update("\n");
      return hash.digest("base64");
    }
    exports.calculateMac = function(credentials, opts) {
      var normalized = "hawk.1.header\n" + opts.ts + "\n" + opts.nonce + "\n" + (opts.method || "").toUpperCase() + "\n" + opts.resource + "\n" + opts.host.toLowerCase() + "\n" + opts.port + "\n" + (opts.hash || "") + "\n";
      if (opts.ext) {
        normalized = normalized + opts.ext.replace("\\", "\\\\").replace("\n", "\\n");
      }
      normalized = normalized + "\n";
      if (opts.app) {
        normalized = normalized + opts.app + "\n" + (opts.dlg || "") + "\n";
      }
      var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
      var digest = hmac.digest("base64");
      return digest;
    };
    exports.header = function(uri, method, opts) {
      var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1e3);
      var credentials = opts.credentials;
      if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
        return "";
      }
      if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
        return "";
      }
      var artifacts = {
        ts: timestamp,
        nonce: opts.nonce || randomString(6),
        method,
        resource: uri.pathname + (uri.search || ""),
        host: uri.hostname,
        port: uri.port || (uri.protocol === "http:" ? 80 : 443),
        hash: opts.hash,
        ext: opts.ext,
        app: opts.app,
        dlg: opts.dlg
      };
      if (!artifacts.hash && (opts.payload || opts.payload === "")) {
        artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
      }
      var mac = exports.calculateMac(credentials, artifacts);
      var hasExt = artifacts.ext !== null && artifacts.ext !== void 0 && artifacts.ext !== "";
      var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, '\\"') : "") + '", mac="' + mac + '"';
      if (artifacts.app) {
        header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
      }
      return header;
    };
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
    var Stream = (init_stream(), __toCommonJS(stream_exports)).Stream;
    var util = (init_util(), __toCommonJS(util_exports));
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
    var util = (init_util(), __toCommonJS(util_exports));
    var Stream = (init_stream(), __toCommonJS(stream_exports)).Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/request/lib/multipart.js
var require_multipart = __commonJS({
  "node_modules/request/lib/multipart.js"(exports) {
    "use strict";
    var uuid = require_uuid();
    var CombinedStream = require_combined_stream();
    var isstream = require_isstream();
    var Buffer2 = require_safe_buffer().Buffer;
    function Multipart(request) {
      this.request = request;
      this.boundary = uuid();
      this.chunked = false;
      this.body = null;
    }
    Multipart.prototype.isChunked = function(options) {
      var self2 = this;
      var chunked = false;
      var parts = options.data || options;
      if (!parts.forEach) {
        self2.request.emit("error", new Error("Argument error, options.multipart."));
      }
      if (options.chunked !== void 0) {
        chunked = options.chunked;
      }
      if (self2.request.getHeader("transfer-encoding") === "chunked") {
        chunked = true;
      }
      if (!chunked) {
        parts.forEach(function(part) {
          if (typeof part.body === "undefined") {
            self2.request.emit("error", new Error("Body attribute missing in multipart."));
          }
          if (isstream(part.body)) {
            chunked = true;
          }
        });
      }
      return chunked;
    };
    Multipart.prototype.setHeaders = function(chunked) {
      var self2 = this;
      if (chunked && !self2.request.hasHeader("transfer-encoding")) {
        self2.request.setHeader("transfer-encoding", "chunked");
      }
      var header = self2.request.getHeader("content-type");
      if (!header || header.indexOf("multipart") === -1) {
        self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
      } else {
        if (header.indexOf("boundary") !== -1) {
          self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
        } else {
          self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
        }
      }
    };
    Multipart.prototype.build = function(parts, chunked) {
      var self2 = this;
      var body = chunked ? new CombinedStream() : [];
      function add(part) {
        if (typeof part === "number") {
          part = part.toString();
        }
        return chunked ? body.append(part) : body.push(Buffer2.from(part));
      }
      if (self2.request.preambleCRLF) {
        add("\r\n");
      }
      parts.forEach(function(part) {
        var preamble = "--" + self2.boundary + "\r\n";
        Object.keys(part).forEach(function(key) {
          if (key === "body") {
            return;
          }
          preamble += key + ": " + part[key] + "\r\n";
        });
        preamble += "\r\n";
        add(preamble);
        add(part.body);
        add("\r\n");
      });
      add("--" + self2.boundary + "--");
      if (self2.request.postambleCRLF) {
        add("\r\n");
      }
      return body;
    };
    Multipart.prototype.onRequest = function(options) {
      var self2 = this;
      var chunked = self2.isChunked(options);
      var parts = options.data || options;
      self2.setHeaders(chunked);
      self2.chunked = chunked;
      self2.body = self2.build(parts, chunked);
    };
    exports.Multipart = Multipart;
  }
});

// node_modules/request/lib/redirect.js
var require_redirect = __commonJS({
  "node_modules/request/lib/redirect.js"(exports) {
    "use strict";
    var url = (init_url(), __toCommonJS(url_exports));
    var isUrl = /^https?:/;
    function Redirect(request) {
      this.request = request;
      this.followRedirect = true;
      this.followRedirects = true;
      this.followAllRedirects = false;
      this.followOriginalHttpMethod = false;
      this.allowRedirect = function() {
        return true;
      };
      this.maxRedirects = 10;
      this.redirects = [];
      this.redirectsFollowed = 0;
      this.removeRefererHeader = false;
    }
    Redirect.prototype.onRequest = function(options) {
      var self2 = this;
      if (options.maxRedirects !== void 0) {
        self2.maxRedirects = options.maxRedirects;
      }
      if (typeof options.followRedirect === "function") {
        self2.allowRedirect = options.followRedirect;
      }
      if (options.followRedirect !== void 0) {
        self2.followRedirects = !!options.followRedirect;
      }
      if (options.followAllRedirects !== void 0) {
        self2.followAllRedirects = options.followAllRedirects;
      }
      if (self2.followRedirects || self2.followAllRedirects) {
        self2.redirects = self2.redirects || [];
      }
      if (options.removeRefererHeader !== void 0) {
        self2.removeRefererHeader = options.removeRefererHeader;
      }
      if (options.followOriginalHttpMethod !== void 0) {
        self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
      }
    };
    Redirect.prototype.redirectTo = function(response) {
      var self2 = this;
      var request = self2.request;
      var redirectTo = null;
      if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has("location")) {
        var location = response.caseless.get("location");
        request.debug("redirect", location);
        if (self2.followAllRedirects) {
          redirectTo = location;
        } else if (self2.followRedirects) {
          switch (request.method) {
            case "PATCH":
            case "PUT":
            case "POST":
            case "DELETE":
              break;
            default:
              redirectTo = location;
              break;
          }
        }
      } else if (response.statusCode === 401) {
        var authHeader = request._auth.onResponse(response);
        if (authHeader) {
          request.setHeader("authorization", authHeader);
          redirectTo = request.uri;
        }
      }
      return redirectTo;
    };
    Redirect.prototype.onResponse = function(response) {
      var self2 = this;
      var request = self2.request;
      var redirectTo = self2.redirectTo(response);
      if (!redirectTo || !self2.allowRedirect.call(request, response)) {
        return false;
      }
      request.debug("redirect to", redirectTo);
      if (response.resume) {
        response.resume();
      }
      if (self2.redirectsFollowed >= self2.maxRedirects) {
        request.emit("error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request.uri.href));
        return false;
      }
      self2.redirectsFollowed += 1;
      if (!isUrl.test(redirectTo)) {
        redirectTo = url.resolve(request.uri.href, redirectTo);
      }
      var uriPrev = request.uri;
      request.uri = url.parse(redirectTo);
      if (request.uri.protocol !== uriPrev.protocol) {
        delete request.agent;
      }
      self2.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });
      if (self2.followAllRedirects && request.method !== "HEAD" && response.statusCode !== 401 && response.statusCode !== 307) {
        request.method = self2.followOriginalHttpMethod ? request.method : "GET";
      }
      delete request.src;
      delete request.req;
      delete request._started;
      if (response.statusCode !== 401 && response.statusCode !== 307) {
        delete request.body;
        delete request._form;
        if (request.headers) {
          request.removeHeader("host");
          request.removeHeader("content-type");
          request.removeHeader("content-length");
          if (request.uri.hostname !== request.originalHost.split(":")[0]) {
            request.removeHeader("authorization");
          }
        }
      }
      if (!self2.removeRefererHeader) {
        request.setHeader("referer", uriPrev.href);
      }
      request.emit("redirect");
      request.init();
      return true;
    };
    exports.Redirect = Redirect;
  }
});

// node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS({
  "node_modules/tunnel-agent/index.js"(exports) {
    "use strict";
    var net = (init_net(), __toCommonJS(net_exports));
    var tls = (init_tls(), __toCommonJS(tls_exports));
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var events = (init_events(), __toCommonJS(events_exports));
    var assert = (init_assert(), __toCommonJS(assert_exports));
    var util = (init_util(), __toCommonJS(util_exports));
    var Buffer2 = require_safe_buffer().Buffer;
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port) {
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === host && pending.port === port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self2 = this;
      if (typeof options === "string") {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push({ host: options.host, port: options.port, request: req });
        return;
      }
      self2.createConnection({ host: options.host, port: options.port, request: req });
    };
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self2 = this;
      self2.createSocket(pending, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        pending.request.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, pending.host, pending.port);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false
      });
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
          assert.equal(head.length, 0);
          debug("tunneling connection has established");
          self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
          cb(socket);
        } else {
          debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
        }
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1)
        return;
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createConnection(pending);
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var secureSocket = tls.connect(0, mergeOptions({}, self2.options, {
          servername: options.host,
          socket
        }));
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.debug = debug;
  }
});

// node_modules/request/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/request/lib/tunnel.js"(exports) {
    "use strict";
    var url = (init_url(), __toCommonJS(url_exports));
    var tunnel = require_tunnel_agent();
    var defaultProxyHeaderWhiteList = [
      "accept",
      "accept-charset",
      "accept-encoding",
      "accept-language",
      "accept-ranges",
      "cache-control",
      "content-encoding",
      "content-language",
      "content-location",
      "content-md5",
      "content-range",
      "content-type",
      "connection",
      "date",
      "expect",
      "max-forwards",
      "pragma",
      "referer",
      "te",
      "user-agent",
      "via"
    ];
    var defaultProxyHeaderExclusiveList = [
      "proxy-authorization"
    ];
    function constructProxyHost(uriObject) {
      var port = uriObject.port;
      var protocol = uriObject.protocol;
      var proxyHost = uriObject.hostname + ":";
      if (port) {
        proxyHost += port;
      } else if (protocol === "https:") {
        proxyHost += "443";
      } else {
        proxyHost += "80";
      }
      return proxyHost;
    }
    function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
      var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
        set[header.toLowerCase()] = true;
        return set;
      }, {});
      return Object.keys(headers).filter(function(header) {
        return whiteList[header.toLowerCase()];
      }).reduce(function(set, header) {
        set[header] = headers[header];
        return set;
      }, {});
    }
    function constructTunnelOptions(request, proxyHeaders) {
      var proxy = request.proxy;
      var tunnelOptions = {
        proxy: {
          host: proxy.hostname,
          port: +proxy.port,
          proxyAuth: proxy.auth,
          headers: proxyHeaders
        },
        headers: request.headers,
        ca: request.ca,
        cert: request.cert,
        key: request.key,
        passphrase: request.passphrase,
        pfx: request.pfx,
        ciphers: request.ciphers,
        rejectUnauthorized: request.rejectUnauthorized,
        secureOptions: request.secureOptions,
        secureProtocol: request.secureProtocol
      };
      return tunnelOptions;
    }
    function constructTunnelFnName(uri, proxy) {
      var uriProtocol = uri.protocol === "https:" ? "https" : "http";
      var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
      return [uriProtocol, proxyProtocol].join("Over");
    }
    function getTunnelFn(request) {
      var uri = request.uri;
      var proxy = request.proxy;
      var tunnelFnName = constructTunnelFnName(uri, proxy);
      return tunnel[tunnelFnName];
    }
    function Tunnel(request) {
      this.request = request;
      this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
      this.proxyHeaderExclusiveList = [];
      if (typeof request.tunnel !== "undefined") {
        this.tunnelOverride = request.tunnel;
      }
    }
    Tunnel.prototype.isEnabled = function() {
      var self2 = this;
      var request = self2.request;
      if (typeof self2.tunnelOverride !== "undefined") {
        return self2.tunnelOverride;
      }
      if (request.uri.protocol === "https:") {
        return true;
      }
      return false;
    };
    Tunnel.prototype.setup = function(options) {
      var self2 = this;
      var request = self2.request;
      options = options || {};
      if (typeof request.proxy === "string") {
        request.proxy = url.parse(request.proxy);
      }
      if (!request.proxy || !request.tunnel) {
        return false;
      }
      if (options.proxyHeaderWhiteList) {
        self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
      }
      if (options.proxyHeaderExclusiveList) {
        self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
      }
      var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
      var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
      var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
      proxyHeaders.host = constructProxyHost(request.uri);
      proxyHeaderExclusiveList.forEach(request.removeHeader, request);
      var tunnelFn = getTunnelFn(request);
      var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
      request.agent = tunnelFn(tunnelOptions);
      return true;
    };
    Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
    exports.Tunnel = Tunnel;
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(exports);
  }
});

// node_modules/request/request.js
var require_request2 = __commonJS({
  "node_modules/request/request.js"(exports, module) {
    "use strict";
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var url = (init_url(), __toCommonJS(url_exports));
    var util = (init_util(), __toCommonJS(util_exports));
    var stream = (init_stream(), __toCommonJS(stream_exports));
    var zlib = (init_zlib(), __toCommonJS(zlib_exports));
    var aws2 = require_aws_sign2();
    var aws4 = require_aws4();
    var httpSignature = require_lib4();
    var mime = require_mime_types();
    var caseless = require_caseless();
    var ForeverAgent = require_forever_agent();
    var FormData = require_browser();
    var extend = require_extend();
    var isstream = require_isstream();
    var isTypedArray = require_is_typedarray().strict;
    var helpers = require_helpers();
    var cookies = require_cookies();
    var getProxyFromURI = require_getProxyFromURI();
    var Querystring = require_querystring().Querystring;
    var Har = require_har2().Har;
    var Auth = require_auth().Auth;
    var OAuth = require_oauth().OAuth;
    var hawk = require_hawk();
    var Multipart = require_multipart().Multipart;
    var Redirect = require_redirect().Redirect;
    var Tunnel = require_tunnel().Tunnel;
    var now = require_performance_now();
    var Buffer2 = require_safe_buffer().Buffer;
    var safeStringify = helpers.safeStringify;
    var isReadStream = helpers.isReadStream;
    var toBase64 = helpers.toBase64;
    var defer = helpers.defer;
    var copy = helpers.copy;
    var version = helpers.version;
    var globalCookieJar = cookies.jar();
    var globalPool = {};
    function filterForNonReserved(reserved, options) {
      var object = {};
      for (var i in options) {
        var notReserved = reserved.indexOf(i) === -1;
        if (notReserved) {
          object[i] = options[i];
        }
      }
      return object;
    }
    function filterOutReservedFunctions(reserved, options) {
      var object = {};
      for (var i in options) {
        var isReserved = !(reserved.indexOf(i) === -1);
        var isFunction = typeof options[i] === "function";
        if (!(isReserved && isFunction)) {
          object[i] = options[i];
        }
      }
      return object;
    }
    function requestToJSON() {
      var self2 = this;
      return {
        uri: self2.uri,
        method: self2.method,
        headers: self2.headers
      };
    }
    function responseToJSON() {
      var self2 = this;
      return {
        statusCode: self2.statusCode,
        body: self2.body,
        headers: self2.headers,
        request: requestToJSON.call(self2.request)
      };
    }
    function Request(options) {
      var self2 = this;
      if (options.har) {
        self2._har = new Har(self2);
        options = self2._har.options(options);
      }
      stream.Stream.call(self2);
      var reserved = Object.keys(Request.prototype);
      var nonReserved = filterForNonReserved(reserved, options);
      extend(self2, nonReserved);
      options = filterOutReservedFunctions(reserved, options);
      self2.readable = true;
      self2.writable = true;
      if (options.method) {
        self2.explicitMethod = true;
      }
      self2._qs = new Querystring(self2);
      self2._auth = new Auth(self2);
      self2._oauth = new OAuth(self2);
      self2._multipart = new Multipart(self2);
      self2._redirect = new Redirect(self2);
      self2._tunnel = new Tunnel(self2);
      self2.init(options);
    }
    util.inherits(Request, stream.Stream);
    Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
    function debug() {
      if (Request.debug) {
        console.error("REQUEST %s", util.format.apply(util, arguments));
      }
    }
    Request.prototype.debug = debug;
    Request.prototype.init = function(options) {
      var self2 = this;
      if (!options) {
        options = {};
      }
      self2.headers = self2.headers ? copy(self2.headers) : {};
      for (var headerName in self2.headers) {
        if (typeof self2.headers[headerName] === "undefined") {
          delete self2.headers[headerName];
        }
      }
      caseless.httpify(self2, self2.headers);
      if (!self2.method) {
        self2.method = options.method || "GET";
      }
      if (!self2.localAddress) {
        self2.localAddress = options.localAddress;
      }
      self2._qs.init(options);
      debug(options);
      if (!self2.pool && self2.pool !== false) {
        self2.pool = globalPool;
      }
      self2.dests = self2.dests || [];
      self2.__isRequestRequest = true;
      if (!self2._callback && self2.callback) {
        self2._callback = self2.callback;
        self2.callback = function() {
          if (self2._callbackCalled) {
            return;
          }
          self2._callbackCalled = true;
          self2._callback.apply(self2, arguments);
        };
        self2.on("error", self2.callback.bind());
        self2.on("complete", self2.callback.bind(self2, null));
      }
      if (!self2.uri && self2.url) {
        self2.uri = self2.url;
        delete self2.url;
      }
      if (self2.baseUrl) {
        if (typeof self2.baseUrl !== "string") {
          return self2.emit("error", new Error("options.baseUrl must be a string"));
        }
        if (typeof self2.uri !== "string") {
          return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
        }
        if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
          return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
        }
        var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
        var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
        if (baseUrlEndsWithSlash && uriStartsWithSlash) {
          self2.uri = self2.baseUrl + self2.uri.slice(1);
        } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
          self2.uri = self2.baseUrl + self2.uri;
        } else if (self2.uri === "") {
          self2.uri = self2.baseUrl;
        } else {
          self2.uri = self2.baseUrl + "/" + self2.uri;
        }
        delete self2.baseUrl;
      }
      if (!self2.uri) {
        return self2.emit("error", new Error("options.uri is a required argument"));
      }
      if (typeof self2.uri === "string") {
        self2.uri = url.parse(self2.uri);
      }
      if (!self2.uri.href) {
        self2.uri.href = url.format(self2.uri);
      }
      if (self2.uri.protocol === "unix:") {
        return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
      }
      if (self2.uri.host === "unix") {
        self2.enableUnixSocket();
      }
      if (self2.strictSSL === false) {
        self2.rejectUnauthorized = false;
      }
      if (!self2.uri.pathname) {
        self2.uri.pathname = "/";
      }
      if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
        var faultyUri = url.format(self2.uri);
        var message = 'Invalid URI "' + faultyUri + '"';
        if (Object.keys(options).length === 0) {
          message += ". This can be caused by a crappy redirection.";
        }
        self2.abort();
        return self2.emit("error", new Error(message));
      }
      if (!self2.hasOwnProperty("proxy")) {
        self2.proxy = getProxyFromURI(self2.uri);
      }
      self2.tunnel = self2._tunnel.isEnabled();
      if (self2.proxy) {
        self2._tunnel.setup(options);
      }
      self2._redirect.onRequest(options);
      self2.setHost = false;
      if (!self2.hasHeader("host")) {
        var hostHeaderName = self2.originalHostHeaderName || "host";
        self2.setHeader(hostHeaderName, self2.uri.host);
        self2.setHost = true;
      }
      self2.jar(self2._jar || options.jar);
      if (!self2.uri.port) {
        if (self2.uri.protocol === "http:") {
          self2.uri.port = 80;
        } else if (self2.uri.protocol === "https:") {
          self2.uri.port = 443;
        }
      }
      if (self2.proxy && !self2.tunnel) {
        self2.port = self2.proxy.port;
        self2.host = self2.proxy.hostname;
      } else {
        self2.port = self2.uri.port;
        self2.host = self2.uri.hostname;
      }
      if (options.form) {
        self2.form(options.form);
      }
      if (options.formData) {
        var formData = options.formData;
        var requestForm = self2.form();
        var appendFormValue = function(key, value) {
          if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) {
            requestForm.append(key, value.value, value.options);
          } else {
            requestForm.append(key, value);
          }
        };
        for (var formKey in formData) {
          if (formData.hasOwnProperty(formKey)) {
            var formValue = formData[formKey];
            if (formValue instanceof Array) {
              for (var j = 0; j < formValue.length; j++) {
                appendFormValue(formKey, formValue[j]);
              }
            } else {
              appendFormValue(formKey, formValue);
            }
          }
        }
      }
      if (options.qs) {
        self2.qs(options.qs);
      }
      if (self2.uri.path) {
        self2.path = self2.uri.path;
      } else {
        self2.path = self2.uri.pathname + (self2.uri.search || "");
      }
      if (self2.path.length === 0) {
        self2.path = "/";
      }
      if (options.aws) {
        self2.aws(options.aws);
      }
      if (options.hawk) {
        self2.hawk(options.hawk);
      }
      if (options.httpSignature) {
        self2.httpSignature(options.httpSignature);
      }
      if (options.auth) {
        if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
          options.auth.user = options.auth.username;
        }
        if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
          options.auth.pass = options.auth.password;
        }
        self2.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer);
      }
      if (self2.gzip && !self2.hasHeader("accept-encoding")) {
        self2.setHeader("accept-encoding", "gzip, deflate");
      }
      if (self2.uri.auth && !self2.hasHeader("authorization")) {
        var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
          return self2._qs.unescape(item);
        });
        self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
      }
      if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
        var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
          return self2._qs.unescape(item);
        });
        var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
        self2.setHeader("proxy-authorization", authHeader);
      }
      if (self2.proxy && !self2.tunnel) {
        self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
      }
      if (options.json) {
        self2.json(options.json);
      }
      if (options.multipart) {
        self2.multipart(options.multipart);
      }
      if (options.time) {
        self2.timing = true;
        self2.elapsedTime = self2.elapsedTime || 0;
      }
      function setContentLength() {
        if (isTypedArray(self2.body)) {
          self2.body = Buffer2.from(self2.body);
        }
        if (!self2.hasHeader("content-length")) {
          var length;
          if (typeof self2.body === "string") {
            length = Buffer2.byteLength(self2.body);
          } else if (Array.isArray(self2.body)) {
            length = self2.body.reduce(function(a, b) {
              return a + b.length;
            }, 0);
          } else {
            length = self2.body.length;
          }
          if (length) {
            self2.setHeader("content-length", length);
          } else {
            self2.emit("error", new Error("Argument error, options.body."));
          }
        }
      }
      if (self2.body && !isstream(self2.body)) {
        setContentLength();
      }
      if (options.oauth) {
        self2.oauth(options.oauth);
      } else if (self2._oauth.params && self2.hasHeader("authorization")) {
        self2.oauth(self2._oauth.params);
      }
      var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
      var defaultModules = { "http:": http, "https:": https };
      var httpModules = self2.httpModules || {};
      self2.httpModule = httpModules[protocol] || defaultModules[protocol];
      if (!self2.httpModule) {
        return self2.emit("error", new Error("Invalid protocol: " + protocol));
      }
      if (options.ca) {
        self2.ca = options.ca;
      }
      if (!self2.agent) {
        if (options.agentOptions) {
          self2.agentOptions = options.agentOptions;
        }
        if (options.agentClass) {
          self2.agentClass = options.agentClass;
        } else if (options.forever) {
          var v = version();
          if (v.major === 0 && v.minor <= 10) {
            self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
          } else {
            self2.agentClass = self2.httpModule.Agent;
            self2.agentOptions = self2.agentOptions || {};
            self2.agentOptions.keepAlive = true;
          }
        } else {
          self2.agentClass = self2.httpModule.Agent;
        }
      }
      if (self2.pool === false) {
        self2.agent = false;
      } else {
        self2.agent = self2.agent || self2.getNewAgent();
      }
      self2.on("pipe", function(src) {
        if (self2.ntick && self2._started) {
          self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
        }
        self2.src = src;
        if (isReadStream(src)) {
          if (!self2.hasHeader("content-type")) {
            self2.setHeader("content-type", mime.lookup(src.path));
          }
        } else {
          if (src.headers) {
            for (var i in src.headers) {
              if (!self2.hasHeader(i)) {
                self2.setHeader(i, src.headers[i]);
              }
            }
          }
          if (self2._json && !self2.hasHeader("content-type")) {
            self2.setHeader("content-type", "application/json");
          }
          if (src.method && !self2.explicitMethod) {
            self2.method = src.method;
          }
        }
      });
      defer(function() {
        if (self2._aborted) {
          return;
        }
        var end = function() {
          if (self2._form) {
            if (!self2._auth.hasAuth) {
              self2._form.pipe(self2);
            } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
              self2._form.pipe(self2);
            }
          }
          if (self2._multipart && self2._multipart.chunked) {
            self2._multipart.body.pipe(self2);
          }
          if (self2.body) {
            if (isstream(self2.body)) {
              self2.body.pipe(self2);
            } else {
              setContentLength();
              if (Array.isArray(self2.body)) {
                self2.body.forEach(function(part) {
                  self2.write(part);
                });
              } else {
                self2.write(self2.body);
              }
              self2.end();
            }
          } else if (self2.requestBodyStream) {
            console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
            self2.requestBodyStream.pipe(self2);
          } else if (!self2.src) {
            if (self2._auth.hasAuth && !self2._auth.sentAuth) {
              self2.end();
              return;
            }
            if (self2.method !== "GET" && typeof self2.method !== "undefined") {
              self2.setHeader("content-length", 0);
            }
            self2.end();
          }
        };
        if (self2._form && !self2.hasHeader("content-length")) {
          self2.setHeader(self2._form.getHeaders(), true);
          self2._form.getLength(function(err, length) {
            if (!err && !isNaN(length)) {
              self2.setHeader("content-length", length);
            }
            end();
          });
        } else {
          end();
        }
        self2.ntick = true;
      });
    };
    Request.prototype.getNewAgent = function() {
      var self2 = this;
      var Agent = self2.agentClass;
      var options = {};
      if (self2.agentOptions) {
        for (var i in self2.agentOptions) {
          options[i] = self2.agentOptions[i];
        }
      }
      if (self2.ca) {
        options.ca = self2.ca;
      }
      if (self2.ciphers) {
        options.ciphers = self2.ciphers;
      }
      if (self2.secureProtocol) {
        options.secureProtocol = self2.secureProtocol;
      }
      if (self2.secureOptions) {
        options.secureOptions = self2.secureOptions;
      }
      if (typeof self2.rejectUnauthorized !== "undefined") {
        options.rejectUnauthorized = self2.rejectUnauthorized;
      }
      if (self2.cert && self2.key) {
        options.key = self2.key;
        options.cert = self2.cert;
      }
      if (self2.pfx) {
        options.pfx = self2.pfx;
      }
      if (self2.passphrase) {
        options.passphrase = self2.passphrase;
      }
      var poolKey = "";
      if (Agent !== self2.httpModule.Agent) {
        poolKey += Agent.name;
      }
      var proxy = self2.proxy;
      if (typeof proxy === "string") {
        proxy = url.parse(proxy);
      }
      var isHttps = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
      if (isHttps) {
        if (options.ca) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.ca;
        }
        if (typeof options.rejectUnauthorized !== "undefined") {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.rejectUnauthorized;
        }
        if (options.cert) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
        }
        if (options.pfx) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.pfx.toString("ascii");
        }
        if (options.ciphers) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.ciphers;
        }
        if (options.secureProtocol) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.secureProtocol;
        }
        if (options.secureOptions) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.secureOptions;
        }
      }
      if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
        return self2.httpModule.globalAgent;
      }
      poolKey = self2.uri.protocol + poolKey;
      if (!self2.pool[poolKey]) {
        self2.pool[poolKey] = new Agent(options);
        if (self2.pool.maxSockets) {
          self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
        }
      }
      return self2.pool[poolKey];
    };
    Request.prototype.start = function() {
      var self2 = this;
      if (self2.timing) {
        var startTime = new Date().getTime();
        var startTimeNow = now();
      }
      if (self2._aborted) {
        return;
      }
      self2._started = true;
      self2.method = self2.method || "GET";
      self2.href = self2.uri.href;
      if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
        self2.setHeader("content-length", self2.src.stat.size);
      }
      if (self2._aws) {
        self2.aws(self2._aws, true);
      }
      var reqOptions = copy(self2);
      delete reqOptions.auth;
      debug("make request", self2.uri.href);
      delete reqOptions.timeout;
      try {
        self2.req = self2.httpModule.request(reqOptions);
      } catch (err) {
        self2.emit("error", err);
        return;
      }
      if (self2.timing) {
        self2.startTime = startTime;
        self2.startTimeNow = startTimeNow;
        self2.timings = {};
      }
      var timeout;
      if (self2.timeout && !self2.timeoutTimer) {
        if (self2.timeout < 0) {
          timeout = 0;
        } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
          timeout = self2.timeout;
        }
      }
      self2.req.on("response", self2.onRequestResponse.bind(self2));
      self2.req.on("error", self2.onRequestError.bind(self2));
      self2.req.on("drain", function() {
        self2.emit("drain");
      });
      self2.req.on("socket", function(socket) {
        var isConnecting = socket._connecting || socket.connecting;
        if (self2.timing) {
          self2.timings.socket = now() - self2.startTimeNow;
          if (isConnecting) {
            var onLookupTiming = function() {
              self2.timings.lookup = now() - self2.startTimeNow;
            };
            var onConnectTiming = function() {
              self2.timings.connect = now() - self2.startTimeNow;
            };
            socket.once("lookup", onLookupTiming);
            socket.once("connect", onConnectTiming);
            self2.req.once("error", function() {
              socket.removeListener("lookup", onLookupTiming);
              socket.removeListener("connect", onConnectTiming);
            });
          }
        }
        var setReqTimeout = function() {
          self2.req.setTimeout(timeout, function() {
            if (self2.req) {
              self2.abort();
              var e = new Error("ESOCKETTIMEDOUT");
              e.code = "ESOCKETTIMEDOUT";
              e.connect = false;
              self2.emit("error", e);
            }
          });
        };
        if (timeout !== void 0) {
          if (isConnecting) {
            var onReqSockConnect = function() {
              socket.removeListener("connect", onReqSockConnect);
              clearTimeout(self2.timeoutTimer);
              self2.timeoutTimer = null;
              setReqTimeout();
            };
            socket.on("connect", onReqSockConnect);
            self2.req.on("error", function(err) {
              socket.removeListener("connect", onReqSockConnect);
            });
            self2.timeoutTimer = setTimeout(function() {
              socket.removeListener("connect", onReqSockConnect);
              self2.abort();
              var e = new Error("ETIMEDOUT");
              e.code = "ETIMEDOUT";
              e.connect = true;
              self2.emit("error", e);
            }, timeout);
          } else {
            setReqTimeout();
          }
        }
        self2.emit("socket", socket);
      });
      self2.emit("request", self2.req);
    };
    Request.prototype.onRequestError = function(error) {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (self2.req && self2.req._reusedSocket && error.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
        self2.agent = { addRequest: self2.agent.addRequestNoreuse.bind(self2.agent) };
        self2.start();
        self2.req.end();
        return;
      }
      if (self2.timeout && self2.timeoutTimer) {
        clearTimeout(self2.timeoutTimer);
        self2.timeoutTimer = null;
      }
      self2.emit("error", error);
    };
    Request.prototype.onRequestResponse = function(response) {
      var self2 = this;
      if (self2.timing) {
        self2.timings.response = now() - self2.startTimeNow;
      }
      debug("onRequestResponse", self2.uri.href, response.statusCode, response.headers);
      response.on("end", function() {
        if (self2.timing) {
          self2.timings.end = now() - self2.startTimeNow;
          response.timingStart = self2.startTime;
          if (!self2.timings.socket) {
            self2.timings.socket = 0;
          }
          if (!self2.timings.lookup) {
            self2.timings.lookup = self2.timings.socket;
          }
          if (!self2.timings.connect) {
            self2.timings.connect = self2.timings.lookup;
          }
          if (!self2.timings.response) {
            self2.timings.response = self2.timings.connect;
          }
          debug("elapsed time", self2.timings.end);
          self2.elapsedTime += Math.round(self2.timings.end);
          response.elapsedTime = self2.elapsedTime;
          response.timings = self2.timings;
          response.timingPhases = {
            wait: self2.timings.socket,
            dns: self2.timings.lookup - self2.timings.socket,
            tcp: self2.timings.connect - self2.timings.lookup,
            firstByte: self2.timings.response - self2.timings.connect,
            download: self2.timings.end - self2.timings.response,
            total: self2.timings.end
          };
        }
        debug("response end", self2.uri.href, response.statusCode, response.headers);
      });
      if (self2._aborted) {
        debug("aborted", self2.uri.href);
        response.resume();
        return;
      }
      self2.response = response;
      response.request = self2;
      response.toJSON = responseToJSON;
      if (self2.httpModule === https && self2.strictSSL && (!response.hasOwnProperty("socket") || !response.socket.authorized)) {
        debug("strict ssl error", self2.uri.href);
        var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self2.uri.href + " does not support SSL";
        self2.emit("error", new Error("SSL Error: " + sslErr));
        return;
      }
      self2.originalHost = self2.getHeader("host");
      if (!self2.originalHostHeaderName) {
        self2.originalHostHeaderName = self2.hasHeader("host");
      }
      if (self2.setHost) {
        self2.removeHeader("host");
      }
      if (self2.timeout && self2.timeoutTimer) {
        clearTimeout(self2.timeoutTimer);
        self2.timeoutTimer = null;
      }
      var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
      var addCookie = function(cookie) {
        try {
          targetCookieJar.setCookie(cookie, self2.uri.href, { ignoreError: true });
        } catch (e) {
          self2.emit("error", e);
        }
      };
      response.caseless = caseless(response.headers);
      if (response.caseless.has("set-cookie") && !self2._disableCookies) {
        var headerName = response.caseless.has("set-cookie");
        if (Array.isArray(response.headers[headerName])) {
          response.headers[headerName].forEach(addCookie);
        } else {
          addCookie(response.headers[headerName]);
        }
      }
      if (self2._redirect.onResponse(response)) {
        return;
      } else {
        response.on("close", function() {
          if (!self2._ended) {
            self2.response.emit("end");
          }
        });
        response.once("end", function() {
          self2._ended = true;
        });
        var noBody = function(code) {
          return self2.method === "HEAD" || code >= 100 && code < 200 || code === 204 || code === 304;
        };
        var responseContent;
        if (self2.gzip && !noBody(response.statusCode)) {
          var contentEncoding = response.headers["content-encoding"] || "identity";
          contentEncoding = contentEncoding.trim().toLowerCase();
          var zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (contentEncoding === "gzip") {
            responseContent = zlib.createGunzip(zlibOptions);
            response.pipe(responseContent);
          } else if (contentEncoding === "deflate") {
            responseContent = zlib.createInflate(zlibOptions);
            response.pipe(responseContent);
          } else {
            if (contentEncoding !== "identity") {
              debug("ignoring unrecognized Content-Encoding " + contentEncoding);
            }
            responseContent = response;
          }
        } else {
          responseContent = response;
        }
        if (self2.encoding) {
          if (self2.dests.length !== 0) {
            console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
          } else {
            responseContent.setEncoding(self2.encoding);
          }
        }
        if (self2._paused) {
          responseContent.pause();
        }
        self2.responseContent = responseContent;
        self2.emit("response", response);
        self2.dests.forEach(function(dest) {
          self2.pipeDest(dest);
        });
        responseContent.on("data", function(chunk) {
          if (self2.timing && !self2.responseStarted) {
            self2.responseStartTime = new Date().getTime();
            response.responseStartTime = self2.responseStartTime;
          }
          self2._destdata = true;
          self2.emit("data", chunk);
        });
        responseContent.once("end", function(chunk) {
          self2.emit("end", chunk);
        });
        responseContent.on("error", function(error) {
          self2.emit("error", error);
        });
        responseContent.on("close", function() {
          self2.emit("close");
        });
        if (self2.callback) {
          self2.readResponseBody(response);
        } else {
          self2.on("end", function() {
            if (self2._aborted) {
              debug("aborted", self2.uri.href);
              return;
            }
            self2.emit("complete", response);
          });
        }
      }
      debug("finish init function", self2.uri.href);
    };
    Request.prototype.readResponseBody = function(response) {
      var self2 = this;
      debug("reading response's body");
      var buffers = [];
      var bufferLength = 0;
      var strings = [];
      self2.on("data", function(chunk) {
        if (!Buffer2.isBuffer(chunk)) {
          strings.push(chunk);
        } else if (chunk.length) {
          bufferLength += chunk.length;
          buffers.push(chunk);
        }
      });
      self2.on("end", function() {
        debug("end event", self2.uri.href);
        if (self2._aborted) {
          debug("aborted", self2.uri.href);
          buffers = [];
          bufferLength = 0;
          return;
        }
        if (bufferLength) {
          debug("has body", self2.uri.href, bufferLength);
          response.body = Buffer2.concat(buffers, bufferLength);
          if (self2.encoding !== null) {
            response.body = response.body.toString(self2.encoding);
          }
          buffers = [];
          bufferLength = 0;
        } else if (strings.length) {
          if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
            strings[0] = strings[0].substring(1);
          }
          response.body = strings.join("");
        }
        if (self2._json) {
          try {
            response.body = JSON.parse(response.body, self2._jsonReviver);
          } catch (e) {
            debug("invalid JSON received", self2.uri.href);
          }
        }
        debug("emitting complete", self2.uri.href);
        if (typeof response.body === "undefined" && !self2._json) {
          response.body = self2.encoding === null ? Buffer2.alloc(0) : "";
        }
        self2.emit("complete", response, response.body);
      });
    };
    Request.prototype.abort = function() {
      var self2 = this;
      self2._aborted = true;
      if (self2.req) {
        self2.req.abort();
      } else if (self2.response) {
        self2.response.destroy();
      }
      self2.emit("abort");
    };
    Request.prototype.pipeDest = function(dest) {
      var self2 = this;
      var response = self2.response;
      if (dest.headers && !dest.headersSent) {
        if (response.caseless.has("content-type")) {
          var ctname = response.caseless.has("content-type");
          if (dest.setHeader) {
            dest.setHeader(ctname, response.headers[ctname]);
          } else {
            dest.headers[ctname] = response.headers[ctname];
          }
        }
        if (response.caseless.has("content-length")) {
          var clname = response.caseless.has("content-length");
          if (dest.setHeader) {
            dest.setHeader(clname, response.headers[clname]);
          } else {
            dest.headers[clname] = response.headers[clname];
          }
        }
      }
      if (dest.setHeader && !dest.headersSent) {
        for (var i in response.headers) {
          if (!self2.gzip || i !== "content-encoding") {
            dest.setHeader(i, response.headers[i]);
          }
        }
        dest.statusCode = response.statusCode;
      }
      if (self2.pipefilter) {
        self2.pipefilter(response, dest);
      }
    };
    Request.prototype.qs = function(q2, clobber) {
      var self2 = this;
      var base;
      if (!clobber && self2.uri.query) {
        base = self2._qs.parse(self2.uri.query);
      } else {
        base = {};
      }
      for (var i in q2) {
        base[i] = q2[i];
      }
      var qs = self2._qs.stringify(base);
      if (qs === "") {
        return self2;
      }
      self2.uri = url.parse(self2.uri.href.split("?")[0] + "?" + qs);
      self2.url = self2.uri;
      self2.path = self2.uri.path;
      if (self2.uri.host === "unix") {
        self2.enableUnixSocket();
      }
      return self2;
    };
    Request.prototype.form = function(form) {
      var self2 = this;
      if (form) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.setHeader("content-type", "application/x-www-form-urlencoded");
        }
        self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
        return self2;
      }
      self2._form = new FormData();
      self2._form.on("error", function(err) {
        err.message = "form-data: " + err.message;
        self2.emit("error", err);
        self2.abort();
      });
      return self2._form;
    };
    Request.prototype.multipart = function(multipart) {
      var self2 = this;
      self2._multipart.onRequest(multipart);
      if (!self2._multipart.chunked) {
        self2.body = self2._multipart.body;
      }
      return self2;
    };
    Request.prototype.json = function(val) {
      var self2 = this;
      if (!self2.hasHeader("accept")) {
        self2.setHeader("accept", "application/json");
      }
      if (typeof self2.jsonReplacer === "function") {
        self2._jsonReplacer = self2.jsonReplacer;
      }
      self2._json = true;
      if (typeof val === "boolean") {
        if (self2.body !== void 0) {
          if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
            self2.body = safeStringify(self2.body, self2._jsonReplacer);
          } else {
            self2.body = self2._qs.rfc3986(self2.body);
          }
          if (!self2.hasHeader("content-type")) {
            self2.setHeader("content-type", "application/json");
          }
        }
      } else {
        self2.body = safeStringify(val, self2._jsonReplacer);
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
      if (typeof self2.jsonReviver === "function") {
        self2._jsonReviver = self2.jsonReviver;
      }
      return self2;
    };
    Request.prototype.getHeader = function(name, headers) {
      var self2 = this;
      var result, re, match;
      if (!headers) {
        headers = self2.headers;
      }
      Object.keys(headers).forEach(function(key) {
        if (key.length !== name.length) {
          return;
        }
        re = new RegExp(name, "i");
        match = key.match(re);
        if (match) {
          result = headers[key];
        }
      });
      return result;
    };
    Request.prototype.enableUnixSocket = function() {
      var unixParts = this.uri.path.split(":");
      var host = unixParts[0];
      var path = unixParts[1];
      this.socketPath = host;
      this.uri.pathname = path;
      this.uri.path = path;
      this.uri.host = host;
      this.uri.hostname = host;
      this.uri.isUnix = true;
    };
    Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
      var self2 = this;
      self2._auth.onRequest(user, pass, sendImmediately, bearer);
      return self2;
    };
    Request.prototype.aws = function(opts, now2) {
      var self2 = this;
      if (!now2) {
        self2._aws = opts;
        return self2;
      }
      if (opts.sign_version === 4 || opts.sign_version === "4") {
        var options = {
          host: self2.uri.host,
          path: self2.uri.path,
          method: self2.method,
          headers: {
            "content-type": self2.getHeader("content-type") || ""
          },
          body: self2.body
        };
        var signRes = aws4.sign(options, {
          accessKeyId: opts.key,
          secretAccessKey: opts.secret,
          sessionToken: opts.session
        });
        self2.setHeader("authorization", signRes.headers.Authorization);
        self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
        if (signRes.headers["X-Amz-Security-Token"]) {
          self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
        }
      } else {
        var date = new Date();
        self2.setHeader("date", date.toUTCString());
        var auth = {
          key: opts.key,
          secret: opts.secret,
          verb: self2.method.toUpperCase(),
          date,
          contentType: self2.getHeader("content-type") || "",
          md5: self2.getHeader("content-md5") || "",
          amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
        };
        var path = self2.uri.path;
        if (opts.bucket && path) {
          auth.resource = "/" + opts.bucket + path;
        } else if (opts.bucket && !path) {
          auth.resource = "/" + opts.bucket;
        } else if (!opts.bucket && path) {
          auth.resource = path;
        } else if (!opts.bucket && !path) {
          auth.resource = "/";
        }
        auth.resource = aws2.canonicalizeResource(auth.resource);
        self2.setHeader("authorization", aws2.authorization(auth));
      }
      return self2;
    };
    Request.prototype.httpSignature = function(opts) {
      var self2 = this;
      httpSignature.signRequest({
        getHeader: function(header) {
          return self2.getHeader(header, self2.headers);
        },
        setHeader: function(header, value) {
          self2.setHeader(header, value);
        },
        method: self2.method,
        path: self2.path
      }, opts);
      debug("httpSignature authorization", self2.getHeader("authorization"));
      return self2;
    };
    Request.prototype.hawk = function(opts) {
      var self2 = this;
      self2.setHeader("Authorization", hawk.header(self2.uri, self2.method, opts));
    };
    Request.prototype.oauth = function(_oauth) {
      var self2 = this;
      self2._oauth.onRequest(_oauth);
      return self2;
    };
    Request.prototype.jar = function(jar) {
      var self2 = this;
      var cookies2;
      if (self2._redirect.redirectsFollowed === 0) {
        self2.originalCookieHeader = self2.getHeader("cookie");
      }
      if (!jar) {
        cookies2 = false;
        self2._disableCookies = true;
      } else {
        var targetCookieJar = jar && jar.getCookieString ? jar : globalCookieJar;
        var urihref = self2.uri.href;
        if (targetCookieJar) {
          cookies2 = targetCookieJar.getCookieString(urihref);
        }
      }
      if (cookies2 && cookies2.length) {
        if (self2.originalCookieHeader) {
          self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies2);
        } else {
          self2.setHeader("cookie", cookies2);
        }
      }
      self2._jar = jar;
      return self2;
    };
    Request.prototype.pipe = function(dest, opts) {
      var self2 = this;
      if (self2.response) {
        if (self2._destdata) {
          self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
        } else if (self2._ended) {
          self2.emit("error", new Error("You cannot pipe after the response has been ended."));
        } else {
          stream.Stream.prototype.pipe.call(self2, dest, opts);
          self2.pipeDest(dest);
          return dest;
        }
      } else {
        self2.dests.push(dest);
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        return dest;
      }
    };
    Request.prototype.write = function() {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (!self2._started) {
        self2.start();
      }
      if (self2.req) {
        return self2.req.write.apply(self2.req, arguments);
      }
    };
    Request.prototype.end = function(chunk) {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (chunk) {
        self2.write(chunk);
      }
      if (!self2._started) {
        self2.start();
      }
      if (self2.req) {
        self2.req.end();
      }
    };
    Request.prototype.pause = function() {
      var self2 = this;
      if (!self2.responseContent) {
        self2._paused = true;
      } else {
        self2.responseContent.pause.apply(self2.responseContent, arguments);
      }
    };
    Request.prototype.resume = function() {
      var self2 = this;
      if (!self2.responseContent) {
        self2._paused = false;
      } else {
        self2.responseContent.resume.apply(self2.responseContent, arguments);
      }
    };
    Request.prototype.destroy = function() {
      var self2 = this;
      if (!self2._ended) {
        self2.end();
      } else if (self2.response) {
        self2.response.destroy();
      }
    };
    Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
    Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
    Request.prototype.toJSON = requestToJSON;
    module.exports = Request;
  }
});

// node_modules/request/index.js
var require_request3 = __commonJS({
  "node_modules/request/index.js"(exports, module) {
    "use strict";
    var extend = require_extend();
    var cookies = require_cookies();
    var helpers = require_helpers();
    var paramsHaveRequestBody = helpers.paramsHaveRequestBody;
    function initParams(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      var params = {};
      if (typeof options === "object") {
        extend(params, options, { uri });
      } else if (typeof uri === "string") {
        extend(params, { uri });
      } else {
        extend(params, uri);
      }
      params.callback = callback || params.callback;
      return params;
    }
    function request(uri, options, callback) {
      if (typeof uri === "undefined") {
        throw new Error("undefined is not a valid uri or options object.");
      }
      var params = initParams(uri, options, callback);
      if (params.method === "HEAD" && paramsHaveRequestBody(params)) {
        throw new Error("HTTP HEAD requests MUST NOT include a request body.");
      }
      return new request.Request(params);
    }
    function verbFunc(verb) {
      var method = verb.toUpperCase();
      return function(uri, options, callback) {
        var params = initParams(uri, options, callback);
        params.method = method;
        return request(params, params.callback);
      };
    }
    request.get = verbFunc("get");
    request.head = verbFunc("head");
    request.options = verbFunc("options");
    request.post = verbFunc("post");
    request.put = verbFunc("put");
    request.patch = verbFunc("patch");
    request.del = verbFunc("delete");
    request["delete"] = verbFunc("delete");
    request.jar = function(store) {
      return cookies.jar(store);
    };
    request.cookie = function(str) {
      return cookies.parse(str);
    };
    function wrapRequestMethod(method, options, requester, verb) {
      return function(uri, opts, callback) {
        var params = initParams(uri, opts, callback);
        var target = {};
        extend(true, target, options, params);
        target.pool = params.pool || options.pool;
        if (verb) {
          target.method = verb.toUpperCase();
        }
        if (typeof requester === "function") {
          method = requester;
        }
        return method(target, target.callback);
      };
    }
    request.defaults = function(options, requester) {
      var self2 = this;
      options = options || {};
      if (typeof options === "function") {
        requester = options;
        options = {};
      }
      var defaults = wrapRequestMethod(self2, options, requester);
      var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
      verbs.forEach(function(verb) {
        defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
      });
      defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
      defaults.jar = self2.jar;
      defaults.defaults = self2.defaults;
      return defaults;
    };
    request.forever = function(agentOptions, optionsArg) {
      var options = {};
      if (optionsArg) {
        extend(options, optionsArg);
      }
      if (agentOptions) {
        options.agentOptions = agentOptions;
      }
      options.forever = true;
      return request.defaults(options);
    };
    module.exports = request;
    request.Request = require_request2();
    request.initParams = initParams;
    Object.defineProperty(request, "debug", {
      enumerable: true,
      get: function() {
        return request.Request.debug;
      },
      set: function(debug) {
        request.Request.debug = debug;
      }
    });
  }
});

// node_modules/html2canvas-proxy/server.js
var require_server = __commonJS({
  "node_modules/html2canvas-proxy/server.js"(exports, module) {
    var express = require_express();
    var url = (init_url(), __toCommonJS(url_exports));
    var cors = require_lib();
    var request = require_request3();
    function validUrl(req, res, next) {
      if (!req.query.url) {
        next(new Error("No url specified"));
      } else if (typeof req.query.url !== "string" || url.parse(req.query.url).host === null) {
        next(new Error(`Invalid url specified: ${req.query.url}`));
      } else {
        next();
      }
    }
    module.exports = () => {
      const app = express.Router();
      app.get("/", cors(), validUrl, (req, res, next) => {
        switch (req.query.responseType) {
          case "blob":
            req.pipe(request(req.query.url).on("error", next)).pipe(res);
            break;
          case "text":
          default:
            request({ url: req.query.url, encoding: "binary" }, (error, response, body) => {
              if (error) {
                return next(error);
              }
              res.send(`data:${response.headers["content-type"]};base64,${Buffer.from(body, "binary").toString("base64")}`);
            });
        }
      });
      return app;
    };
  }
});

// dep:html2canvas-proxy
var html2canvas_proxy_default = require_server();
export {
  html2canvas_proxy_default as default
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 *  Copyright 2010 LearnBoost <dev@learnboost.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
//# sourceMappingURL=html2canvas-proxy.js.map
