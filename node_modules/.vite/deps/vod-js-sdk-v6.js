import {
  __commonJS
} from "./chunk-QOVRSCHT.js";

// node_modules/js-sha1/src/sha1.js
var require_sha1 = __commonJS({
  "node_modules/js-sha1/src/sha1.js"(exports, module) {
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_SHA1_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Sha1(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method2 = createOutputMethod("hex");
        if (NODE_JS) {
          method2 = nodeWrap(method2);
        }
        method2.create = function() {
          return new Sha1();
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type);
        }
        return method2;
      };
      var nodeWrap = function(method) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash("sha1").update(message, "utf8").digest("hex");
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto.createHash("sha1").update(new Buffer(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Sha1(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.h0 = 1732584193;
        this.h1 = 4023233417;
        this.h2 = 2562383102;
        this.h3 = 271733878;
        this.h4 = 3285377520;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Sha1.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && message.constructor === root.ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha1.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha1.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
        var f, j, t, blocks2 = this.blocks;
        for (j = 16; j < 80; ++j) {
          t = blocks2[j - 3] ^ blocks2[j - 8] ^ blocks2[j - 14] ^ blocks2[j - 16];
          blocks2[j] = t << 1 | t >>> 31;
        }
        for (j = 0; j < 20; j += 5) {
          f = b & c | ~b & d;
          t = a << 5 | a >>> 27;
          e = t + f + e + 1518500249 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f = a & b | ~a & c;
          t = e << 5 | e >>> 27;
          d = t + f + d + 1518500249 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f = e & a | ~e & b;
          t = d << 5 | d >>> 27;
          c = t + f + c + 1518500249 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f = d & e | ~d & a;
          t = c << 5 | c >>> 27;
          b = t + f + b + 1518500249 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f = c & d | ~c & e;
          t = b << 5 | b >>> 27;
          a = t + f + a + 1518500249 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        for (; j < 40; j += 5) {
          f = b ^ c ^ d;
          t = a << 5 | a >>> 27;
          e = t + f + e + 1859775393 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f = a ^ b ^ c;
          t = e << 5 | e >>> 27;
          d = t + f + d + 1859775393 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f = e ^ a ^ b;
          t = d << 5 | d >>> 27;
          c = t + f + c + 1859775393 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f = d ^ e ^ a;
          t = c << 5 | c >>> 27;
          b = t + f + b + 1859775393 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f = c ^ d ^ e;
          t = b << 5 | b >>> 27;
          a = t + f + a + 1859775393 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        for (; j < 60; j += 5) {
          f = b & c | b & d | c & d;
          t = a << 5 | a >>> 27;
          e = t + f + e - 1894007588 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f = a & b | a & c | b & c;
          t = e << 5 | e >>> 27;
          d = t + f + d - 1894007588 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f = e & a | e & b | a & b;
          t = d << 5 | d >>> 27;
          c = t + f + c - 1894007588 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f = d & e | d & a | e & a;
          t = c << 5 | c >>> 27;
          b = t + f + b - 1894007588 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f = c & d | c & e | d & e;
          t = b << 5 | b >>> 27;
          a = t + f + a - 1894007588 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        for (; j < 80; j += 5) {
          f = b ^ c ^ d;
          t = a << 5 | a >>> 27;
          e = t + f + e - 899497514 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f = a ^ b ^ c;
          t = e << 5 | e >>> 27;
          d = t + f + d - 899497514 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f = e ^ a ^ b;
          t = d << 5 | d >>> 27;
          c = t + f + c - 899497514 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f = d ^ e ^ a;
          t = c << 5 | c >>> 27;
          b = t + f + b - 899497514 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f = c ^ d ^ e;
          t = b << 5 | b >>> 27;
          a = t + f + a - 899497514 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
      };
      Sha1.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
        return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
      };
      Sha1.prototype.toString = Sha1.prototype.hex;
      Sha1.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
        return [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255
        ];
      };
      Sha1.prototype.array = Sha1.prototype.digest;
      Sha1.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(20);
        var dataView = new DataView(buffer2);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        return buffer2;
      };
      var exports = createMethod();
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha1 = exports;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/cos-js-sdk-v5/dist/cos-js-sdk-v5.js
var require_cos_js_sdk_v5 = __commonJS({
  "node_modules/cos-js-sdk-v5/dist/cos-js-sdk-v5.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["COS"] = factory();
      else
        root2["COS"] = factory();
    })(window, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__2(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__2.m = modules;
        __webpack_require__2.c = installedModules;
        __webpack_require__2.d = function(exports2, name, getter) {
          if (!__webpack_require__2.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__2.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__2.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__2(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__2.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__2.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__2.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__2.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__2.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__2.p = "/dist/";
        return __webpack_require__2(__webpack_require__2.s = "./index.js");
      }({
        "./index.js": function(module2, exports2, __webpack_require__2) {
          var COS = __webpack_require__2("./src/cos.js");
          module2.exports = COS;
        },
        "./lib/beacon.min.js": function(module2, exports2, __webpack_require__2) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__2;
          var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
          !function(t, e) {
            (false ? void 0 : _typeof2(exports2)) == "object" && typeof module2 != "undefined" ? module2.exports = e() : true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = e, __WEBPACK_AMD_DEFINE_RESULT__2 = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports2, __webpack_require__2, exports2, module2) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__2 !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__2)) : void 0;
          }(this, function() {
            "use strict";
            var _t = function t(e, n2) {
              return _t = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(t2, e2) {
                t2.__proto__ = e2;
              } || function(t2, e2) {
                for (var n3 in e2) {
                  Object.prototype.hasOwnProperty.call(e2, n3) && (t2[n3] = e2[n3]);
                }
              }, _t(e, n2);
            };
            var _e = function e() {
              return _e = Object.assign || function(t) {
                for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++) {
                  for (var o2 in e2 = arguments[n2]) {
                    Object.prototype.hasOwnProperty.call(e2, o2) && (t[o2] = e2[o2]);
                  }
                }
                return t;
              }, _e.apply(this, arguments);
            };
            function n(t, e, n2, r2) {
              return new (n2 || (n2 = Promise))(function(o2, i2) {
                function s2(t2) {
                  try {
                    u2(r2.next(t2));
                  } catch (t3) {
                    i2(t3);
                  }
                }
                function a2(t2) {
                  try {
                    u2(r2.throw(t2));
                  } catch (t3) {
                    i2(t3);
                  }
                }
                function u2(t2) {
                  var e2;
                  t2.done ? o2(t2.value) : (e2 = t2.value, e2 instanceof n2 ? e2 : new n2(function(t3) {
                    t3(e2);
                  })).then(s2, a2);
                }
                u2((r2 = r2.apply(t, e || [])).next());
              });
            }
            function r(t, e) {
              var n2, r2, o2, i2, s2 = {
                label: 0,
                sent: function sent() {
                  if (1 & o2[0])
                    throw o2[1];
                  return o2[1];
                },
                trys: [],
                ops: []
              };
              return i2 = {
                next: a2(0),
                throw: a2(1),
                return: a2(2)
              }, typeof Symbol == "function" && (i2[Symbol.iterator] = function() {
                return this;
              }), i2;
              function a2(i3) {
                return function(a3) {
                  return function(i4) {
                    if (n2)
                      throw new TypeError("Generator is already executing.");
                    for (; s2; ) {
                      try {
                        if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
                          return o2;
                        switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                          case 0:
                          case 1:
                            o2 = i4;
                            break;
                          case 4:
                            return s2.label++, {
                              value: i4[1],
                              done: false
                            };
                          case 5:
                            s2.label++, r2 = i4[1], i4 = [0];
                            continue;
                          case 7:
                            i4 = s2.ops.pop(), s2.trys.pop();
                            continue;
                          default:
                            if (!(o2 = s2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || i4[0] !== 6 && i4[0] !== 2)) {
                              s2 = 0;
                              continue;
                            }
                            if (i4[0] === 3 && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                              s2.label = i4[1];
                              break;
                            }
                            if (i4[0] === 6 && s2.label < o2[1]) {
                              s2.label = o2[1], o2 = i4;
                              break;
                            }
                            if (o2 && s2.label < o2[2]) {
                              s2.label = o2[2], s2.ops.push(i4);
                              break;
                            }
                            o2[2] && s2.ops.pop(), s2.trys.pop();
                            continue;
                        }
                        i4 = e.call(t, s2);
                      } catch (t2) {
                        i4 = [6, t2], r2 = 0;
                      } finally {
                        n2 = o2 = 0;
                      }
                    }
                    if (5 & i4[0])
                      throw i4[1];
                    return {
                      value: i4[0] ? i4[1] : void 0,
                      done: true
                    };
                  }([i3, a3]);
                };
              }
            }
            var o = "__BEACON_", i = "__BEACON_deviceId", s = "last_report_time", a = "sending_event_ids", u = "beacon_config", c = "beacon_config_request_time", l = function() {
              function t() {
                var t2 = this;
                this.emit = function(e, n2) {
                  if (t2) {
                    var r2, o2 = t2.__EventsList[e];
                    if (o2 == null ? void 0 : o2.length) {
                      o2 = o2.slice();
                      for (var i2 = 0; i2 < o2.length; i2++) {
                        r2 = o2[i2];
                        try {
                          var s2 = r2.callback.apply(t2, [n2]);
                          if (r2.type === 1 && t2.remove(e, r2.callback), s2 === false)
                            break;
                        } catch (t3) {
                          throw t3;
                        }
                      }
                    }
                    return t2;
                  }
                }, this.__EventsList = {};
              }
              return t.prototype.indexOf = function(t2, e) {
                for (var n2 = 0; n2 < t2.length; n2++) {
                  if (t2[n2].callback === e)
                    return n2;
                }
                return -1;
              }, t.prototype.on = function(t2, e, n2) {
                if (n2 === void 0 && (n2 = 0), this) {
                  var r2 = this.__EventsList[t2];
                  if (r2 || (r2 = this.__EventsList[t2] = []), this.indexOf(r2, e) === -1) {
                    var o2 = {
                      name: t2,
                      type: n2 || 0,
                      callback: e
                    };
                    return r2.push(o2), this;
                  }
                  return this;
                }
              }, t.prototype.one = function(t2, e) {
                this.on(t2, e, 1);
              }, t.prototype.remove = function(t2, e) {
                if (this) {
                  var n2 = this.__EventsList[t2];
                  if (!n2)
                    return null;
                  if (!e) {
                    try {
                      delete this.__EventsList[t2];
                    } catch (t3) {
                    }
                    return null;
                  }
                  if (n2.length) {
                    var r2 = this.indexOf(n2, e);
                    n2.splice(r2, 1);
                  }
                  return this;
                }
              }, t;
            }();
            function p(t, e) {
              for (var n2 = {}, r2 = 0, o2 = Object.keys(t); r2 < o2.length; r2++) {
                var i2 = o2[r2], s2 = t[i2];
                if (typeof s2 == "string")
                  n2[h(i2)] = h(s2);
                else {
                  if (e)
                    throw new Error("value mast be string  !!!!");
                  n2[h(String(i2))] = h(String(s2));
                }
              }
              return n2;
            }
            function h(t) {
              if (typeof t != "string")
                return t;
              try {
                return t.replace(new RegExp("\\|", "g"), "%7C").replace(new RegExp("\\&", "g"), "%26").replace(new RegExp("\\=", "g"), "%3D").replace(new RegExp("\\+", "g"), "%2B");
              } catch (t2) {
                return "";
              }
            }
            function f(t) {
              return String(t.A99) + String(t.A100);
            }
            var d = function d2() {
            };
            var v = function() {
              function t(t2) {
                var n2 = this;
                this.lifeCycle = new l(), this.uploadJobQueue = [], this.additionalParams = {}, this.delayTime = 0, this._normalLogPipeline = function(t3) {
                  if (!t3 || !t3.reduce || !t3.length)
                    throw new TypeError("createPipeline \u65B9\u6CD5\u9700\u8981\u4F20\u5165\u81F3\u5C11\u6709\u4E00\u4E2A pipe \u7684\u6570\u7EC4");
                  return t3.length === 1 ? function(e, n3) {
                    t3[0](e, n3 || d);
                  } : t3.reduce(function(t4, e) {
                    return function(n3, r2) {
                      return r2 === void 0 && (r2 = d), t4(n3, function(t5) {
                        return e == null ? void 0 : e(t5, r2);
                      });
                    };
                  });
                }([function(t3) {
                  n2.send({
                    url: n2.strategy.getUploadUrl(),
                    data: t3,
                    method: "post",
                    contentType: "application/json;charset=UTF-8"
                  }, function() {
                    var e = n2.config.onReportSuccess;
                    typeof e == "function" && e(JSON.stringify(t3.events));
                  }, function() {
                    var e = n2.config.onReportFail;
                    typeof e == "function" && e(JSON.stringify(t3.events));
                  });
                }]), function(t3, e) {
                  if (!t3)
                    throw e instanceof Error ? e : new Error(e);
                }(Boolean(t2.appkey), "appkey must be initial"), this.config = _e({}, t2);
              }
              return t.prototype.onUserAction = function(t2, e) {
                this.preReport(t2, e, false);
              }, t.prototype.onDirectUserAction = function(t2, e) {
                this.preReport(t2, e, true);
              }, t.prototype.preReport = function(t2, e, n2) {
                t2 ? this.strategy.isEventUpOnOff() && (this.strategy.isBlackEvent(t2) || this.strategy.isSampleEvent(t2) || this.onReport(t2, e, n2)) : this.errorReport.reportError("602", " no eventCode");
              }, t.prototype.addAdditionalParams = function(t2) {
                for (var e = 0, n2 = Object.keys(t2); e < n2.length; e++) {
                  var r2 = n2[e];
                  this.additionalParams[r2] = t2[r2];
                }
              }, t.prototype.setChannelId = function(t2) {
                this.commonInfo.channelID = String(t2);
              }, t.prototype.setOpenId = function(t2) {
                this.commonInfo.openid = String(t2);
              }, t.prototype.setUnionid = function(t2) {
                this.commonInfo.unid = String(t2);
              }, t.prototype.getDeviceId = function() {
                return this.commonInfo.deviceId;
              }, t.prototype.getCommonInfo = function() {
                return this.commonInfo;
              }, t.prototype.removeSendingId = function(t2) {
                try {
                  var e = JSON.parse(this.storage.getItem(a)), n2 = e.indexOf(t2);
                  n2 != -1 && (e.splice(n2, 1), this.storage.setItem(a, JSON.stringify(e)));
                } catch (t3) {
                }
              }, t;
            }(), g = function() {
              function t(t2, e, n2, r2) {
                this.requestParams = {}, this.network = r2, this.requestParams.attaid = "00400014144", this.requestParams.token = "6478159937", this.requestParams.product_id = t2.appkey, this.requestParams.platform = n2, this.requestParams.uin = e.deviceId, this.requestParams.model = "", this.requestParams.os = n2, this.requestParams.app_version = t2.appVersion, this.requestParams.sdk_version = e.sdkVersion, this.requestParams.error_stack = "", this.uploadUrl = t2.isOversea ? "https://htrace.wetvinfo.com/kv" : "https://h.trace.qq.com/kv";
              }
              return t.prototype.reportError = function(t2, e) {
                this.requestParams._dc = Math.random(), this.requestParams.error_msg = e, this.requestParams.error_code = t2, this.network.get(this.uploadUrl, {
                  params: this.requestParams
                }).catch(function(t3) {
                });
              }, t;
            }(), y = function() {
              function t(t2, e, n2, r2, o2) {
                this.strategy = {
                  isEventUpOnOff: true,
                  httpsUploadUrl: "https://otheve.beacon.qq.com/analytics/v2_upload",
                  requestInterval: 30,
                  blacklist: [],
                  samplelist: []
                }, this.realSample = {}, this.appkey = "", this.needQueryConfig = true, this.appkey = e.appkey, this.storage = r2, this.needQueryConfig = t2;
                try {
                  var i2 = JSON.parse(this.storage.getItem(u));
                  i2 && this.processData(i2);
                } catch (t3) {
                }
                e.isOversea && (this.strategy.httpsUploadUrl = "https://svibeacon.onezapp.com/analytics/v2_upload"), !e.isOversea && this.needRequestConfig() && this.requestConfig(e.appVersion, n2, o2);
              }
              return t.prototype.requestConfig = function(t2, e, n2) {
                var r2 = this;
                this.storage.setItem(c, Date.now().toString()), n2.post("https://oth.str.beacon.qq.com/trpc.beacon.configserver.BeaconConfigService/QueryConfig", {
                  platformId: typeof wx == "undefined" ? "3" : "4",
                  mainAppKey: this.appkey,
                  appVersion: t2,
                  sdkVersion: e.sdkVersion,
                  osVersion: e.userAgent,
                  model: "",
                  packageName: "",
                  params: {
                    A3: e.deviceId
                  }
                }).then(function(t3) {
                  if (t3.data.ret == 0)
                    try {
                      var e2 = JSON.parse(t3.data.beaconConfig);
                      e2 && (r2.processData(e2), r2.storage.setItem(u, t3.data.beaconConfig));
                    } catch (t4) {
                    }
                  else
                    r2.processData(null), r2.storage.setItem(u, "");
                }).catch(function(t3) {
                });
              }, t.prototype.processData = function(t2) {
                var e, n2, r2, o2, i2;
                this.strategy.isEventUpOnOff = (e = t2 == null ? void 0 : t2.isEventUpOnOff) !== null && e !== void 0 ? e : this.strategy.isEventUpOnOff, this.strategy.httpsUploadUrl = (n2 = t2 == null ? void 0 : t2.httpsUploadUrl) !== null && n2 !== void 0 ? n2 : this.strategy.httpsUploadUrl, this.strategy.requestInterval = (r2 = t2 == null ? void 0 : t2.requestInterval) !== null && r2 !== void 0 ? r2 : this.strategy.requestInterval, this.strategy.blacklist = (o2 = t2 == null ? void 0 : t2.blacklist) !== null && o2 !== void 0 ? o2 : this.strategy.blacklist, this.strategy.samplelist = (i2 = t2 == null ? void 0 : t2.samplelist) !== null && i2 !== void 0 ? i2 : this.strategy.samplelist;
                for (var s2 = 0, a2 = this.strategy.samplelist; s2 < a2.length; s2++) {
                  var u2 = a2[s2].split(",");
                  u2.length == 2 && (this.realSample[u2[0]] = u2[1]);
                }
              }, t.prototype.needRequestConfig = function() {
                if (!this.needQueryConfig)
                  return false;
                var t2 = Number(this.storage.getItem(c));
                return Date.now() - t2 > 60 * this.strategy.requestInterval * 1e3;
              }, t.prototype.getUploadUrl = function() {
                return this.strategy.httpsUploadUrl + "?appkey=" + this.appkey;
              }, t.prototype.isBlackEvent = function(t2) {
                return this.strategy.blacklist.indexOf(t2) != -1;
              }, t.prototype.isEventUpOnOff = function() {
                return this.strategy.isEventUpOnOff;
              }, t.prototype.isSampleEvent = function(t2) {
                return !!Object.prototype.hasOwnProperty.call(this.realSample, t2) && this.realSample[t2] < Math.floor(Math.random() * Math.floor(1e4));
              }, t;
            }(), m = "session_storage_key", w = function() {
              function t(t2, e, n2) {
                this.getSessionStackDepth = 0, this.beacon = n2, this.storage = t2, this.duration = e, this.appkey = n2.config.appkey;
              }
              return t.prototype.getSession = function() {
                this.getSessionStackDepth += 1;
                var t2 = this.storage.getItem(m);
                if (!t2)
                  return this.createSession();
                var e = "", n2 = 0;
                try {
                  var r2 = JSON.parse(t2) || {
                    sessionId: void 0,
                    sessionStart: void 0
                  };
                  if (!r2.sessionId || !r2.sessionStart)
                    return this.createSession();
                  var o2 = Number(this.storage.getItem(s));
                  if (Date.now() - o2 > this.duration)
                    return this.createSession();
                  e = r2.sessionId, n2 = r2.sessionStart, this.getSessionStackDepth = 0;
                } catch (t3) {
                }
                return {
                  sessionId: e,
                  sessionStart: n2
                };
              }, t.prototype.createSession = function() {
                var t2 = Date.now(), e = {
                  sessionId: this.appkey + "_" + t2.toString(),
                  sessionStart: t2
                };
                this.storage.setItem(m, JSON.stringify(e)), this.storage.setItem(s, t2.toString());
                var n2 = "is_new_user", r2 = this.storage.getItem(n2);
                return this.getSessionStackDepth <= 1 && this.beacon.onDirectUserAction("rqd_applaunched", {
                  A21: r2 ? "N" : "Y"
                }), this.storage.setItem(n2, JSON.stringify(false)), e;
              }, t;
            }();
            function b() {
              var t = navigator.userAgent, e = t.indexOf("compatible") > -1 && t.indexOf("MSIE") > -1, n2 = t.indexOf("Edge") > -1 && !e, r2 = t.indexOf("Trident") > -1 && t.indexOf("rv:11.0") > -1;
              if (e) {
                new RegExp("MSIE (\\d+\\.\\d+);").test(t);
                var o2 = parseFloat(RegExp.$1);
                return o2 == 7 ? 7 : o2 == 8 ? 8 : o2 == 9 ? 9 : o2 == 10 ? 10 : 6;
              }
              return n2 ? -2 : r2 ? 11 : -1;
            }
            function S(t, e) {
              var n2, r2;
              return (n2 = "https://tun-cos-1258344701.file.myqcloud.com/fp.js", r2 === void 0 && (r2 = Date.now() + "-" + Math.random()), new Promise(function(t2, e2) {
                if (document.getElementById(r2))
                  t2(void 0);
                else {
                  var o2 = document.getElementsByTagName("head")[0], i2 = document.createElement("script");
                  i2.onload = function() {
                    return function() {
                      i2.onload = null, t2(void 0);
                    };
                  }, i2.onerror = function(t3) {
                    i2.onerror = null, o2.removeChild(i2), e2(t3);
                  }, i2.src = n2, i2.id = r2, o2.appendChild(i2);
                }
              })).then(function() {
                new Fingerprint().getQimei36(t, e);
              }).catch(function(t2) {
              }), "";
            }
            var _I = function I() {
              return (_I = Object.assign || function(t) {
                for (var e, n2 = 1, r2 = arguments.length; n2 < r2; n2++) {
                  for (var o2 in e = arguments[n2]) {
                    Object.prototype.hasOwnProperty.call(e, o2) && (t[o2] = e[o2]);
                  }
                }
                return t;
              }).apply(this, arguments);
            };
            var E, k = function() {
              function t(t2, e) {
                e === void 0 && (e = {}), this.reportOptions = {}, this.config = t2, this.reportOptions = e;
              }
              return t.canUseDB = function() {
                return !!(window === null || window === void 0 ? void 0 : window.indexedDB);
              }, t.prototype.openDB = function() {
                var e = this;
                return new Promise(function(n2, r2) {
                  if (!t.canUseDB())
                    return r2({
                      message: "\u5F53\u524D\u4E0D\u652F\u6301 indexeddb"
                    });
                  var o2 = e.config, i2 = o2.name, s2 = o2.version, a2 = o2.stores, u2 = indexedDB.open(i2, s2);
                  u2.onsuccess = function() {
                    e.db = u2.result, n2(), _I({
                      result: 1,
                      func: "open",
                      params: JSON.stringify(e.config)
                    }, e.reportOptions);
                  }, u2.onerror = function(t2) {
                    var n3, o3;
                    r2(t2), _I({
                      result: 0,
                      func: "open",
                      params: JSON.stringify(e.config),
                      error_msg: (o3 = (n3 = t2.target) === null || n3 === void 0 ? void 0 : n3.error) === null || o3 === void 0 ? void 0 : o3.message
                    }, e.reportOptions);
                  }, u2.onupgradeneeded = function() {
                    e.db = u2.result;
                    try {
                      a2 == null || a2.forEach(function(t2) {
                        e.createStore(t2);
                      });
                    } catch (t2) {
                      _I({
                        result: 0,
                        func: "open",
                        params: JSON.stringify(e.config),
                        error_msg: t2.message
                      }, e.reportOptions), r2(t2);
                    }
                  };
                });
              }, t.prototype.useStore = function(t2) {
                return this.storeName = t2, this;
              }, t.prototype.deleteDB = function() {
                var t2 = this;
                return this.closeDB(), new Promise(function(e, n2) {
                  var r2 = indexedDB.deleteDatabase(t2.config.name);
                  r2.onsuccess = function() {
                    return e();
                  }, r2.onerror = n2;
                });
              }, t.prototype.closeDB = function() {
                var t2;
                (t2 = this.db) === null || t2 === void 0 || t2.close(), this.db = null;
              }, t.prototype.getStoreCount = function() {
                var t2 = this;
                return new Promise(function(e, n2) {
                  var r2 = t2.getStore("readonly").count();
                  r2.onsuccess = function() {
                    return e(r2.result);
                  }, r2.onerror = n2;
                });
              }, t.prototype.clearStore = function() {
                var t2 = this;
                return new Promise(function(e, n2) {
                  var r2 = t2.getStore("readwrite").clear();
                  r2.onsuccess = function() {
                    return e();
                  }, r2.onerror = n2;
                });
              }, t.prototype.add = function(t2, e) {
                var n2 = this;
                return new Promise(function(r2, o2) {
                  var i2 = n2.getStore("readwrite").add(t2, e);
                  i2.onsuccess = function() {
                    r2(i2.result);
                  }, i2.onerror = o2;
                });
              }, t.prototype.put = function(t2, e) {
                var n2 = this;
                return new Promise(function(r2, o2) {
                  var i2 = n2.getStore("readwrite").put(t2, e);
                  i2.onsuccess = function() {
                    r2(i2.result);
                  }, i2.onerror = o2;
                });
              }, t.prototype.getStoreAllData = function() {
                var t2 = this;
                return new Promise(function(e, n2) {
                  var r2 = t2.getStore("readonly").openCursor(), o2 = [];
                  r2.onsuccess = function() {
                    var t3;
                    if ((t3 = r2.result) === null || t3 === void 0 ? void 0 : t3.value) {
                      var n3 = r2.result.value;
                      o2.push(n3), r2.result.continue();
                    } else
                      e(o2);
                  }, r2.onerror = n2;
                });
              }, t.prototype.getDataRangeByIndex = function(t2, e, n2, r2, o2) {
                var i2 = this;
                return new Promise(function(s2, a2) {
                  var u2 = i2.getStore().index(t2), c2 = IDBKeyRange.bound(e, n2, r2, o2), l2 = [], p2 = u2.openCursor(c2);
                  p2.onsuccess = function() {
                    var t3;
                    ((t3 = p2 == null ? void 0 : p2.result) === null || t3 === void 0 ? void 0 : t3.value) ? (l2.push(p2 == null ? void 0 : p2.result.value), p2 == null || p2.result.continue()) : s2(l2);
                  }, p2.onerror = a2;
                });
              }, t.prototype.removeDataByIndex = function(t2, e, n2, r2, o2) {
                var i2 = this;
                return new Promise(function(s2, a2) {
                  var u2 = i2.getStore("readwrite").index(t2), c2 = IDBKeyRange.bound(e, n2, r2, o2), l2 = u2.openCursor(c2), p2 = 0;
                  l2.onsuccess = function(t3) {
                    var e2 = t3.target.result;
                    e2 ? (p2 += 1, e2.delete(), e2.continue()) : s2(p2);
                  }, l2.onerror = a2;
                });
              }, t.prototype.createStore = function(t2) {
                var e = t2.name, n2 = t2.indexes, r2 = n2 === void 0 ? [] : n2, o2 = t2.options;
                if (this.db) {
                  this.db.objectStoreNames.contains(e) && this.db.deleteObjectStore(e);
                  var i2 = this.db.createObjectStore(e, o2);
                  r2.forEach(function(t3) {
                    i2.createIndex(t3.indexName, t3.keyPath, t3.options);
                  });
                }
              }, t.prototype.getStore = function(t2) {
                var e;
                return t2 === void 0 && (t2 = "readonly"), (e = this.db) === null || e === void 0 ? void 0 : e.transaction(this.storeName, t2).objectStore(this.storeName);
              }, t;
            }(), O = "event_table_v3", C = "eventId", D = function() {
              function t(t2) {
                this.isReady = false, this.taskQueue = Promise.resolve(), this.db = new k({
                  name: "Beacon_" + t2 + "_V3",
                  version: 1,
                  stores: [{
                    name: O,
                    options: {
                      keyPath: C
                    },
                    indexes: [{
                      indexName: C,
                      keyPath: C,
                      options: {
                        unique: true
                      }
                    }]
                  }]
                }), this.open();
              }
              return t.prototype.getCount = function() {
                var t2 = this;
                return this.readyExec(function() {
                  return t2.db.getStoreCount();
                });
              }, t.prototype.setItem = function(t2, e) {
                var n2 = this;
                return this.readyExec(function() {
                  return n2.db.add({
                    eventId: t2,
                    value: e
                  });
                });
              }, t.prototype.getItem = function(t2) {
                return n(this, void 0, void 0, function() {
                  var e = this;
                  return r(this, function(n2) {
                    return [2, this.readyExec(function() {
                      return e.db.getDataRangeByIndex(C, t2, t2);
                    })];
                  });
                });
              }, t.prototype.removeItem = function(t2) {
                var e = this;
                return this.readyExec(function() {
                  return e.db.removeDataByIndex(C, t2, t2);
                });
              }, t.prototype.updateItem = function(t2, e) {
                var n2 = this;
                return this.readyExec(function() {
                  return n2.db.put({
                    eventId: t2,
                    value: e
                  });
                });
              }, t.prototype.iterate = function(t2) {
                var e = this;
                return this.readyExec(function() {
                  return e.db.getStoreAllData().then(function(e2) {
                    e2.forEach(function(e3) {
                      t2(e3.value);
                    });
                  });
                });
              }, t.prototype.open = function() {
                return n(this, void 0, void 0, function() {
                  var t2 = this;
                  return r(this, function(e) {
                    switch (e.label) {
                      case 0:
                        return this.taskQueue = this.taskQueue.then(function() {
                          return t2.db.openDB();
                        }), [4, this.taskQueue];
                      case 1:
                        return e.sent(), this.isReady = true, this.db.useStore(O), [2];
                    }
                  });
                });
              }, t.prototype.readyExec = function(t2) {
                return this.isReady ? t2() : (this.taskQueue = this.taskQueue.then(function() {
                  return t2();
                }), this.taskQueue);
              }, t;
            }(), x = function() {
              function t(t2) {
                this.keyObject = {}, this.storage = t2;
              }
              return t.prototype.getCount = function() {
                return this.storage.getStoreCount();
              }, t.prototype.removeItem = function(t2) {
                this.storage.removeItem(t2), delete this.keyObject[t2];
              }, t.prototype.setItem = function(t2, e) {
                var n2 = JSON.stringify(e);
                this.storage.setItem(t2, n2), this.keyObject[t2] = e;
              }, t.prototype.iterate = function(t2) {
                for (var e = Object.keys(this.keyObject), n2 = 0; n2 < e.length; n2++) {
                  var r2 = this.storage.getItem(e[n2]);
                  t2(JSON.parse(r2));
                }
              }, t;
            }(), _ = function() {
              function t(t2, e) {
                var n2 = this;
                this.dbEventCount = 0, b() > 0 || !window.indexedDB || /X5Lite/.test(navigator.userAgent) ? (this.store = new x(e), this.dbEventCount = this.store.getCount()) : (this.store = new D(t2), this.getCount().then(function(t3) {
                  n2.dbEventCount = t3;
                }).catch(function(t3) {
                }));
              }
              return t.prototype.getCount = function() {
                return n(this, void 0, void 0, function() {
                  return r(this, function(t2) {
                    switch (t2.label) {
                      case 0:
                        return t2.trys.push([0, 2, , 3]), [4, this.store.getCount()];
                      case 1:
                        return [2, t2.sent()];
                      case 2:
                        return t2.sent(), [2, Promise.reject()];
                      case 3:
                        return [2];
                    }
                  });
                });
              }, t.prototype.insertEvent = function(t2, e) {
                return n(this, void 0, void 0, function() {
                  var n2, o2;
                  return r(this, function(r2) {
                    switch (r2.label) {
                      case 0:
                        if (this.dbEventCount >= 1e4)
                          return [2, Promise.reject()];
                        n2 = f(t2.mapValue), r2.label = 1;
                      case 1:
                        return r2.trys.push([1, 3, , 4]), this.dbEventCount++, [4, this.store.setItem(n2, t2)];
                      case 2:
                        return [2, r2.sent()];
                      case 3:
                        return o2 = r2.sent(), e && e(o2, t2), this.dbEventCount--, [2, Promise.reject()];
                      case 4:
                        return [2];
                    }
                  });
                });
              }, t.prototype.getEvents = function() {
                return n(this, void 0, void 0, function() {
                  var t2;
                  return r(this, function(e) {
                    switch (e.label) {
                      case 0:
                        t2 = [], e.label = 1;
                      case 1:
                        return e.trys.push([1, 3, , 4]), [4, this.store.iterate(function(e2) {
                          t2.push(e2);
                        })];
                      case 2:
                        return e.sent(), [2, Promise.all(t2)];
                      case 3:
                        return e.sent(), [2, Promise.all(t2)];
                      case 4:
                        return [2];
                    }
                  });
                });
              }, t.prototype.removeEvent = function(t2) {
                return n(this, void 0, void 0, function() {
                  var e;
                  return r(this, function(n2) {
                    switch (n2.label) {
                      case 0:
                        e = f(t2.mapValue), n2.label = 1;
                      case 1:
                        return n2.trys.push([1, 3, , 4]), this.dbEventCount--, [4, this.store.removeItem(e)];
                      case 2:
                        return [2, n2.sent()];
                      case 3:
                        return n2.sent(), this.dbEventCount++, [2, Promise.reject()];
                      case 4:
                        return [2];
                    }
                  });
                });
              }, t;
            }(), _P = function P() {
              return (_P = Object.assign || function(t) {
                for (var e, n2 = 1, r2 = arguments.length; n2 < r2; n2++) {
                  for (var o2 in e = arguments[n2]) {
                    Object.prototype.hasOwnProperty.call(e, o2) && (t[o2] = e[o2]);
                  }
                }
                return t;
              }).apply(this, arguments);
            };
            function T(t) {
              try {
                return decodeURIComponent(t.replace(/\+/g, " "));
              } catch (t2) {
                return null;
              }
            }
            function U(t, e) {
              var n2 = [null, void 0, "", NaN].includes(t);
              if (e.isSkipEmpty && n2)
                return null;
              var r2 = !e.isSkipEmpty && n2 ? "" : t;
              try {
                return e.encode ? encodeURIComponent(r2) : r2;
              } catch (t2) {
                return null;
              }
            }
            function N(t, e) {
              e === void 0 && (e = {
                encode: true,
                isSkipEmpty: false
              });
              var n2 = t.url, r2 = t.query, o2 = r2 === void 0 ? {} : r2, i2 = t.hash, s2 = n2.split("#"), a2 = s2[0], u2 = s2[1], c2 = u2 === void 0 ? "" : u2, l2 = a2.split("?")[0], p2 = [], h2 = U(i2 || c2, e), f2 = _P(_P({}, function(t2) {
                var e2 = t2.split("#"), n3 = e2[0], r3 = e2[1], o3 = r3 === void 0 ? "" : r3, i3 = n3.split("?"), s3 = i3[0], a3 = i3[1], u3 = a3 === void 0 ? "" : a3, c3 = T(o3), l3 = /* @__PURE__ */ Object.create(null);
                return u3.split("&").forEach(function(t3) {
                  var e3 = t3.split("="), n4 = e3[0], r4 = e3[1], o4 = r4 === void 0 ? "" : r4, i4 = T(n4), s4 = T(o4);
                  i4 === null || s4 === null || i4 === "" && s4 === "" || l3[i4] || (l3[i4] = s4);
                }), {
                  url: s3,
                  query: l3,
                  hash: c3
                };
              }(n2).query), o2);
              return Object.keys(f2).forEach(function(t2) {
                var n3 = U(t2, e), r3 = U(f2[t2], e);
                n3 !== null && r3 !== null && p2.push(n3 + "=" + r3);
              }), l2 + (p2.length ? "?" + p2.join("&") : "") + (h2 ? "#" + h2 : "");
            }
            function j(t, e) {
              return new Promise(function(n2, r2) {
                if (e && document.querySelectorAll("script[data-tag=" + e + "]").length)
                  return n2();
                var o2 = document.createElement("script"), i2 = _P({
                  type: "text/javascript",
                  charset: "utf-8"
                }, t);
                Object.keys(i2).forEach(function(t2) {
                  return function(t3, e2, n3) {
                    if (t3)
                      return n3 === void 0 ? t3.getAttribute(e2) : t3.setAttribute(e2, n3);
                  }(o2, t2, i2[t2]);
                }), e && (o2.dataset.tag = e), o2.onload = function() {
                  return n2();
                }, o2.onreadystatechange = function() {
                  var t2 = o2.readyState;
                  ["complete", "loaded"].includes(t2) && (o2.onreadystatechange = null, n2());
                }, o2.onerror = r2, document.body.appendChild(o2);
              });
            }
            !function(t) {
              t[t.equal = 0] = "equal", t[t.low = -1] = "low", t[t.high = 1] = "high";
            }(E || (E = {}));
            var _q = function q() {
              return (_q = Object.assign || function(t) {
                for (var e, n2 = 1, r2 = arguments.length; n2 < r2; n2++) {
                  for (var o2 in e = arguments[n2]) {
                    Object.prototype.hasOwnProperty.call(e, o2) && (t[o2] = e[o2]);
                  }
                }
                return t;
              }).apply(this, arguments);
            };
            function A(t, e, n2, r2) {
              return new (n2 || (n2 = Promise))(function(o2, i2) {
                function s2(t2) {
                  try {
                    u2(r2.next(t2));
                  } catch (t3) {
                    i2(t3);
                  }
                }
                function a2(t2) {
                  try {
                    u2(r2.throw(t2));
                  } catch (t3) {
                    i2(t3);
                  }
                }
                function u2(t2) {
                  var e2;
                  t2.done ? o2(t2.value) : (e2 = t2.value, e2 instanceof n2 ? e2 : new n2(function(t3) {
                    t3(e2);
                  })).then(s2, a2);
                }
                u2((r2 = r2.apply(t, e || [])).next());
              });
            }
            function R(t, e) {
              var n2, r2, o2, i2, s2 = {
                label: 0,
                sent: function sent() {
                  if (1 & o2[0])
                    throw o2[1];
                  return o2[1];
                },
                trys: [],
                ops: []
              };
              return i2 = {
                next: a2(0),
                throw: a2(1),
                return: a2(2)
              }, typeof Symbol == "function" && (i2[Symbol.iterator] = function() {
                return this;
              }), i2;
              function a2(i3) {
                return function(a3) {
                  return function(i4) {
                    if (n2)
                      throw new TypeError("Generator is already executing.");
                    for (; s2; ) {
                      try {
                        if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
                          return o2;
                        switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                          case 0:
                          case 1:
                            o2 = i4;
                            break;
                          case 4:
                            return s2.label++, {
                              value: i4[1],
                              done: false
                            };
                          case 5:
                            s2.label++, r2 = i4[1], i4 = [0];
                            continue;
                          case 7:
                            i4 = s2.ops.pop(), s2.trys.pop();
                            continue;
                          default:
                            if (!((o2 = (o2 = s2.trys).length > 0 && o2[o2.length - 1]) || i4[0] !== 6 && i4[0] !== 2)) {
                              s2 = 0;
                              continue;
                            }
                            if (i4[0] === 3 && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                              s2.label = i4[1];
                              break;
                            }
                            if (i4[0] === 6 && s2.label < o2[1]) {
                              s2.label = o2[1], o2 = i4;
                              break;
                            }
                            if (o2 && s2.label < o2[2]) {
                              s2.label = o2[2], s2.ops.push(i4);
                              break;
                            }
                            o2[2] && s2.ops.pop(), s2.trys.pop();
                            continue;
                        }
                        i4 = e.call(t, s2);
                      } catch (t2) {
                        i4 = [6, t2], r2 = 0;
                      } finally {
                        n2 = o2 = 0;
                      }
                    }
                    if (5 & i4[0])
                      throw i4[1];
                    return {
                      value: i4[0] ? i4[1] : void 0,
                      done: true
                    };
                  }([i3, a3]);
                };
              }
            }
            var B = function() {
              function t() {
                this.interceptors = [];
              }
              return t.prototype.use = function(t2, e) {
                return this.interceptors.push({
                  resolved: t2,
                  rejected: e
                }), this.interceptors.length - 1;
              }, t.prototype.traverse = function(t2, e) {
                e === void 0 && (e = false);
                var n2 = Promise.resolve(t2);
                return (e ? Array.prototype.reduceRight : Array.prototype.reduce).call(this.interceptors, function(t3, e2) {
                  if (e2) {
                    var r2 = e2.resolved, o2 = e2.rejected;
                    n2 = n2.then(r2, o2);
                  }
                  return t3;
                }, ""), n2;
              }, t.prototype.eject = function(t2) {
                this.interceptors[t2] && (this.interceptors[t2] = null);
              }, t;
            }(), J = {
              defaults: {
                timeout: 0,
                method: "GET",
                mode: "cors",
                redirect: "follow",
                credentials: "same-origin"
              },
              headers: {
                common: {
                  Accept: "application/json, text/plain, */*"
                },
                POST: {
                  "Content-Type": "application/x-www-form-urlencoded"
                },
                PUT: {
                  "Content-Type": "application/x-www-form-urlencoded"
                },
                PATCH: {
                  "Content-Type": "application/x-www-form-urlencoded"
                }
              },
              baseURL: "",
              polyfillUrl: "https://vm.gtimg.cn/comps/script/fetch.min.js",
              interceptors: {
                request: new B(),
                response: new B()
              }
            }, V = /^([a-z][a-z\d+\-.]*:)?\/\//i, Q = Object.prototype.toString;
            function L(t) {
              return A(this, void 0, void 0, function() {
                var e;
                return R(this, function(n2) {
                  switch (n2.label) {
                    case 0:
                      if (window.fetch)
                        return [2];
                      n2.label = 1;
                    case 1:
                      return n2.trys.push([1, 3, , 4]), [4, j({
                        src: t
                      })];
                    case 2:
                      return n2.sent(), [3, 4];
                    case 3:
                      throw e = n2.sent(), new Error("\u52A0\u8F7D polyfill " + t + " \u5931\u8D25: " + e.message);
                    case 4:
                      return [2];
                  }
                });
              });
            }
            function M(t) {
              return ["Accept", "Content-Type"].forEach(function(e) {
                return n2 = e, void ((r2 = t.headers) && Object.keys(r2).forEach(function(t2) {
                  t2 !== n2 && t2.toUpperCase() === n2.toUpperCase() && (r2[n2] = r2[t2], delete r2[t2]);
                }));
                var n2, r2;
              }), function(t2) {
                if (Q.call(t2) !== "[object Object]")
                  return false;
                var e = Object.getPrototypeOf(t2);
                return e === null || e === Object.prototype;
              }(t.body) && (t.body = JSON.stringify(t.body), t.headers && (t.headers["Content-Type"] = "application/json;charset=utf-8")), t;
            }
            function K(t) {
              return A(this, void 0, void 0, function() {
                var e, n2, r2, o2, i2, s2, a2, u2, c2, l2, p2, h2, f2, d2, v2, g2, y2;
                return R(this, function(m2) {
                  switch (m2.label) {
                    case 0:
                      return e = J.baseURL, n2 = J.defaults, r2 = J.interceptors, [4, L(J.polyfillUrl)];
                    case 1:
                      return m2.sent(), (o2 = _q(_q({}, n2), t)).headers || (o2.headers = function(t2) {
                        t2 === void 0 && (t2 = "GET");
                        var e2 = J.headers[t2] || {};
                        return _q(_q({}, J.headers.common), e2);
                      }(o2.method)), M(o2), [4, r2.request.traverse(o2, true)];
                    case 2:
                      if ((i2 = m2.sent()) instanceof Error)
                        throw i2;
                      return i2.url = function(t2, e2) {
                        return !t2 || V.test(e2) ? e2 : t2.replace(/\/+$/, "") + "/" + e2.replace(/^\/+/, "");
                      }(e, i2.url), s2 = i2.url, a2 = i2.timeout, u2 = i2.params, c2 = i2.method, l2 = ["GET", "DELETE", "OPTIONS", "HEAD"].includes(c2 === void 0 ? "GET" : c2) && !!u2, p2 = l2 ? N({
                        url: s2,
                        query: u2
                      }) : s2, h2 = [], a2 && !i2.signal && (v2 = new Promise(function(t2) {
                        f2 = setTimeout(function() {
                          t2(new Error("timeout"));
                        }, a2);
                      }), h2.push(v2), d2 = new AbortController(), i2.signal = d2.signal), h2.push(fetch(p2, i2).catch(function(t2) {
                        return t2;
                      })), [4, Promise.race(h2)];
                    case 3:
                      return g2 = m2.sent(), f2 && clearTimeout(f2), [4, r2.response.traverse(g2)];
                    case 4:
                      if ((y2 = m2.sent()) instanceof Error)
                        throw d2 == null || d2.abort(), y2;
                      return [2, y2];
                  }
                });
              });
            }
            var F = function() {
              function t(t2) {
                J.interceptors.request.use(function(n2) {
                  var r2 = n2.url, o2 = n2.method, i2 = n2.body, s2 = i2;
                  if (t2.onReportBeforeSend) {
                    var a2 = t2.onReportBeforeSend({
                      url: r2,
                      method: o2,
                      data: i2 ? JSON.parse(i2) : null
                    });
                    s2 = (a2 == null ? void 0 : a2.data) ? JSON.stringify(a2.data) : null;
                  }
                  return o2 != "GET" && s2 ? _e(_e({}, n2), {
                    body: s2
                  }) : n2;
                });
              }
              return t.prototype.get = function(t2, o2) {
                return n(this, void 0, void 0, function() {
                  var n2, i2;
                  return r(this, function(r2) {
                    switch (r2.label) {
                      case 0:
                        return [4, K(_e({
                          url: t2
                        }, o2))];
                      case 1:
                        return [4, (n2 = r2.sent()).json()];
                      case 2:
                        return i2 = r2.sent(), [2, Promise.resolve({
                          data: i2,
                          status: n2.status,
                          statusText: n2.statusText,
                          headers: n2.headers
                        })];
                    }
                  });
                });
              }, t.prototype.post = function(t2, o2, i2) {
                return n(this, void 0, void 0, function() {
                  var n2, s2;
                  return r(this, function(r2) {
                    switch (r2.label) {
                      case 0:
                        return [4, K(_e({
                          url: t2,
                          body: o2,
                          method: "POST"
                        }, i2))];
                      case 1:
                        return [4, (n2 = r2.sent()).json()];
                      case 2:
                        return s2 = r2.sent(), [2, Promise.resolve({
                          data: s2,
                          status: n2.status,
                          statusText: n2.statusText,
                          headers: n2.headers
                        })];
                    }
                  });
                });
              }, t;
            }(), G = function() {
              function t(t2) {
                this.appkey = t2;
              }
              return t.prototype.getItem = function(t2) {
                try {
                  return window.localStorage.getItem(this.getStoreKey(t2));
                } catch (t3) {
                  return "";
                }
              }, t.prototype.removeItem = function(t2) {
                try {
                  window.localStorage.removeItem(this.getStoreKey(t2));
                } catch (t3) {
                }
              }, t.prototype.setItem = function(t2, e) {
                try {
                  window.localStorage.setItem(this.getStoreKey(t2), e);
                } catch (t3) {
                }
              }, t.prototype.setSessionItem = function(t2, e) {
                try {
                  window.sessionStorage.setItem(this.getStoreKey(t2), e);
                } catch (t3) {
                }
              }, t.prototype.getSessionItem = function(t2) {
                try {
                  return window.sessionStorage.getItem(this.getStoreKey(t2));
                } catch (t3) {
                  return "";
                }
              }, t.prototype.getStoreKey = function(t2) {
                return o + this.appkey + "_" + t2;
              }, t.prototype.createDeviceId = function() {
                try {
                  var t2 = window.localStorage.getItem(i);
                  return t2 || (t2 = function(t3) {
                    for (var e = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz0123456789", n2 = "", r2 = 0; r2 < t3; r2++) {
                      n2 += e.charAt(Math.floor(Math.random() * e.length));
                    }
                    return n2;
                  }(32), window.localStorage.setItem(i, t2)), t2;
                } catch (t3) {
                  return "";
                }
              }, t.prototype.clear = function() {
                try {
                  for (var t2 = window.localStorage.length, e = 0; e < t2; e++) {
                    var n2 = window.localStorage.key(e);
                    (n2 == null ? void 0 : n2.substr(0, 9)) == o && window.localStorage.removeItem(n2);
                  }
                } catch (t3) {
                }
              }, t.prototype.getStoreCount = function() {
                var t2 = 0;
                try {
                  t2 = window.localStorage.length;
                } catch (t3) {
                }
                return t2;
              }, t;
            }(), z = "logid_start", W = "4.5.14-web";
            return function(n2) {
              function r2(t) {
                var e = n2.call(this, t) || this;
                e.qimei36 = "", e.uselessCycleTaskNum = 0, e.underWeakNet = false, e.pauseSearching = false, e.send = function(t2, n3, r4) {
                  e.storage.setItem(s, Date.now().toString()), e.network.post(e.uploadUrl || e.strategy.getUploadUrl(), t2.data).then(function(r5) {
                    var o3;
                    ((o3 = r5 == null ? void 0 : r5.data) === null || o3 === void 0 ? void 0 : o3.result) == 100 ? e.delayTime = 1e3 * r5.data.delayTime : e.delayTime = 0, n3 && n3(t2.data), t2.data.events.forEach(function(t3) {
                      e.store.removeEvent(t3).then(function() {
                        e.removeSendingId(f(t3.mapValue));
                      });
                    }), e.doCustomCycleTask();
                  }).catch(function(n4) {
                    var o3 = t2.data.events;
                    e.errorReport.reportError(n4.code ? n4.code.toString() : "600", n4.message), r4 && r4(t2.data);
                    var i3 = JSON.parse(e.storage.getItem(a));
                    o3.forEach(function(t3) {
                      i3 && i3.indexOf(f(t3)) != -1 && e.store.insertEvent(t3, function(t4, n5) {
                        t4 && e.errorReport.reportError("604", "insertEvent fail!");
                      }), e.removeSendingId(f(t3));
                    }), e.monitorUploadFailed();
                  });
                };
                var r3, o2, i2 = b();
                return e.isUnderIE8 = i2 > 0 && i2 < 8, e.isUnderIE8 || (e.isUnderIE = i2 > 0, t.needInitQimei && S(t.appkey, function(t2) {
                  e.qimei36 = t2.q36;
                }), e.network = new F(t), e.storage = new G(t.appkey), e.initCommonInfo(t), e.store = new _(t.appkey, e.storage), e.errorReport = new g(e.config, e.commonInfo, "web", e.network), e.strategy = new y(t.needQueryConfig == null || t.needQueryConfig, e.config, e.commonInfo, e.storage, e.network), e.logidStartTime = e.storage.getItem(z), e.logidStartTime || (e.logidStartTime = Date.now().toString(), e.storage.setItem(z, e.logidStartTime)), r3 = e.logidStartTime, o2 = Date.now() - Number.parseFloat(r3), Math.floor(o2 / 864e5) >= 365 && e.storage.clear(), e.initSession(t), e.onDirectUserAction("rqd_js_init", {}), setTimeout(function() {
                  return e.lifeCycle.emit("init");
                }, 0), e.initDelayTime = t.delay ? t.delay : 1e3, e.cycleTask(e.initDelayTime)), e;
              }
              return function(e, n3) {
                if (typeof n3 != "function" && n3 !== null)
                  throw new TypeError("Class extends value " + String(n3) + " is not a constructor or null");
                function r3() {
                  this.constructor = e;
                }
                _t(e, n3), e.prototype = n3 === null ? Object.create(n3) : (r3.prototype = n3.prototype, new r3());
              }(r2, n2), r2.prototype.initSession = function(t) {
                var e = 18e5;
                t.sessionDuration && t.sessionDuration > 3e4 && (e = t.sessionDuration), this.beaconSession = new w(this.storage, e, this);
              }, r2.prototype.initCommonInfo = function(t) {
                var e = Number(this.storage.getItem(s));
                try {
                  var n3 = JSON.parse(this.storage.getItem(a));
                  (Date.now() - e > 3e4 || !n3) && this.storage.setItem(a, JSON.stringify([]));
                } catch (t2) {
                }
                t.uploadUrl && (this.uploadUrl = t.uploadUrl + "?appkey=" + t.appkey);
                var r3 = [window.screen.width, window.screen.height];
                window.devicePixelRatio && r3.push(window.devicePixelRatio), this.commonInfo = {
                  deviceId: this.storage.createDeviceId(),
                  language: navigator && navigator.language || "zh_CN",
                  query: window.location.search,
                  userAgent: navigator.userAgent,
                  pixel: r3.join("*"),
                  channelID: t.channelID ? String(t.channelID) : "",
                  openid: t.openid ? String(t.openid) : "",
                  unid: t.unionid ? String(t.unionid) : "",
                  sdkVersion: W
                }, this.config.appVersion = t.versionCode ? String(t.versionCode) : "", this.config.strictMode = t.strictMode;
              }, r2.prototype.cycleTask = function(t) {
                var e = this;
                this.intervalID = window.setInterval(function() {
                  e.pauseSearching || e.store.getEvents().then(function(t2) {
                    t2.length == 0 && (e.pauseSearching = true);
                    var n3 = [], r3 = JSON.parse(e.storage.getItem(a));
                    r3 || (r3 = []), t2 && t2.forEach(function(t3) {
                      var e2 = f(t3.mapValue);
                      r3.indexOf(e2) == -1 && (n3.push(t3), r3.push(e2));
                    }), n3.length != 0 && (e.storage.setItem(a, JSON.stringify(r3)), e._normalLogPipeline(e.assembleData(n3)));
                  }).catch(function(t2) {
                  });
                }, t);
              }, r2.prototype.onReport = function(t, e, n3) {
                var r3 = this;
                if (this.isUnderIE8)
                  this.errorReport.reportError("601", "UnderIE8");
                else {
                  this.pauseSearching = false;
                  var o2 = this.generateData(t, e, n3);
                  if (n3 && this.delayTime == 0 && !this.underWeakNet)
                    this._normalLogPipeline(this.assembleData(o2));
                  else {
                    var i2 = o2.shift();
                    i2 && this.store.insertEvent(i2, function(t2) {
                      t2 && r3.errorReport.reportError("604", "insertEvent fail!");
                    }).catch(function(t2) {
                      r3._normalLogPipeline(r3.assembleData(o2));
                    });
                  }
                }
              }, r2.prototype.onSendBeacon = function(t, e) {
                if (this.isUnderIE)
                  this.errorReport.reportError("605", "UnderIE");
                else {
                  this.pauseSearching = false;
                  var n3 = this.assembleData(this.generateData(t, e, true));
                  typeof navigator.sendBeacon == "function" && navigator.sendBeacon(this.uploadUrl || this.strategy.getUploadUrl(), JSON.stringify(n3));
                }
              }, r2.prototype.generateData = function(t, n3, r3) {
                var o2 = [], i2 = "4.5.14-web_" + (r3 ? "direct_log_id" : "normal_log_id"), s2 = Number(this.storage.getItem(i2));
                return s2 = s2 || 1, n3 = _e(_e({}, n3), {
                  A99: r3 ? "Y" : "N",
                  A100: s2.toString(),
                  A72: W,
                  A88: this.logidStartTime
                }), s2++, this.storage.setItem(i2, s2.toString()), o2.push({
                  eventCode: t,
                  eventTime: Date.now().toString(),
                  mapValue: p(n3, this.config.strictMode)
                }), o2;
              }, r2.prototype.assembleData = function(t) {
                var n3 = this.beaconSession.getSession();
                return {
                  appVersion: this.config.appVersion ? h(this.config.appVersion) : "",
                  sdkId: "js",
                  sdkVersion: W,
                  mainAppKey: this.config.appkey,
                  platformId: 3,
                  common: p(_e(_e({}, this.additionalParams), {
                    A2: this.commonInfo.deviceId,
                    A8: this.commonInfo.openid,
                    A12: this.commonInfo.language,
                    A17: this.commonInfo.pixel,
                    A23: this.commonInfo.channelID,
                    A50: this.commonInfo.unid,
                    A76: n3.sessionId,
                    A101: this.commonInfo.userAgent,
                    A102: window.location.href,
                    A104: document.referrer,
                    A119: this.commonInfo.query,
                    A153: this.qimei36
                  }), false),
                  events: t
                };
              }, r2.prototype.monitorUploadFailed = function() {
                this.uselessCycleTaskNum++, this.uselessCycleTaskNum >= 5 && (window.clearInterval(this.intervalID), this.cycleTask(6e4), this.underWeakNet = true);
              }, r2.prototype.doCustomCycleTask = function() {
                this.uselessCycleTaskNum >= 5 && (window.clearInterval(this.intervalID), this.cycleTask(this.initDelayTime)), this.uselessCycleTaskNum = 0, this.underWeakNet = false;
              }, r2;
            }(v);
          });
        },
        "./lib/crypto.js": function(module2, exports2, __webpack_require__2) {
          (function(module3) {
            var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
            var CryptoJS = CryptoJS || function(g, l) {
              var e = {}, d = e.lib = {}, m = function m2() {
              }, k = d.Base = {
                extend: function extend(a) {
                  m.prototype = this;
                  var c = new m();
                  a && c.mixIn(a);
                  c.hasOwnProperty("init") || (c.init = function() {
                    c.$super.init.apply(this, arguments);
                  });
                  c.init.prototype = c;
                  c.$super = this;
                  return c;
                },
                create: function create() {
                  var a = this.extend();
                  a.init.apply(a, arguments);
                  return a;
                },
                init: function init() {
                },
                mixIn: function mixIn(a) {
                  for (var c in a) {
                    a.hasOwnProperty(c) && (this[c] = a[c]);
                  }
                  a.hasOwnProperty("toString") && (this.toString = a.toString);
                },
                clone: function clone() {
                  return this.init.prototype.extend(this);
                }
              }, p = d.WordArray = k.extend({
                init: function init(a, c) {
                  a = this.words = a || [];
                  this.sigBytes = c != l ? c : 4 * a.length;
                },
                toString: function toString(a) {
                  return (a || n).stringify(this);
                },
                concat: function concat(a) {
                  var c = this.words, q = a.words, f = this.sigBytes;
                  a = a.sigBytes;
                  this.clamp();
                  if (f % 4)
                    for (var b2 = 0; b2 < a; b2++) {
                      c[f + b2 >>> 2] |= (q[b2 >>> 2] >>> 24 - 8 * (b2 % 4) & 255) << 24 - 8 * ((f + b2) % 4);
                    }
                  else if (65535 < q.length)
                    for (b2 = 0; b2 < a; b2 += 4) {
                      c[f + b2 >>> 2] = q[b2 >>> 2];
                    }
                  else
                    c.push.apply(c, q);
                  this.sigBytes += a;
                  return this;
                },
                clamp: function clamp() {
                  var a = this.words, c = this.sigBytes;
                  a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
                  a.length = g.ceil(c / 4);
                },
                clone: function clone() {
                  var a = k.clone.call(this);
                  a.words = this.words.slice(0);
                  return a;
                },
                random: function random(a) {
                  for (var c = [], b2 = 0; b2 < a; b2 += 4) {
                    c.push(4294967296 * g.random() | 0);
                  }
                  return new p.init(c, a);
                }
              }), b = e.enc = {}, n = b.Hex = {
                stringify: function stringify(a) {
                  var c = a.words;
                  a = a.sigBytes;
                  for (var b2 = [], f = 0; f < a; f++) {
                    var d2 = c[f >>> 2] >>> 24 - 8 * (f % 4) & 255;
                    b2.push((d2 >>> 4).toString(16));
                    b2.push((d2 & 15).toString(16));
                  }
                  return b2.join("");
                },
                parse: function parse(a) {
                  for (var c = a.length, b2 = [], f = 0; f < c; f += 2) {
                    b2[f >>> 3] |= parseInt(a.substr(f, 2), 16) << 24 - 4 * (f % 8);
                  }
                  return new p.init(b2, c / 2);
                }
              }, j = b.Latin1 = {
                stringify: function stringify(a) {
                  var c = a.words;
                  a = a.sigBytes;
                  for (var b2 = [], f = 0; f < a; f++) {
                    b2.push(String.fromCharCode(c[f >>> 2] >>> 24 - 8 * (f % 4) & 255));
                  }
                  return b2.join("");
                },
                parse: function parse(a) {
                  for (var c = a.length, b2 = [], f = 0; f < c; f++) {
                    b2[f >>> 2] |= (a.charCodeAt(f) & 255) << 24 - 8 * (f % 4);
                  }
                  return new p.init(b2, c);
                }
              }, h = b.Utf8 = {
                stringify: function stringify(a) {
                  try {
                    return decodeURIComponent(escape(j.stringify(a)));
                  } catch (c) {
                    throw Error("Malformed UTF-8 data");
                  }
                },
                parse: function parse(a) {
                  return j.parse(unescape(encodeURIComponent(a)));
                }
              }, r = d.BufferedBlockAlgorithm = k.extend({
                reset: function reset() {
                  this._data = new p.init();
                  this._nDataBytes = 0;
                },
                _append: function _append(a) {
                  typeof a == "string" && (a = h.parse(a));
                  this._data.concat(a);
                  this._nDataBytes += a.sigBytes;
                },
                _process: function _process(a) {
                  var c = this._data, b2 = c.words, f = c.sigBytes, d2 = this.blockSize, e2 = f / (4 * d2), e2 = a ? g.ceil(e2) : g.max((e2 | 0) - this._minBufferSize, 0);
                  a = e2 * d2;
                  f = g.min(4 * a, f);
                  if (a) {
                    for (var k2 = 0; k2 < a; k2 += d2) {
                      this._doProcessBlock(b2, k2);
                    }
                    k2 = b2.splice(0, a);
                    c.sigBytes -= f;
                  }
                  return new p.init(k2, f);
                },
                clone: function clone() {
                  var a = k.clone.call(this);
                  a._data = this._data.clone();
                  return a;
                },
                _minBufferSize: 0
              });
              d.Hasher = r.extend({
                cfg: k.extend(),
                init: function init(a) {
                  this.cfg = this.cfg.extend(a);
                  this.reset();
                },
                reset: function reset() {
                  r.reset.call(this);
                  this._doReset();
                },
                update: function update(a) {
                  this._append(a);
                  this._process();
                  return this;
                },
                finalize: function finalize(a) {
                  a && this._append(a);
                  return this._doFinalize();
                },
                blockSize: 16,
                _createHelper: function _createHelper(a) {
                  return function(b2, d2) {
                    return new a.init(d2).finalize(b2);
                  };
                },
                _createHmacHelper: function _createHmacHelper(a) {
                  return function(b2, d2) {
                    return new s.HMAC.init(a, d2).finalize(b2);
                  };
                }
              });
              var s = e.algo = {};
              return e;
            }(Math);
            (function() {
              var g = CryptoJS, l = g.lib, e = l.WordArray, d = l.Hasher, m = [], l = g.algo.SHA1 = d.extend({
                _doReset: function _doReset() {
                  this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                },
                _doProcessBlock: function _doProcessBlock(d2, e2) {
                  for (var b = this._hash.words, n = b[0], j = b[1], h = b[2], g2 = b[3], l2 = b[4], a = 0; 80 > a; a++) {
                    if (16 > a)
                      m[a] = d2[e2 + a] | 0;
                    else {
                      var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];
                      m[a] = c << 1 | c >>> 31;
                    }
                    c = (n << 5 | n >>> 27) + l2 + m[a];
                    c = 20 > a ? c + ((j & h | ~j & g2) + 1518500249) : 40 > a ? c + ((j ^ h ^ g2) + 1859775393) : 60 > a ? c + ((j & h | j & g2 | h & g2) - 1894007588) : c + ((j ^ h ^ g2) - 899497514);
                    l2 = g2;
                    g2 = h;
                    h = j << 30 | j >>> 2;
                    j = n;
                    n = c;
                  }
                  b[0] = b[0] + n | 0;
                  b[1] = b[1] + j | 0;
                  b[2] = b[2] + h | 0;
                  b[3] = b[3] + g2 | 0;
                  b[4] = b[4] + l2 | 0;
                },
                _doFinalize: function _doFinalize() {
                  var d2 = this._data, e2 = d2.words, b = 8 * this._nDataBytes, g2 = 8 * d2.sigBytes;
                  e2[g2 >>> 5] |= 128 << 24 - g2 % 32;
                  e2[(g2 + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);
                  e2[(g2 + 64 >>> 9 << 4) + 15] = b;
                  d2.sigBytes = 4 * e2.length;
                  this._process();
                  return this._hash;
                },
                clone: function clone() {
                  var e2 = d.clone.call(this);
                  e2._hash = this._hash.clone();
                  return e2;
                }
              });
              g.SHA1 = d._createHelper(l);
              g.HmacSHA1 = d._createHmacHelper(l);
            })();
            (function() {
              var g = CryptoJS, l = g.enc.Utf8;
              g.algo.HMAC = g.lib.Base.extend({
                init: function init(e, d) {
                  e = this._hasher = new e.init();
                  typeof d == "string" && (d = l.parse(d));
                  var g2 = e.blockSize, k = 4 * g2;
                  d.sigBytes > k && (d = e.finalize(d));
                  d.clamp();
                  for (var p = this._oKey = d.clone(), b = this._iKey = d.clone(), n = p.words, j = b.words, h = 0; h < g2; h++) {
                    n[h] ^= 1549556828, j[h] ^= 909522486;
                  }
                  p.sigBytes = b.sigBytes = k;
                  this.reset();
                },
                reset: function reset() {
                  var e = this._hasher;
                  e.reset();
                  e.update(this._iKey);
                },
                update: function update(e) {
                  this._hasher.update(e);
                  return this;
                },
                finalize: function finalize(e) {
                  var d = this._hasher;
                  e = d.finalize(e);
                  d.reset();
                  return d.finalize(this._oKey.clone().concat(e));
                }
              });
            })();
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var C_enc = C.enc;
              var Base64 = C_enc.Base64 = {
                stringify: function stringify(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var map = this._map;
                  wordArray.clamp();
                  var base64Chars = [];
                  for (var i = 0; i < sigBytes; i += 3) {
                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                    var triplet = byte1 << 16 | byte2 << 8 | byte3;
                    for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                      base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    while (base64Chars.length % 4) {
                      base64Chars.push(paddingChar);
                    }
                  }
                  return base64Chars.join("");
                },
                parse: function parse(base64Str) {
                  var base64StrLength = base64Str.length;
                  var map = this._map;
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    var paddingIndex = base64Str.indexOf(paddingChar);
                    if (paddingIndex != -1) {
                      base64StrLength = paddingIndex;
                    }
                  }
                  var words = [];
                  var nBytes = 0;
                  for (var i = 0; i < base64StrLength; i++) {
                    if (i % 4) {
                      var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;
                      var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;
                      words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
                      nBytes++;
                    }
                  }
                  return WordArray.create(words, nBytes);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
              };
            })();
            if ((false ? void 0 : _typeof2(module3)) === "object") {
              module3.exports = CryptoJS;
            } else {
              window.CryptoJS = CryptoJS;
            }
          }).call(this, __webpack_require__2("./node_modules/webpack/buildin/module.js")(module2));
        },
        "./lib/json2xml.js": function(module2, exports2, __webpack_require__2) {
          var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
          var element_start_char = "a-zA-Z_\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FFF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
          var element_non_start_char = "-.0-9\xB7\u0300-\u036F\u203F\u2040";
          var element_replace = new RegExp("^([^" + element_start_char + "])|^((x|X)(m|M)(l|L))|([^" + element_start_char + element_non_start_char + "])", "g");
          var not_safe_in_xml = /[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm;
          var objKeys = function objKeys2(obj) {
            var l = [];
            if (obj instanceof Object) {
              for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                  l.push(k);
                }
              }
            }
            return l;
          };
          var process_to_xml = function process_to_xml2(node_data, options) {
            var makeNode = function makeNode2(name, content, attributes, level, hasSubNodes) {
              var indent_value = options.indent !== void 0 ? options.indent : "	";
              var indent = options.prettyPrint ? "\n" + new Array(level).join(indent_value) : "";
              if (options.removeIllegalNameCharacters) {
                name = name.replace(element_replace, "_");
              }
              var node = [indent, "<", name, attributes || ""];
              if (content && content.length > 0) {
                node.push(">");
                node.push(content);
                hasSubNodes && node.push(indent);
                node.push("</");
                node.push(name);
                node.push(">");
              } else {
                node.push("/>");
              }
              return node.join("");
            };
            return function fn(node_data2, node_descriptor, level) {
              var type = _typeof2(node_data2);
              if (Array.isArray ? Array.isArray(node_data2) : node_data2 instanceof Array) {
                type = "array";
              } else if (node_data2 instanceof Date) {
                type = "date";
              }
              switch (type) {
                case "array":
                  var ret = [];
                  node_data2.map(function(v) {
                    ret.push(fn(v, 1, level + 1));
                  });
                  options.prettyPrint && ret.push("\n");
                  return ret.join("");
                  break;
                case "date":
                  return node_data2.toJSON ? node_data2.toJSON() : node_data2 + "";
                  break;
                case "object":
                  var nodes = [];
                  for (var name in node_data2) {
                    if (node_data2.hasOwnProperty(name)) {
                      if (node_data2[name] instanceof Array) {
                        for (var j = 0; j < node_data2[name].length; j++) {
                          if (node_data2[name].hasOwnProperty(j)) {
                            nodes.push(makeNode(name, fn(node_data2[name][j], 0, level + 1), null, level + 1, objKeys(node_data2[name][j]).length));
                          }
                        }
                      } else {
                        nodes.push(makeNode(name, fn(node_data2[name], 0, level + 1), null, level + 1));
                      }
                    }
                  }
                  options.prettyPrint && nodes.length > 0 && nodes.push("\n");
                  return nodes.join("");
                  break;
                case "function":
                  return node_data2();
                  break;
                default:
                  return options.escape ? esc(node_data2) : "" + node_data2;
              }
            }(node_data, 0, 0);
          };
          var xml_header = function xml_header2(standalone) {
            var ret = ['<?xml version="1.0" encoding="UTF-8"'];
            if (standalone) {
              ret.push(' standalone="yes"');
            }
            ret.push("?>");
            return ret.join("");
          };
          function esc(str) {
            return ("" + str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;").replace(not_safe_in_xml, "");
          }
          module2.exports = function(obj, options) {
            if (!options) {
              options = {
                xmlHeader: {
                  standalone: true
                },
                prettyPrint: true,
                indent: "  ",
                escape: true
              };
            }
            if (typeof obj == "string") {
              try {
                obj = JSON.parse(obj.toString());
              } catch (e) {
                return false;
              }
            }
            var xmlheader = "";
            var docType = "";
            if (options) {
              if (_typeof2(options) == "object") {
                if (options.xmlHeader) {
                  xmlheader = xml_header(!!options.xmlHeader.standalone);
                }
                if (typeof options.docType != "undefined") {
                  docType = "<!DOCTYPE " + options.docType + ">";
                }
              } else {
                xmlheader = xml_header();
              }
            }
            options = options || {};
            var ret = [xmlheader, options.prettyPrint && docType ? "\n" : "", docType, process_to_xml(obj, options)];
            return ret.join("").replace(/\n{2,}/g, "\n").replace(/\s+$/g, "");
          };
        },
        "./lib/md5.js": function(module, exports, __webpack_require__) {
          (function(process, global, module) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            var _typeof = __webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js");
            (function() {
              "use strict";
              var ERROR = "input is invalid type";
              var WINDOW = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";
              var root = WINDOW ? window : {};
              if (root.JS_MD5_NO_WINDOW) {
                WINDOW = false;
              }
              var WEB_WORKER = !WINDOW && (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object";
              var NODE_JS = !root.JS_MD5_NO_NODE_JS && (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.versions && process.versions.node;
              if (NODE_JS) {
                root = global;
              } else if (WEB_WORKER) {
                root = self;
              }
              var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && (false ? void 0 : _typeof(module)) === "object" && module.exports;
              var AMD = __webpack_require__("./node_modules/webpack/buildin/amd-options.js");
              var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
              var HEX_CHARS = "0123456789abcdef".split("");
              var EXTRA = [128, 32768, 8388608, -2147483648];
              var SHIFT = [0, 8, 16, 24];
              var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"];
              var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
              var blocks = [], buffer8;
              if (ARRAY_BUFFER) {
                var buffer = new ArrayBuffer(68);
                buffer8 = new Uint8Array(buffer);
                blocks = new Uint32Array(buffer);
              }
              if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
                Array.isArray = function(obj) {
                  return Object.prototype.toString.call(obj) === "[object Array]";
                };
              }
              if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
                ArrayBuffer.isView = function(obj) {
                  return _typeof(obj) === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
                };
              }
              var createOutputMethod = function createOutputMethod2(outputType) {
                return function(message, isBinStr) {
                  return new Md5(true).update(message, isBinStr)[outputType]();
                };
              };
              var createMethod = function createMethod2() {
                var method2 = createOutputMethod("hex");
                if (NODE_JS) {
                  method2 = nodeWrap(method2);
                }
                method2.getCtx = method2.create = function() {
                  return new Md5();
                };
                method2.update = function(message) {
                  return method2.create().update(message);
                };
                for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
                  var type = OUTPUT_TYPES[i];
                  method2[type] = createOutputMethod(type);
                }
                return method2;
              };
              var nodeWrap = function nodeWrap(method) {
                var crypto = eval("require('crypto')");
                var Buffer = eval("require('buffer').Buffer");
                var nodeMethod = function nodeMethod2(message) {
                  if (typeof message === "string") {
                    return crypto.createHash("md5").update(message, "utf8").digest("hex");
                  } else {
                    if (message === null || message === void 0) {
                      throw ERROR;
                    } else if (message.constructor === ArrayBuffer) {
                      message = new Uint8Array(message);
                    }
                  }
                  if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
                    return crypto.createHash("md5").update(new Buffer(message)).digest("hex");
                  } else {
                    return method(message);
                  }
                };
                return nodeMethod;
              };
              function Md5(sharedMemory) {
                if (sharedMemory) {
                  blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                  this.blocks = blocks;
                  this.buffer8 = buffer8;
                } else {
                  if (ARRAY_BUFFER) {
                    var buffer2 = new ArrayBuffer(68);
                    this.buffer8 = new Uint8Array(buffer2);
                    this.blocks = new Uint32Array(buffer2);
                  } else {
                    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                  }
                }
                this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
                this.finalized = this.hashed = false;
                this.first = true;
              }
              Md5.prototype.update = function(message, isBinStr) {
                if (this.finalized) {
                  return;
                }
                var code, index = 0, i, length = message.length, blocks2 = this.blocks;
                var buffer82 = this.buffer8;
                while (index < length) {
                  if (this.hashed) {
                    this.hashed = false;
                    blocks2[0] = blocks2[16];
                    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                  }
                  if (ARRAY_BUFFER) {
                    for (i = this.start; index < length && i < 64; ++index) {
                      code = message.charCodeAt(index);
                      if (isBinStr || code < 128) {
                        buffer82[i++] = code;
                      } else if (code < 2048) {
                        buffer82[i++] = 192 | code >> 6;
                        buffer82[i++] = 128 | code & 63;
                      } else if (code < 55296 || code >= 57344) {
                        buffer82[i++] = 224 | code >> 12;
                        buffer82[i++] = 128 | code >> 6 & 63;
                        buffer82[i++] = 128 | code & 63;
                      } else {
                        code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                        buffer82[i++] = 240 | code >> 18;
                        buffer82[i++] = 128 | code >> 12 & 63;
                        buffer82[i++] = 128 | code >> 6 & 63;
                        buffer82[i++] = 128 | code & 63;
                      }
                    }
                  } else {
                    for (i = this.start; index < length && i < 64; ++index) {
                      code = message.charCodeAt(index);
                      if (isBinStr || code < 128) {
                        blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                      } else if (code < 2048) {
                        blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                        blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                      } else if (code < 55296 || code >= 57344) {
                        blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                        blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                        blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                      } else {
                        code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                        blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                        blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                        blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                        blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                      }
                    }
                  }
                  this.lastByteIndex = i;
                  this.bytes += i - this.start;
                  if (i >= 64) {
                    this.start = i - 64;
                    this.hash();
                    this.hashed = true;
                  } else {
                    this.start = i;
                  }
                }
                if (this.bytes > 4294967295) {
                  this.hBytes += this.bytes / 4294967296 << 0;
                  this.bytes = this.bytes % 4294967296;
                }
                return this;
              };
              Md5.prototype.finalize = function() {
                if (this.finalized) {
                  return;
                }
                this.finalized = true;
                var blocks2 = this.blocks, i = this.lastByteIndex;
                blocks2[i >> 2] |= EXTRA[i & 3];
                if (i >= 56) {
                  if (!this.hashed) {
                    this.hash();
                  }
                  blocks2[0] = blocks2[16];
                  blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                }
                blocks2[14] = this.bytes << 3;
                blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
                this.hash();
              };
              Md5.prototype.hash = function() {
                var a, b, c, d, bc, da, blocks2 = this.blocks;
                if (this.first) {
                  a = blocks2[0] - 680876937;
                  a = (a << 7 | a >>> 25) - 271733879 << 0;
                  d = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
                  d = (d << 12 | d >>> 20) + a << 0;
                  c = (-271733879 ^ d & (a ^ -271733879)) + blocks2[2] - 1126478375;
                  c = (c << 17 | c >>> 15) + d << 0;
                  b = (a ^ c & (d ^ a)) + blocks2[3] - 1316259209;
                  b = (b << 22 | b >>> 10) + c << 0;
                } else {
                  a = this.h0;
                  b = this.h1;
                  c = this.h2;
                  d = this.h3;
                  a += (d ^ b & (c ^ d)) + blocks2[0] - 680876936;
                  a = (a << 7 | a >>> 25) + b << 0;
                  d += (c ^ a & (b ^ c)) + blocks2[1] - 389564586;
                  d = (d << 12 | d >>> 20) + a << 0;
                  c += (b ^ d & (a ^ b)) + blocks2[2] + 606105819;
                  c = (c << 17 | c >>> 15) + d << 0;
                  b += (a ^ c & (d ^ a)) + blocks2[3] - 1044525330;
                  b = (b << 22 | b >>> 10) + c << 0;
                }
                a += (d ^ b & (c ^ d)) + blocks2[4] - 176418897;
                a = (a << 7 | a >>> 25) + b << 0;
                d += (c ^ a & (b ^ c)) + blocks2[5] + 1200080426;
                d = (d << 12 | d >>> 20) + a << 0;
                c += (b ^ d & (a ^ b)) + blocks2[6] - 1473231341;
                c = (c << 17 | c >>> 15) + d << 0;
                b += (a ^ c & (d ^ a)) + blocks2[7] - 45705983;
                b = (b << 22 | b >>> 10) + c << 0;
                a += (d ^ b & (c ^ d)) + blocks2[8] + 1770035416;
                a = (a << 7 | a >>> 25) + b << 0;
                d += (c ^ a & (b ^ c)) + blocks2[9] - 1958414417;
                d = (d << 12 | d >>> 20) + a << 0;
                c += (b ^ d & (a ^ b)) + blocks2[10] - 42063;
                c = (c << 17 | c >>> 15) + d << 0;
                b += (a ^ c & (d ^ a)) + blocks2[11] - 1990404162;
                b = (b << 22 | b >>> 10) + c << 0;
                a += (d ^ b & (c ^ d)) + blocks2[12] + 1804603682;
                a = (a << 7 | a >>> 25) + b << 0;
                d += (c ^ a & (b ^ c)) + blocks2[13] - 40341101;
                d = (d << 12 | d >>> 20) + a << 0;
                c += (b ^ d & (a ^ b)) + blocks2[14] - 1502002290;
                c = (c << 17 | c >>> 15) + d << 0;
                b += (a ^ c & (d ^ a)) + blocks2[15] + 1236535329;
                b = (b << 22 | b >>> 10) + c << 0;
                a += (c ^ d & (b ^ c)) + blocks2[1] - 165796510;
                a = (a << 5 | a >>> 27) + b << 0;
                d += (b ^ c & (a ^ b)) + blocks2[6] - 1069501632;
                d = (d << 9 | d >>> 23) + a << 0;
                c += (a ^ b & (d ^ a)) + blocks2[11] + 643717713;
                c = (c << 14 | c >>> 18) + d << 0;
                b += (d ^ a & (c ^ d)) + blocks2[0] - 373897302;
                b = (b << 20 | b >>> 12) + c << 0;
                a += (c ^ d & (b ^ c)) + blocks2[5] - 701558691;
                a = (a << 5 | a >>> 27) + b << 0;
                d += (b ^ c & (a ^ b)) + blocks2[10] + 38016083;
                d = (d << 9 | d >>> 23) + a << 0;
                c += (a ^ b & (d ^ a)) + blocks2[15] - 660478335;
                c = (c << 14 | c >>> 18) + d << 0;
                b += (d ^ a & (c ^ d)) + blocks2[4] - 405537848;
                b = (b << 20 | b >>> 12) + c << 0;
                a += (c ^ d & (b ^ c)) + blocks2[9] + 568446438;
                a = (a << 5 | a >>> 27) + b << 0;
                d += (b ^ c & (a ^ b)) + blocks2[14] - 1019803690;
                d = (d << 9 | d >>> 23) + a << 0;
                c += (a ^ b & (d ^ a)) + blocks2[3] - 187363961;
                c = (c << 14 | c >>> 18) + d << 0;
                b += (d ^ a & (c ^ d)) + blocks2[8] + 1163531501;
                b = (b << 20 | b >>> 12) + c << 0;
                a += (c ^ d & (b ^ c)) + blocks2[13] - 1444681467;
                a = (a << 5 | a >>> 27) + b << 0;
                d += (b ^ c & (a ^ b)) + blocks2[2] - 51403784;
                d = (d << 9 | d >>> 23) + a << 0;
                c += (a ^ b & (d ^ a)) + blocks2[7] + 1735328473;
                c = (c << 14 | c >>> 18) + d << 0;
                b += (d ^ a & (c ^ d)) + blocks2[12] - 1926607734;
                b = (b << 20 | b >>> 12) + c << 0;
                bc = b ^ c;
                a += (bc ^ d) + blocks2[5] - 378558;
                a = (a << 4 | a >>> 28) + b << 0;
                d += (bc ^ a) + blocks2[8] - 2022574463;
                d = (d << 11 | d >>> 21) + a << 0;
                da = d ^ a;
                c += (da ^ b) + blocks2[11] + 1839030562;
                c = (c << 16 | c >>> 16) + d << 0;
                b += (da ^ c) + blocks2[14] - 35309556;
                b = (b << 23 | b >>> 9) + c << 0;
                bc = b ^ c;
                a += (bc ^ d) + blocks2[1] - 1530992060;
                a = (a << 4 | a >>> 28) + b << 0;
                d += (bc ^ a) + blocks2[4] + 1272893353;
                d = (d << 11 | d >>> 21) + a << 0;
                da = d ^ a;
                c += (da ^ b) + blocks2[7] - 155497632;
                c = (c << 16 | c >>> 16) + d << 0;
                b += (da ^ c) + blocks2[10] - 1094730640;
                b = (b << 23 | b >>> 9) + c << 0;
                bc = b ^ c;
                a += (bc ^ d) + blocks2[13] + 681279174;
                a = (a << 4 | a >>> 28) + b << 0;
                d += (bc ^ a) + blocks2[0] - 358537222;
                d = (d << 11 | d >>> 21) + a << 0;
                da = d ^ a;
                c += (da ^ b) + blocks2[3] - 722521979;
                c = (c << 16 | c >>> 16) + d << 0;
                b += (da ^ c) + blocks2[6] + 76029189;
                b = (b << 23 | b >>> 9) + c << 0;
                bc = b ^ c;
                a += (bc ^ d) + blocks2[9] - 640364487;
                a = (a << 4 | a >>> 28) + b << 0;
                d += (bc ^ a) + blocks2[12] - 421815835;
                d = (d << 11 | d >>> 21) + a << 0;
                da = d ^ a;
                c += (da ^ b) + blocks2[15] + 530742520;
                c = (c << 16 | c >>> 16) + d << 0;
                b += (da ^ c) + blocks2[2] - 995338651;
                b = (b << 23 | b >>> 9) + c << 0;
                a += (c ^ (b | ~d)) + blocks2[0] - 198630844;
                a = (a << 6 | a >>> 26) + b << 0;
                d += (b ^ (a | ~c)) + blocks2[7] + 1126891415;
                d = (d << 10 | d >>> 22) + a << 0;
                c += (a ^ (d | ~b)) + blocks2[14] - 1416354905;
                c = (c << 15 | c >>> 17) + d << 0;
                b += (d ^ (c | ~a)) + blocks2[5] - 57434055;
                b = (b << 21 | b >>> 11) + c << 0;
                a += (c ^ (b | ~d)) + blocks2[12] + 1700485571;
                a = (a << 6 | a >>> 26) + b << 0;
                d += (b ^ (a | ~c)) + blocks2[3] - 1894986606;
                d = (d << 10 | d >>> 22) + a << 0;
                c += (a ^ (d | ~b)) + blocks2[10] - 1051523;
                c = (c << 15 | c >>> 17) + d << 0;
                b += (d ^ (c | ~a)) + blocks2[1] - 2054922799;
                b = (b << 21 | b >>> 11) + c << 0;
                a += (c ^ (b | ~d)) + blocks2[8] + 1873313359;
                a = (a << 6 | a >>> 26) + b << 0;
                d += (b ^ (a | ~c)) + blocks2[15] - 30611744;
                d = (d << 10 | d >>> 22) + a << 0;
                c += (a ^ (d | ~b)) + blocks2[6] - 1560198380;
                c = (c << 15 | c >>> 17) + d << 0;
                b += (d ^ (c | ~a)) + blocks2[13] + 1309151649;
                b = (b << 21 | b >>> 11) + c << 0;
                a += (c ^ (b | ~d)) + blocks2[4] - 145523070;
                a = (a << 6 | a >>> 26) + b << 0;
                d += (b ^ (a | ~c)) + blocks2[11] - 1120210379;
                d = (d << 10 | d >>> 22) + a << 0;
                c += (a ^ (d | ~b)) + blocks2[2] + 718787259;
                c = (c << 15 | c >>> 17) + d << 0;
                b += (d ^ (c | ~a)) + blocks2[9] - 343485551;
                b = (b << 21 | b >>> 11) + c << 0;
                if (this.first) {
                  this.h0 = a + 1732584193 << 0;
                  this.h1 = b - 271733879 << 0;
                  this.h2 = c - 1732584194 << 0;
                  this.h3 = d + 271733878 << 0;
                  this.first = false;
                } else {
                  this.h0 = this.h0 + a << 0;
                  this.h1 = this.h1 + b << 0;
                  this.h2 = this.h2 + c << 0;
                  this.h3 = this.h3 + d << 0;
                }
              };
              Md5.prototype.hex = function() {
                this.finalize();
                var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
                return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
              };
              Md5.prototype.toString = Md5.prototype.hex;
              Md5.prototype.digest = function(format) {
                if (format === "hex")
                  return this.hex();
                this.finalize();
                var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
                var res = [h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >> 24 & 255];
                return res;
              };
              Md5.prototype.array = Md5.prototype.digest;
              Md5.prototype.arrayBuffer = function() {
                this.finalize();
                var buffer2 = new ArrayBuffer(16);
                var blocks2 = new Uint32Array(buffer2);
                blocks2[0] = this.h0;
                blocks2[1] = this.h1;
                blocks2[2] = this.h2;
                blocks2[3] = this.h3;
                return buffer2;
              };
              Md5.prototype.buffer = Md5.prototype.arrayBuffer;
              Md5.prototype.base64 = function() {
                var v1, v2, v3, base64Str = "", bytes = this.array();
                for (var i = 0; i < 15; ) {
                  v1 = bytes[i++];
                  v2 = bytes[i++];
                  v3 = bytes[i++];
                  base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
                }
                v1 = bytes[i];
                base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
                return base64Str;
              };
              var exports = createMethod();
              if (COMMON_JS) {
                module.exports = exports;
              } else {
                root.md5 = exports;
                if (AMD) {
                  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return exports;
                  }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                }
              }
            })();
          }).call(this, __webpack_require__("./node_modules/process/browser.js"), __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/webpack/buildin/module.js")(module));
        },
        "./lib/request.js": function(module2, exports2, __webpack_require__2) {
          var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
          var stringifyPrimitive = function stringifyPrimitive2(v) {
            switch (_typeof2(v)) {
              case "string":
                return v;
              case "boolean":
                return v ? "true" : "false";
              case "number":
                return isFinite(v) ? v : "";
              default:
                return "";
            }
          };
          var queryStringify = function queryStringify2(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
              obj = void 0;
            }
            if (_typeof2(obj) === "object") {
              return Object.keys(obj).map(function(k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                if (Array.isArray(obj[k])) {
                  return obj[k].map(function(v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                  }).join(sep);
                } else {
                  return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                }
              }).filter(Boolean).join(sep);
            }
            if (!name)
              return "";
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
          };
          var xhrRes = function xhrRes2(err, xhr, body) {
            var headers = {};
            xhr.getAllResponseHeaders().trim().split("\n").forEach(function(item) {
              if (item) {
                var index = item.indexOf(":");
                var key = item.substr(0, index).trim().toLowerCase();
                var val = item.substr(index + 1).trim();
                headers[key] = val;
              }
            });
            return {
              error: err,
              statusCode: xhr.status,
              statusMessage: xhr.statusText,
              headers,
              body
            };
          };
          var xhrBody = function xhrBody2(xhr, dataType) {
            return !dataType && dataType === "text" ? xhr.responseText : xhr.response;
          };
          var request = function request2(opt, callback) {
            var method2 = (opt.method || "GET").toUpperCase();
            var url = opt.url;
            if (opt.qs) {
              var qsStr = queryStringify(opt.qs);
              if (qsStr) {
                url += (url.indexOf("?") === -1 ? "?" : "&") + qsStr;
              }
            }
            var xhr = new XMLHttpRequest();
            xhr.open(method2, url, true);
            xhr.responseType = opt.dataType || "text";
            if (opt.xhrFields) {
              for (var xhrField in opt.xhrFields) {
                xhr[xhrField] = opt.xhrFields[xhrField];
              }
            }
            var headers = opt.headers;
            if (headers) {
              for (var key in headers) {
                if (headers.hasOwnProperty(key) && key.toLowerCase() !== "content-length" && key.toLowerCase() !== "user-agent" && key.toLowerCase() !== "origin" && key.toLowerCase() !== "host") {
                  xhr.setRequestHeader(key, headers[key]);
                }
              }
            }
            if (opt.onProgress && xhr.upload)
              xhr.upload.onprogress = opt.onProgress;
            if (opt.onDownloadProgress)
              xhr.onprogress = opt.onDownloadProgress;
            if (opt.timeout)
              xhr.timeout = opt.timeout;
            xhr.ontimeout = function(event) {
              var error = new Error("timeout");
              callback(xhrRes(error, xhr));
            };
            xhr.onload = function() {
              callback(xhrRes(null, xhr, xhrBody(xhr, opt.dataType)));
            };
            xhr.onerror = function(err) {
              var body = xhrBody(xhr, opt.dataType);
              if (body) {
                callback(xhrRes(null, xhr, body));
              } else {
                var error = xhr.statusText;
                if (!error && xhr.status === 0)
                  error = new Error("CORS blocked or network error");
                callback(xhrRes(error, xhr, body));
              }
            };
            xhr.send(opt.body || "");
            return xhr;
          };
          module2.exports = request;
        },
        "./lib/xml2json.js": function(module2, exports2, __webpack_require__2) {
          var DOMParser = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/index.js").DOMParser;
          var xmlToJSON = function() {
            this.version = "1.3.5";
            var options = {
              mergeCDATA: true,
              normalize: true,
              stripElemPrefix: true
            };
            var prefixMatch = new RegExp(/(?!xmlns)^.*:/);
            var trimMatch = new RegExp(/^\s+|\s+$/g);
            this.grokType = function(sValue) {
              if (/^\s*$/.test(sValue)) {
                return null;
              }
              if (/^(?:true|false)$/i.test(sValue)) {
                return sValue.toLowerCase() === "true";
              }
              if (isFinite(sValue)) {
                return parseFloat(sValue);
              }
              return sValue;
            };
            this.parseString = function(xmlString, opt) {
              if (xmlString) {
                var xml = this.stringToXML(xmlString);
                if (xml.getElementsByTagName("parsererror").length) {
                  return null;
                } else {
                  return this.parseXML(xml, opt);
                }
              } else {
                return null;
              }
            };
            this.parseXML = function(oXMLParent, opt) {
              for (var key in opt) {
                options[key] = opt[key];
              }
              var vResult = {}, nLength = 0, sCollectedTxt = "";
              var childNum = oXMLParent.childNodes.length;
              if (childNum) {
                for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
                  oNode = oXMLParent.childNodes.item(nItem);
                  if (oNode.nodeType === 4) {
                    if (options.mergeCDATA) {
                      sCollectedTxt += oNode.nodeValue;
                    }
                  } else if (oNode.nodeType === 3) {
                    sCollectedTxt += oNode.nodeValue;
                  } else if (oNode.nodeType === 1) {
                    if (nLength === 0) {
                      vResult = {};
                    }
                    if (options.stripElemPrefix) {
                      sProp = oNode.nodeName.replace(prefixMatch, "");
                    } else {
                      sProp = oNode.nodeName;
                    }
                    vContent = xmlToJSON.parseXML(oNode);
                    if (vResult.hasOwnProperty(sProp)) {
                      if (vResult[sProp].constructor !== Array) {
                        vResult[sProp] = [vResult[sProp]];
                      }
                      vResult[sProp].push(vContent);
                    } else {
                      vResult[sProp] = vContent;
                      nLength++;
                    }
                  }
                }
              }
              if (!Object.keys(vResult).length) {
                vResult = sCollectedTxt || "";
              }
              return vResult;
            };
            this.xmlToString = function(xmlDoc) {
              try {
                var xmlString = xmlDoc.xml ? xmlDoc.xml : new XMLSerializer().serializeToString(xmlDoc);
                return xmlString;
              } catch (err) {
                return null;
              }
            };
            this.stringToXML = function(xmlString) {
              try {
                var xmlDoc = null;
                if (window.DOMParser) {
                  var parser = new DOMParser();
                  xmlDoc = parser.parseFromString(xmlString, "text/xml");
                  return xmlDoc;
                } else {
                  xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                  xmlDoc.async = false;
                  xmlDoc.loadXML(xmlString);
                  return xmlDoc;
                }
              } catch (e) {
                return null;
              }
            };
            return this;
          }.call({});
          var xml2json = function xml2json2(xmlString) {
            return xmlToJSON.parseString(xmlString);
          };
          module2.exports = xml2json;
        },
        "./node_modules/@babel/runtime/helpers/classCallCheck.js": function(module2, exports2) {
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
        },
        "./node_modules/@babel/runtime/helpers/createClass.js": function(module2, exports2) {
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            Object.defineProperty(Constructor, "prototype", {
              writable: false
            });
            return Constructor;
          }
          module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
        },
        "./node_modules/@babel/runtime/helpers/typeof.js": function(module2, exports2) {
          function _typeof2(obj) {
            "@babel/helpers - typeof";
            return module2.exports = _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
              return typeof obj2;
            } : function(obj2) {
              return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(obj);
          }
          module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
        },
        "./node_modules/@xmldom/xmldom/lib/conventions.js": function(module2, exports2, __webpack_require__2) {
          "use strict";
          function find(list, predicate, ac) {
            if (ac === void 0) {
              ac = Array.prototype;
            }
            if (list && typeof ac.find === "function") {
              return ac.find.call(list, predicate);
            }
            for (var i = 0; i < list.length; i++) {
              if (Object.prototype.hasOwnProperty.call(list, i)) {
                var item = list[i];
                if (predicate.call(void 0, item, i, list)) {
                  return item;
                }
              }
            }
          }
          function freeze(object, oc) {
            if (oc === void 0) {
              oc = Object;
            }
            return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
          }
          function assign(target, source) {
            if (target === null || typeof target !== "object") {
              throw new TypeError("target is not an object");
            }
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
            return target;
          }
          var MIME_TYPE = freeze({
            HTML: "text/html",
            isHTML: function(value) {
              return value === MIME_TYPE.HTML;
            },
            XML_APPLICATION: "application/xml",
            XML_TEXT: "text/xml",
            XML_XHTML_APPLICATION: "application/xhtml+xml",
            XML_SVG_IMAGE: "image/svg+xml"
          });
          var NAMESPACE = freeze({
            HTML: "http://www.w3.org/1999/xhtml",
            isHTML: function(uri) {
              return uri === NAMESPACE.HTML;
            },
            SVG: "http://www.w3.org/2000/svg",
            XML: "http://www.w3.org/XML/1998/namespace",
            XMLNS: "http://www.w3.org/2000/xmlns/"
          });
          exports2.assign = assign;
          exports2.find = find;
          exports2.freeze = freeze;
          exports2.MIME_TYPE = MIME_TYPE;
          exports2.NAMESPACE = NAMESPACE;
        },
        "./node_modules/@xmldom/xmldom/lib/dom-parser.js": function(module2, exports2, __webpack_require__2) {
          var conventions = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/conventions.js");
          var dom = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/dom.js");
          var entities = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/entities.js");
          var sax = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/sax.js");
          var DOMImplementation = dom.DOMImplementation;
          var NAMESPACE = conventions.NAMESPACE;
          var ParseError = sax.ParseError;
          var XMLReader = sax.XMLReader;
          function normalizeLineEndings(input) {
            return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
          }
          function DOMParser(options) {
            this.options = options || { locator: {} };
          }
          DOMParser.prototype.parseFromString = function(source, mimeType) {
            var options = this.options;
            var sax2 = new XMLReader();
            var domBuilder = options.domBuilder || new DOMHandler();
            var errorHandler = options.errorHandler;
            var locator = options.locator;
            var defaultNSMap = options.xmlns || {};
            var isHTML = /\/x?html?$/.test(mimeType);
            var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
            if (locator) {
              domBuilder.setDocumentLocator(locator);
            }
            sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
            sax2.domBuilder = options.domBuilder || domBuilder;
            if (isHTML) {
              defaultNSMap[""] = NAMESPACE.HTML;
            }
            defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
            var normalize = options.normalizeLineEndings || normalizeLineEndings;
            if (source && typeof source === "string") {
              sax2.parse(normalize(source), defaultNSMap, entityMap);
            } else {
              sax2.errorHandler.error("invalid doc source");
            }
            return domBuilder.doc;
          };
          function buildErrorHandler(errorImpl, domBuilder, locator) {
            if (!errorImpl) {
              if (domBuilder instanceof DOMHandler) {
                return domBuilder;
              }
              errorImpl = domBuilder;
            }
            var errorHandler = {};
            var isCallback = errorImpl instanceof Function;
            locator = locator || {};
            function build(key) {
              var fn = errorImpl[key];
              if (!fn && isCallback) {
                fn = errorImpl.length == 2 ? function(msg) {
                  errorImpl(key, msg);
                } : errorImpl;
              }
              errorHandler[key] = fn && function(msg) {
                fn("[xmldom " + key + "]	" + msg + _locator(locator));
              } || function() {
              };
            }
            build("warning");
            build("error");
            build("fatalError");
            return errorHandler;
          }
          function DOMHandler() {
            this.cdata = false;
          }
          function position(locator, node) {
            node.lineNumber = locator.lineNumber;
            node.columnNumber = locator.columnNumber;
          }
          DOMHandler.prototype = {
            startDocument: function() {
              this.doc = new DOMImplementation().createDocument(null, null, null);
              if (this.locator) {
                this.doc.documentURI = this.locator.systemId;
              }
            },
            startElement: function(namespaceURI, localName, qName, attrs) {
              var doc = this.doc;
              var el = doc.createElementNS(namespaceURI, qName || localName);
              var len = attrs.length;
              appendElement(this, el);
              this.currentElement = el;
              this.locator && position(this.locator, el);
              for (var i = 0; i < len; i++) {
                var namespaceURI = attrs.getURI(i);
                var value = attrs.getValue(i);
                var qName = attrs.getQName(i);
                var attr = doc.createAttributeNS(namespaceURI, qName);
                this.locator && position(attrs.getLocator(i), attr);
                attr.value = attr.nodeValue = value;
                el.setAttributeNode(attr);
              }
            },
            endElement: function(namespaceURI, localName, qName) {
              var current = this.currentElement;
              var tagName = current.tagName;
              this.currentElement = current.parentNode;
            },
            startPrefixMapping: function(prefix, uri) {
            },
            endPrefixMapping: function(prefix) {
            },
            processingInstruction: function(target, data) {
              var ins = this.doc.createProcessingInstruction(target, data);
              this.locator && position(this.locator, ins);
              appendElement(this, ins);
            },
            ignorableWhitespace: function(ch, start, length) {
            },
            characters: function(chars, start, length) {
              chars = _toString.apply(this, arguments);
              if (chars) {
                if (this.cdata) {
                  var charNode = this.doc.createCDATASection(chars);
                } else {
                  var charNode = this.doc.createTextNode(chars);
                }
                if (this.currentElement) {
                  this.currentElement.appendChild(charNode);
                } else if (/^\s*$/.test(chars)) {
                  this.doc.appendChild(charNode);
                }
                this.locator && position(this.locator, charNode);
              }
            },
            skippedEntity: function(name) {
            },
            endDocument: function() {
              this.doc.normalize();
            },
            setDocumentLocator: function(locator) {
              if (this.locator = locator) {
                locator.lineNumber = 0;
              }
            },
            comment: function(chars, start, length) {
              chars = _toString.apply(this, arguments);
              var comm = this.doc.createComment(chars);
              this.locator && position(this.locator, comm);
              appendElement(this, comm);
            },
            startCDATA: function() {
              this.cdata = true;
            },
            endCDATA: function() {
              this.cdata = false;
            },
            startDTD: function(name, publicId, systemId) {
              var impl = this.doc.implementation;
              if (impl && impl.createDocumentType) {
                var dt = impl.createDocumentType(name, publicId, systemId);
                this.locator && position(this.locator, dt);
                appendElement(this, dt);
                this.doc.doctype = dt;
              }
            },
            warning: function(error) {
              console.warn("[xmldom warning]	" + error, _locator(this.locator));
            },
            error: function(error) {
              console.error("[xmldom error]	" + error, _locator(this.locator));
            },
            fatalError: function(error) {
              throw new ParseError(error, this.locator);
            }
          };
          function _locator(l) {
            if (l) {
              return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
            }
          }
          function _toString(chars, start, length) {
            if (typeof chars == "string") {
              return chars.substr(start, length);
            } else {
              if (chars.length >= start + length || start) {
                return new java.lang.String(chars, start, length) + "";
              }
              return chars;
            }
          }
          "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
            DOMHandler.prototype[key] = function() {
              return null;
            };
          });
          function appendElement(hander, node) {
            if (!hander.currentElement) {
              hander.doc.appendChild(node);
            } else {
              hander.currentElement.appendChild(node);
            }
          }
          exports2.__DOMHandler = DOMHandler;
          exports2.normalizeLineEndings = normalizeLineEndings;
          exports2.DOMParser = DOMParser;
        },
        "./node_modules/@xmldom/xmldom/lib/dom.js": function(module2, exports2, __webpack_require__2) {
          var conventions = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/conventions.js");
          var find = conventions.find;
          var NAMESPACE = conventions.NAMESPACE;
          function notEmptyString(input) {
            return input !== "";
          }
          function splitOnASCIIWhitespace(input) {
            return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
          }
          function orderedSetReducer(current, element) {
            if (!current.hasOwnProperty(element)) {
              current[element] = true;
            }
            return current;
          }
          function toOrderedSet(input) {
            if (!input)
              return [];
            var list = splitOnASCIIWhitespace(input);
            return Object.keys(list.reduce(orderedSetReducer, {}));
          }
          function arrayIncludes(list) {
            return function(element) {
              return list && list.indexOf(element) !== -1;
            };
          }
          function copy(src, dest) {
            for (var p in src) {
              if (Object.prototype.hasOwnProperty.call(src, p)) {
                dest[p] = src[p];
              }
            }
          }
          function _extends(Class, Super) {
            var pt = Class.prototype;
            if (!(pt instanceof Super)) {
              let t2 = function() {
              };
              var t = t2;
              ;
              t2.prototype = Super.prototype;
              t2 = new t2();
              copy(pt, t2);
              Class.prototype = pt = t2;
            }
            if (pt.constructor != Class) {
              if (typeof Class != "function") {
                console.error("unknown Class:" + Class);
              }
              pt.constructor = Class;
            }
          }
          var NodeType = {};
          var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
          var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
          var TEXT_NODE = NodeType.TEXT_NODE = 3;
          var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
          var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
          var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
          var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
          var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
          var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
          var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
          var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
          var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
          var ExceptionCode = {};
          var ExceptionMessage = {};
          var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
          var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
          var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
          var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
          var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
          var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
          var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
          var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
          var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
          var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
          var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
          var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
          var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
          var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
          var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
          function DOMException(code, message) {
            if (message instanceof Error) {
              var error = message;
            } else {
              error = this;
              Error.call(this, ExceptionMessage[code]);
              this.message = ExceptionMessage[code];
              if (Error.captureStackTrace)
                Error.captureStackTrace(this, DOMException);
            }
            error.code = code;
            if (message)
              this.message = this.message + ": " + message;
            return error;
          }
          ;
          DOMException.prototype = Error.prototype;
          copy(ExceptionCode, DOMException);
          function NodeList() {
          }
          ;
          NodeList.prototype = {
            length: 0,
            item: function(index) {
              return this[index] || null;
            },
            toString: function(isHTML, nodeFilter) {
              for (var buf = [], i = 0; i < this.length; i++) {
                serializeToString(this[i], buf, isHTML, nodeFilter);
              }
              return buf.join("");
            },
            filter: function(predicate) {
              return Array.prototype.filter.call(this, predicate);
            },
            indexOf: function(item) {
              return Array.prototype.indexOf.call(this, item);
            }
          };
          function LiveNodeList(node, refresh) {
            this._node = node;
            this._refresh = refresh;
            _updateLiveList(this);
          }
          function _updateLiveList(list) {
            var inc = list._node._inc || list._node.ownerDocument._inc;
            if (list._inc != inc) {
              var ls = list._refresh(list._node);
              __set__(list, "length", ls.length);
              copy(ls, list);
              list._inc = inc;
            }
          }
          LiveNodeList.prototype.item = function(i) {
            _updateLiveList(this);
            return this[i];
          };
          _extends(LiveNodeList, NodeList);
          function NamedNodeMap() {
          }
          ;
          function _findNodeIndex(list, node) {
            var i = list.length;
            while (i--) {
              if (list[i] === node) {
                return i;
              }
            }
          }
          function _addNamedNode(el, list, newAttr, oldAttr) {
            if (oldAttr) {
              list[_findNodeIndex(list, oldAttr)] = newAttr;
            } else {
              list[list.length++] = newAttr;
            }
            if (el) {
              newAttr.ownerElement = el;
              var doc = el.ownerDocument;
              if (doc) {
                oldAttr && _onRemoveAttribute(doc, el, oldAttr);
                _onAddAttribute(doc, el, newAttr);
              }
            }
          }
          function _removeNamedNode(el, list, attr) {
            var i = _findNodeIndex(list, attr);
            if (i >= 0) {
              var lastIndex = list.length - 1;
              while (i < lastIndex) {
                list[i] = list[++i];
              }
              list.length = lastIndex;
              if (el) {
                var doc = el.ownerDocument;
                if (doc) {
                  _onRemoveAttribute(doc, el, attr);
                  attr.ownerElement = null;
                }
              }
            } else {
              throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
            }
          }
          NamedNodeMap.prototype = {
            length: 0,
            item: NodeList.prototype.item,
            getNamedItem: function(key) {
              var i = this.length;
              while (i--) {
                var attr = this[i];
                if (attr.nodeName == key) {
                  return attr;
                }
              }
            },
            setNamedItem: function(attr) {
              var el = attr.ownerElement;
              if (el && el != this._ownerElement) {
                throw new DOMException(INUSE_ATTRIBUTE_ERR);
              }
              var oldAttr = this.getNamedItem(attr.nodeName);
              _addNamedNode(this._ownerElement, this, attr, oldAttr);
              return oldAttr;
            },
            setNamedItemNS: function(attr) {
              var el = attr.ownerElement, oldAttr;
              if (el && el != this._ownerElement) {
                throw new DOMException(INUSE_ATTRIBUTE_ERR);
              }
              oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
              _addNamedNode(this._ownerElement, this, attr, oldAttr);
              return oldAttr;
            },
            removeNamedItem: function(key) {
              var attr = this.getNamedItem(key);
              _removeNamedNode(this._ownerElement, this, attr);
              return attr;
            },
            removeNamedItemNS: function(namespaceURI, localName) {
              var attr = this.getNamedItemNS(namespaceURI, localName);
              _removeNamedNode(this._ownerElement, this, attr);
              return attr;
            },
            getNamedItemNS: function(namespaceURI, localName) {
              var i = this.length;
              while (i--) {
                var node = this[i];
                if (node.localName == localName && node.namespaceURI == namespaceURI) {
                  return node;
                }
              }
              return null;
            }
          };
          function DOMImplementation() {
          }
          DOMImplementation.prototype = {
            hasFeature: function(feature, version) {
              return true;
            },
            createDocument: function(namespaceURI, qualifiedName, doctype) {
              var doc = new Document();
              doc.implementation = this;
              doc.childNodes = new NodeList();
              doc.doctype = doctype || null;
              if (doctype) {
                doc.appendChild(doctype);
              }
              if (qualifiedName) {
                var root2 = doc.createElementNS(namespaceURI, qualifiedName);
                doc.appendChild(root2);
              }
              return doc;
            },
            createDocumentType: function(qualifiedName, publicId, systemId) {
              var node = new DocumentType();
              node.name = qualifiedName;
              node.nodeName = qualifiedName;
              node.publicId = publicId || "";
              node.systemId = systemId || "";
              return node;
            }
          };
          function Node() {
          }
          ;
          Node.prototype = {
            firstChild: null,
            lastChild: null,
            previousSibling: null,
            nextSibling: null,
            attributes: null,
            parentNode: null,
            childNodes: null,
            ownerDocument: null,
            nodeValue: null,
            namespaceURI: null,
            prefix: null,
            localName: null,
            insertBefore: function(newChild, refChild) {
              return _insertBefore(this, newChild, refChild);
            },
            replaceChild: function(newChild, oldChild) {
              _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
              if (oldChild) {
                this.removeChild(oldChild);
              }
            },
            removeChild: function(oldChild) {
              return _removeChild(this, oldChild);
            },
            appendChild: function(newChild) {
              return this.insertBefore(newChild, null);
            },
            hasChildNodes: function() {
              return this.firstChild != null;
            },
            cloneNode: function(deep) {
              return cloneNode(this.ownerDocument || this, this, deep);
            },
            normalize: function() {
              var child = this.firstChild;
              while (child) {
                var next = child.nextSibling;
                if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
                  this.removeChild(next);
                  child.appendData(next.data);
                } else {
                  child.normalize();
                  child = next;
                }
              }
            },
            isSupported: function(feature, version) {
              return this.ownerDocument.implementation.hasFeature(feature, version);
            },
            hasAttributes: function() {
              return this.attributes.length > 0;
            },
            lookupPrefix: function(namespaceURI) {
              var el = this;
              while (el) {
                var map = el._nsMap;
                if (map) {
                  for (var n in map) {
                    if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                      return n;
                    }
                  }
                }
                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
              }
              return null;
            },
            lookupNamespaceURI: function(prefix) {
              var el = this;
              while (el) {
                var map = el._nsMap;
                if (map) {
                  if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                    return map[prefix];
                  }
                }
                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
              }
              return null;
            },
            isDefaultNamespace: function(namespaceURI) {
              var prefix = this.lookupPrefix(namespaceURI);
              return prefix == null;
            }
          };
          function _xmlEncoder(c) {
            return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
          }
          copy(NodeType, Node);
          copy(NodeType, Node.prototype);
          function _visitNode(node, callback) {
            if (callback(node)) {
              return true;
            }
            if (node = node.firstChild) {
              do {
                if (_visitNode(node, callback)) {
                  return true;
                }
              } while (node = node.nextSibling);
            }
          }
          function Document() {
            this.ownerDocument = this;
          }
          function _onAddAttribute(doc, el, newAttr) {
            doc && doc._inc++;
            var ns = newAttr.namespaceURI;
            if (ns === NAMESPACE.XMLNS) {
              el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
            }
          }
          function _onRemoveAttribute(doc, el, newAttr, remove) {
            doc && doc._inc++;
            var ns = newAttr.namespaceURI;
            if (ns === NAMESPACE.XMLNS) {
              delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
            }
          }
          function _onUpdateChild(doc, el, newChild) {
            if (doc && doc._inc) {
              doc._inc++;
              var cs = el.childNodes;
              if (newChild) {
                cs[cs.length++] = newChild;
              } else {
                var child = el.firstChild;
                var i = 0;
                while (child) {
                  cs[i++] = child;
                  child = child.nextSibling;
                }
                cs.length = i;
                delete cs[cs.length];
              }
            }
          }
          function _removeChild(parentNode, child) {
            var previous = child.previousSibling;
            var next = child.nextSibling;
            if (previous) {
              previous.nextSibling = next;
            } else {
              parentNode.firstChild = next;
            }
            if (next) {
              next.previousSibling = previous;
            } else {
              parentNode.lastChild = previous;
            }
            child.parentNode = null;
            child.previousSibling = null;
            child.nextSibling = null;
            _onUpdateChild(parentNode.ownerDocument, parentNode);
            return child;
          }
          function hasValidParentNodeType(node) {
            return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
          }
          function hasInsertableNodeType(node) {
            return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
          }
          function isDocTypeNode(node) {
            return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
          }
          function isElementNode(node) {
            return node && node.nodeType === Node.ELEMENT_NODE;
          }
          function isTextNode(node) {
            return node && node.nodeType === Node.TEXT_NODE;
          }
          function isElementInsertionPossible(doc, child) {
            var parentChildNodes = doc.childNodes || [];
            if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
              return false;
            }
            var docTypeNode = find(parentChildNodes, isDocTypeNode);
            return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
          }
          function isElementReplacementPossible(doc, child) {
            var parentChildNodes = doc.childNodes || [];
            function hasElementChildThatIsNotChild(node) {
              return isElementNode(node) && node !== child;
            }
            if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
              return false;
            }
            var docTypeNode = find(parentChildNodes, isDocTypeNode);
            return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
          }
          function assertPreInsertionValidity1to5(parent, node, child) {
            if (!hasValidParentNodeType(parent)) {
              throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
            }
            if (child && child.parentNode !== parent) {
              throw new DOMException(NOT_FOUND_ERR, "child not in parent");
            }
            if (!hasInsertableNodeType(node) || isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {
              throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
            }
          }
          function assertPreInsertionValidityInDocument(parent, node, child) {
            var parentChildNodes = parent.childNodes || [];
            var nodeChildNodes = node.childNodes || [];
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              var nodeChildElements = nodeChildNodes.filter(isElementNode);
              if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
              }
              if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
              }
            }
            if (isElementNode(node)) {
              if (!isElementInsertionPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
              }
            }
            if (isDocTypeNode(node)) {
              if (find(parentChildNodes, isDocTypeNode)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
              }
              var parentElementChild = find(parentChildNodes, isElementNode);
              if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
              }
              if (!child && parentElementChild) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
              }
            }
          }
          function assertPreReplacementValidityInDocument(parent, node, child) {
            var parentChildNodes = parent.childNodes || [];
            var nodeChildNodes = node.childNodes || [];
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              var nodeChildElements = nodeChildNodes.filter(isElementNode);
              if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
              }
              if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
              }
            }
            if (isElementNode(node)) {
              if (!isElementReplacementPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
              }
            }
            if (isDocTypeNode(node)) {
              let hasDoctypeChildThatIsNotChild2 = function(node2) {
                return isDocTypeNode(node2) && node2 !== child;
              };
              var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
              if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
              }
              var parentElementChild = find(parentChildNodes, isElementNode);
              if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
              }
            }
          }
          function _insertBefore(parent, node, child, _inDocumentAssertion) {
            assertPreInsertionValidity1to5(parent, node, child);
            if (parent.nodeType === Node.DOCUMENT_NODE) {
              (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
            }
            var cp = node.parentNode;
            if (cp) {
              cp.removeChild(node);
            }
            if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
              var newFirst = node.firstChild;
              if (newFirst == null) {
                return node;
              }
              var newLast = node.lastChild;
            } else {
              newFirst = newLast = node;
            }
            var pre = child ? child.previousSibling : parent.lastChild;
            newFirst.previousSibling = pre;
            newLast.nextSibling = child;
            if (pre) {
              pre.nextSibling = newFirst;
            } else {
              parent.firstChild = newFirst;
            }
            if (child == null) {
              parent.lastChild = newLast;
            } else {
              child.previousSibling = newLast;
            }
            do {
              newFirst.parentNode = parent;
            } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
            _onUpdateChild(parent.ownerDocument || parent, parent);
            if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
              node.firstChild = node.lastChild = null;
            }
            return node;
          }
          function _appendSingleChild(parentNode, newChild) {
            if (newChild.parentNode) {
              newChild.parentNode.removeChild(newChild);
            }
            newChild.parentNode = parentNode;
            newChild.previousSibling = parentNode.lastChild;
            newChild.nextSibling = null;
            if (newChild.previousSibling) {
              newChild.previousSibling.nextSibling = newChild;
            } else {
              parentNode.firstChild = newChild;
            }
            parentNode.lastChild = newChild;
            _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
            return newChild;
          }
          Document.prototype = {
            nodeName: "#document",
            nodeType: DOCUMENT_NODE,
            doctype: null,
            documentElement: null,
            _inc: 1,
            insertBefore: function(newChild, refChild) {
              if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                var child = newChild.firstChild;
                while (child) {
                  var next = child.nextSibling;
                  this.insertBefore(child, refChild);
                  child = next;
                }
                return newChild;
              }
              _insertBefore(this, newChild, refChild);
              newChild.ownerDocument = this;
              if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
                this.documentElement = newChild;
              }
              return newChild;
            },
            removeChild: function(oldChild) {
              if (this.documentElement == oldChild) {
                this.documentElement = null;
              }
              return _removeChild(this, oldChild);
            },
            replaceChild: function(newChild, oldChild) {
              _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
              newChild.ownerDocument = this;
              if (oldChild) {
                this.removeChild(oldChild);
              }
              if (isElementNode(newChild)) {
                this.documentElement = newChild;
              }
            },
            importNode: function(importedNode, deep) {
              return importNode(this, importedNode, deep);
            },
            getElementById: function(id) {
              var rtv = null;
              _visitNode(this.documentElement, function(node) {
                if (node.nodeType == ELEMENT_NODE) {
                  if (node.getAttribute("id") == id) {
                    rtv = node;
                    return true;
                  }
                }
              });
              return rtv;
            },
            getElementsByClassName: function(classNames) {
              var classNamesSet = toOrderedSet(classNames);
              return new LiveNodeList(this, function(base) {
                var ls = [];
                if (classNamesSet.length > 0) {
                  _visitNode(base.documentElement, function(node) {
                    if (node !== base && node.nodeType === ELEMENT_NODE) {
                      var nodeClassNames = node.getAttribute("class");
                      if (nodeClassNames) {
                        var matches = classNames === nodeClassNames;
                        if (!matches) {
                          var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                          matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                        }
                        if (matches) {
                          ls.push(node);
                        }
                      }
                    }
                  });
                }
                return ls;
              });
            },
            createElement: function(tagName) {
              var node = new Element();
              node.ownerDocument = this;
              node.nodeName = tagName;
              node.tagName = tagName;
              node.localName = tagName;
              node.childNodes = new NodeList();
              var attrs = node.attributes = new NamedNodeMap();
              attrs._ownerElement = node;
              return node;
            },
            createDocumentFragment: function() {
              var node = new DocumentFragment();
              node.ownerDocument = this;
              node.childNodes = new NodeList();
              return node;
            },
            createTextNode: function(data) {
              var node = new Text();
              node.ownerDocument = this;
              node.appendData(data);
              return node;
            },
            createComment: function(data) {
              var node = new Comment();
              node.ownerDocument = this;
              node.appendData(data);
              return node;
            },
            createCDATASection: function(data) {
              var node = new CDATASection();
              node.ownerDocument = this;
              node.appendData(data);
              return node;
            },
            createProcessingInstruction: function(target, data) {
              var node = new ProcessingInstruction();
              node.ownerDocument = this;
              node.tagName = node.target = target;
              node.nodeValue = node.data = data;
              return node;
            },
            createAttribute: function(name) {
              var node = new Attr();
              node.ownerDocument = this;
              node.name = name;
              node.nodeName = name;
              node.localName = name;
              node.specified = true;
              return node;
            },
            createEntityReference: function(name) {
              var node = new EntityReference();
              node.ownerDocument = this;
              node.nodeName = name;
              return node;
            },
            createElementNS: function(namespaceURI, qualifiedName) {
              var node = new Element();
              var pl = qualifiedName.split(":");
              var attrs = node.attributes = new NamedNodeMap();
              node.childNodes = new NodeList();
              node.ownerDocument = this;
              node.nodeName = qualifiedName;
              node.tagName = qualifiedName;
              node.namespaceURI = namespaceURI;
              if (pl.length == 2) {
                node.prefix = pl[0];
                node.localName = pl[1];
              } else {
                node.localName = qualifiedName;
              }
              attrs._ownerElement = node;
              return node;
            },
            createAttributeNS: function(namespaceURI, qualifiedName) {
              var node = new Attr();
              var pl = qualifiedName.split(":");
              node.ownerDocument = this;
              node.nodeName = qualifiedName;
              node.name = qualifiedName;
              node.namespaceURI = namespaceURI;
              node.specified = true;
              if (pl.length == 2) {
                node.prefix = pl[0];
                node.localName = pl[1];
              } else {
                node.localName = qualifiedName;
              }
              return node;
            }
          };
          _extends(Document, Node);
          function Element() {
            this._nsMap = {};
          }
          ;
          Element.prototype = {
            nodeType: ELEMENT_NODE,
            hasAttribute: function(name) {
              return this.getAttributeNode(name) != null;
            },
            getAttribute: function(name) {
              var attr = this.getAttributeNode(name);
              return attr && attr.value || "";
            },
            getAttributeNode: function(name) {
              return this.attributes.getNamedItem(name);
            },
            setAttribute: function(name, value) {
              var attr = this.ownerDocument.createAttribute(name);
              attr.value = attr.nodeValue = "" + value;
              this.setAttributeNode(attr);
            },
            removeAttribute: function(name) {
              var attr = this.getAttributeNode(name);
              attr && this.removeAttributeNode(attr);
            },
            appendChild: function(newChild) {
              if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
                return this.insertBefore(newChild, null);
              } else {
                return _appendSingleChild(this, newChild);
              }
            },
            setAttributeNode: function(newAttr) {
              return this.attributes.setNamedItem(newAttr);
            },
            setAttributeNodeNS: function(newAttr) {
              return this.attributes.setNamedItemNS(newAttr);
            },
            removeAttributeNode: function(oldAttr) {
              return this.attributes.removeNamedItem(oldAttr.nodeName);
            },
            removeAttributeNS: function(namespaceURI, localName) {
              var old = this.getAttributeNodeNS(namespaceURI, localName);
              old && this.removeAttributeNode(old);
            },
            hasAttributeNS: function(namespaceURI, localName) {
              return this.getAttributeNodeNS(namespaceURI, localName) != null;
            },
            getAttributeNS: function(namespaceURI, localName) {
              var attr = this.getAttributeNodeNS(namespaceURI, localName);
              return attr && attr.value || "";
            },
            setAttributeNS: function(namespaceURI, qualifiedName, value) {
              var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
              attr.value = attr.nodeValue = "" + value;
              this.setAttributeNode(attr);
            },
            getAttributeNodeNS: function(namespaceURI, localName) {
              return this.attributes.getNamedItemNS(namespaceURI, localName);
            },
            getElementsByTagName: function(tagName) {
              return new LiveNodeList(this, function(base) {
                var ls = [];
                _visitNode(base, function(node) {
                  if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
                    ls.push(node);
                  }
                });
                return ls;
              });
            },
            getElementsByTagNameNS: function(namespaceURI, localName) {
              return new LiveNodeList(this, function(base) {
                var ls = [];
                _visitNode(base, function(node) {
                  if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                    ls.push(node);
                  }
                });
                return ls;
              });
            }
          };
          Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
          Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
          _extends(Element, Node);
          function Attr() {
          }
          ;
          Attr.prototype.nodeType = ATTRIBUTE_NODE;
          _extends(Attr, Node);
          function CharacterData() {
          }
          ;
          CharacterData.prototype = {
            data: "",
            substringData: function(offset, count) {
              return this.data.substring(offset, offset + count);
            },
            appendData: function(text) {
              text = this.data + text;
              this.nodeValue = this.data = text;
              this.length = text.length;
            },
            insertData: function(offset, text) {
              this.replaceData(offset, 0, text);
            },
            appendChild: function(newChild) {
              throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
            },
            deleteData: function(offset, count) {
              this.replaceData(offset, count, "");
            },
            replaceData: function(offset, count, text) {
              var start = this.data.substring(0, offset);
              var end = this.data.substring(offset + count);
              text = start + text + end;
              this.nodeValue = this.data = text;
              this.length = text.length;
            }
          };
          _extends(CharacterData, Node);
          function Text() {
          }
          ;
          Text.prototype = {
            nodeName: "#text",
            nodeType: TEXT_NODE,
            splitText: function(offset) {
              var text = this.data;
              var newText = text.substring(offset);
              text = text.substring(0, offset);
              this.data = this.nodeValue = text;
              this.length = text.length;
              var newNode = this.ownerDocument.createTextNode(newText);
              if (this.parentNode) {
                this.parentNode.insertBefore(newNode, this.nextSibling);
              }
              return newNode;
            }
          };
          _extends(Text, CharacterData);
          function Comment() {
          }
          ;
          Comment.prototype = {
            nodeName: "#comment",
            nodeType: COMMENT_NODE
          };
          _extends(Comment, CharacterData);
          function CDATASection() {
          }
          ;
          CDATASection.prototype = {
            nodeName: "#cdata-section",
            nodeType: CDATA_SECTION_NODE
          };
          _extends(CDATASection, CharacterData);
          function DocumentType() {
          }
          ;
          DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
          _extends(DocumentType, Node);
          function Notation() {
          }
          ;
          Notation.prototype.nodeType = NOTATION_NODE;
          _extends(Notation, Node);
          function Entity() {
          }
          ;
          Entity.prototype.nodeType = ENTITY_NODE;
          _extends(Entity, Node);
          function EntityReference() {
          }
          ;
          EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
          _extends(EntityReference, Node);
          function DocumentFragment() {
          }
          ;
          DocumentFragment.prototype.nodeName = "#document-fragment";
          DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
          _extends(DocumentFragment, Node);
          function ProcessingInstruction() {
          }
          ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
          _extends(ProcessingInstruction, Node);
          function XMLSerializer2() {
          }
          XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
            return nodeSerializeToString.call(node, isHtml, nodeFilter);
          };
          Node.prototype.toString = nodeSerializeToString;
          function nodeSerializeToString(isHtml, nodeFilter) {
            var buf = [];
            var refNode = this.nodeType == 9 && this.documentElement || this;
            var prefix = refNode.prefix;
            var uri = refNode.namespaceURI;
            if (uri && prefix == null) {
              var prefix = refNode.lookupPrefix(uri);
              if (prefix == null) {
                var visibleNamespaces = [
                  { namespace: uri, prefix: null }
                ];
              }
            }
            serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
            return buf.join("");
          }
          function needNamespaceDefine(node, isHTML, visibleNamespaces) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            if (!uri) {
              return false;
            }
            if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
              return false;
            }
            var i = visibleNamespaces.length;
            while (i--) {
              var ns = visibleNamespaces[i];
              if (ns.prefix === prefix) {
                return ns.namespace !== uri;
              }
            }
            return true;
          }
          function addSerializedAttribute(buf, qualifiedName, value) {
            buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
          }
          function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
            if (!visibleNamespaces) {
              visibleNamespaces = [];
            }
            if (nodeFilter) {
              node = nodeFilter(node);
              if (node) {
                if (typeof node == "string") {
                  buf.push(node);
                  return;
                }
              } else {
                return;
              }
            }
            switch (node.nodeType) {
              case ELEMENT_NODE:
                var attrs = node.attributes;
                var len = attrs.length;
                var child = node.firstChild;
                var nodeName = node.tagName;
                isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
                var prefixedNodeName = nodeName;
                if (!isHTML && !node.prefix && node.namespaceURI) {
                  var defaultNS;
                  for (var ai = 0; ai < attrs.length; ai++) {
                    if (attrs.item(ai).name === "xmlns") {
                      defaultNS = attrs.item(ai).value;
                      break;
                    }
                  }
                  if (!defaultNS) {
                    for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                      var namespace = visibleNamespaces[nsi];
                      if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                        defaultNS = namespace.namespace;
                        break;
                      }
                    }
                  }
                  if (defaultNS !== node.namespaceURI) {
                    for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                      var namespace = visibleNamespaces[nsi];
                      if (namespace.namespace === node.namespaceURI) {
                        if (namespace.prefix) {
                          prefixedNodeName = namespace.prefix + ":" + nodeName;
                        }
                        break;
                      }
                    }
                  }
                }
                buf.push("<", prefixedNodeName);
                for (var i = 0; i < len; i++) {
                  var attr = attrs.item(i);
                  if (attr.prefix == "xmlns") {
                    visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
                  } else if (attr.nodeName == "xmlns") {
                    visibleNamespaces.push({ prefix: "", namespace: attr.value });
                  }
                }
                for (var i = 0; i < len; i++) {
                  var attr = attrs.item(i);
                  if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                    var prefix = attr.prefix || "";
                    var uri = attr.namespaceURI;
                    addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                    visibleNamespaces.push({ prefix, namespace: uri });
                  }
                  serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
                }
                if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
                  var prefix = node.prefix || "";
                  var uri = node.namespaceURI;
                  addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                  visibleNamespaces.push({ prefix, namespace: uri });
                }
                if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
                  buf.push(">");
                  if (isHTML && /^script$/i.test(nodeName)) {
                    while (child) {
                      if (child.data) {
                        buf.push(child.data);
                      } else {
                        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                      }
                      child = child.nextSibling;
                    }
                  } else {
                    while (child) {
                      serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                      child = child.nextSibling;
                    }
                  }
                  buf.push("</", prefixedNodeName, ">");
                } else {
                  buf.push("/>");
                }
                return;
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                var child = node.firstChild;
                while (child) {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  child = child.nextSibling;
                }
                return;
              case ATTRIBUTE_NODE:
                return addSerializedAttribute(buf, node.name, node.value);
              case TEXT_NODE:
                return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
              case CDATA_SECTION_NODE:
                return buf.push("<![CDATA[", node.data, "]]>");
              case COMMENT_NODE:
                return buf.push("<!--", node.data, "-->");
              case DOCUMENT_TYPE_NODE:
                var pubid = node.publicId;
                var sysid = node.systemId;
                buf.push("<!DOCTYPE ", node.name);
                if (pubid) {
                  buf.push(" PUBLIC ", pubid);
                  if (sysid && sysid != ".") {
                    buf.push(" ", sysid);
                  }
                  buf.push(">");
                } else if (sysid && sysid != ".") {
                  buf.push(" SYSTEM ", sysid, ">");
                } else {
                  var sub = node.internalSubset;
                  if (sub) {
                    buf.push(" [", sub, "]");
                  }
                  buf.push(">");
                }
                return;
              case PROCESSING_INSTRUCTION_NODE:
                return buf.push("<?", node.target, " ", node.data, "?>");
              case ENTITY_REFERENCE_NODE:
                return buf.push("&", node.nodeName, ";");
              default:
                buf.push("??", node.nodeName);
            }
          }
          function importNode(doc, node, deep) {
            var node2;
            switch (node.nodeType) {
              case ELEMENT_NODE:
                node2 = node.cloneNode(false);
                node2.ownerDocument = doc;
              case DOCUMENT_FRAGMENT_NODE:
                break;
              case ATTRIBUTE_NODE:
                deep = true;
                break;
            }
            if (!node2) {
              node2 = node.cloneNode(false);
            }
            node2.ownerDocument = doc;
            node2.parentNode = null;
            if (deep) {
              var child = node.firstChild;
              while (child) {
                node2.appendChild(importNode(doc, child, deep));
                child = child.nextSibling;
              }
            }
            return node2;
          }
          function cloneNode(doc, node, deep) {
            var node2 = new node.constructor();
            for (var n in node) {
              if (Object.prototype.hasOwnProperty.call(node, n)) {
                var v = node[n];
                if (typeof v != "object") {
                  if (v != node2[n]) {
                    node2[n] = v;
                  }
                }
              }
            }
            if (node.childNodes) {
              node2.childNodes = new NodeList();
            }
            node2.ownerDocument = doc;
            switch (node2.nodeType) {
              case ELEMENT_NODE:
                var attrs = node.attributes;
                var attrs2 = node2.attributes = new NamedNodeMap();
                var len = attrs.length;
                attrs2._ownerElement = node2;
                for (var i = 0; i < len; i++) {
                  node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
                }
                break;
                ;
              case ATTRIBUTE_NODE:
                deep = true;
            }
            if (deep) {
              var child = node.firstChild;
              while (child) {
                node2.appendChild(cloneNode(doc, child, deep));
                child = child.nextSibling;
              }
            }
            return node2;
          }
          function __set__(object, key, value) {
            object[key] = value;
          }
          try {
            if (Object.defineProperty) {
              let getTextContent2 = function(node) {
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                  case DOCUMENT_FRAGMENT_NODE:
                    var buf = [];
                    node = node.firstChild;
                    while (node) {
                      if (node.nodeType !== 7 && node.nodeType !== 8) {
                        buf.push(getTextContent2(node));
                      }
                      node = node.nextSibling;
                    }
                    return buf.join("");
                  default:
                    return node.nodeValue;
                }
              };
              var getTextContent = getTextContent2;
              Object.defineProperty(LiveNodeList.prototype, "length", {
                get: function() {
                  _updateLiveList(this);
                  return this.$$length;
                }
              });
              Object.defineProperty(Node.prototype, "textContent", {
                get: function() {
                  return getTextContent2(this);
                },
                set: function(data) {
                  switch (this.nodeType) {
                    case ELEMENT_NODE:
                    case DOCUMENT_FRAGMENT_NODE:
                      while (this.firstChild) {
                        this.removeChild(this.firstChild);
                      }
                      if (data || String(data)) {
                        this.appendChild(this.ownerDocument.createTextNode(data));
                      }
                      break;
                    default:
                      this.data = data;
                      this.value = data;
                      this.nodeValue = data;
                  }
                }
              });
              __set__ = function(object, key, value) {
                object["$$" + key] = value;
              };
            }
          } catch (e) {
          }
          exports2.DocumentType = DocumentType;
          exports2.DOMException = DOMException;
          exports2.DOMImplementation = DOMImplementation;
          exports2.Element = Element;
          exports2.Node = Node;
          exports2.NodeList = NodeList;
          exports2.XMLSerializer = XMLSerializer2;
        },
        "./node_modules/@xmldom/xmldom/lib/entities.js": function(module2, exports2, __webpack_require__2) {
          var freeze = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/conventions.js").freeze;
          exports2.XML_ENTITIES = freeze({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
          exports2.HTML_ENTITIES = freeze({
            lt: "<",
            gt: ">",
            amp: "&",
            quot: '"',
            apos: "'",
            Agrave: "\xC0",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Atilde: "\xC3",
            Auml: "\xC4",
            Aring: "\xC5",
            AElig: "\xC6",
            Ccedil: "\xC7",
            Egrave: "\xC8",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Euml: "\xCB",
            Igrave: "\xCC",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Iuml: "\xCF",
            ETH: "\xD0",
            Ntilde: "\xD1",
            Ograve: "\xD2",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Otilde: "\xD5",
            Ouml: "\xD6",
            Oslash: "\xD8",
            Ugrave: "\xD9",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Uuml: "\xDC",
            Yacute: "\xDD",
            THORN: "\xDE",
            szlig: "\xDF",
            agrave: "\xE0",
            aacute: "\xE1",
            acirc: "\xE2",
            atilde: "\xE3",
            auml: "\xE4",
            aring: "\xE5",
            aelig: "\xE6",
            ccedil: "\xE7",
            egrave: "\xE8",
            eacute: "\xE9",
            ecirc: "\xEA",
            euml: "\xEB",
            igrave: "\xEC",
            iacute: "\xED",
            icirc: "\xEE",
            iuml: "\xEF",
            eth: "\xF0",
            ntilde: "\xF1",
            ograve: "\xF2",
            oacute: "\xF3",
            ocirc: "\xF4",
            otilde: "\xF5",
            ouml: "\xF6",
            oslash: "\xF8",
            ugrave: "\xF9",
            uacute: "\xFA",
            ucirc: "\xFB",
            uuml: "\xFC",
            yacute: "\xFD",
            thorn: "\xFE",
            yuml: "\xFF",
            nbsp: "\xA0",
            iexcl: "\xA1",
            cent: "\xA2",
            pound: "\xA3",
            curren: "\xA4",
            yen: "\xA5",
            brvbar: "\xA6",
            sect: "\xA7",
            uml: "\xA8",
            copy: "\xA9",
            ordf: "\xAA",
            laquo: "\xAB",
            not: "\xAC",
            shy: "\xAD\xAD",
            reg: "\xAE",
            macr: "\xAF",
            deg: "\xB0",
            plusmn: "\xB1",
            sup2: "\xB2",
            sup3: "\xB3",
            acute: "\xB4",
            micro: "\xB5",
            para: "\xB6",
            middot: "\xB7",
            cedil: "\xB8",
            sup1: "\xB9",
            ordm: "\xBA",
            raquo: "\xBB",
            frac14: "\xBC",
            frac12: "\xBD",
            frac34: "\xBE",
            iquest: "\xBF",
            times: "\xD7",
            divide: "\xF7",
            forall: "\u2200",
            part: "\u2202",
            exist: "\u2203",
            empty: "\u2205",
            nabla: "\u2207",
            isin: "\u2208",
            notin: "\u2209",
            ni: "\u220B",
            prod: "\u220F",
            sum: "\u2211",
            minus: "\u2212",
            lowast: "\u2217",
            radic: "\u221A",
            prop: "\u221D",
            infin: "\u221E",
            ang: "\u2220",
            and: "\u2227",
            or: "\u2228",
            cap: "\u2229",
            cup: "\u222A",
            "int": "\u222B",
            there4: "\u2234",
            sim: "\u223C",
            cong: "\u2245",
            asymp: "\u2248",
            ne: "\u2260",
            equiv: "\u2261",
            le: "\u2264",
            ge: "\u2265",
            sub: "\u2282",
            sup: "\u2283",
            nsub: "\u2284",
            sube: "\u2286",
            supe: "\u2287",
            oplus: "\u2295",
            otimes: "\u2297",
            perp: "\u22A5",
            sdot: "\u22C5",
            Alpha: "\u0391",
            Beta: "\u0392",
            Gamma: "\u0393",
            Delta: "\u0394",
            Epsilon: "\u0395",
            Zeta: "\u0396",
            Eta: "\u0397",
            Theta: "\u0398",
            Iota: "\u0399",
            Kappa: "\u039A",
            Lambda: "\u039B",
            Mu: "\u039C",
            Nu: "\u039D",
            Xi: "\u039E",
            Omicron: "\u039F",
            Pi: "\u03A0",
            Rho: "\u03A1",
            Sigma: "\u03A3",
            Tau: "\u03A4",
            Upsilon: "\u03A5",
            Phi: "\u03A6",
            Chi: "\u03A7",
            Psi: "\u03A8",
            Omega: "\u03A9",
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            iota: "\u03B9",
            kappa: "\u03BA",
            lambda: "\u03BB",
            mu: "\u03BC",
            nu: "\u03BD",
            xi: "\u03BE",
            omicron: "\u03BF",
            pi: "\u03C0",
            rho: "\u03C1",
            sigmaf: "\u03C2",
            sigma: "\u03C3",
            tau: "\u03C4",
            upsilon: "\u03C5",
            phi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            thetasym: "\u03D1",
            upsih: "\u03D2",
            piv: "\u03D6",
            OElig: "\u0152",
            oelig: "\u0153",
            Scaron: "\u0160",
            scaron: "\u0161",
            Yuml: "\u0178",
            fnof: "\u0192",
            circ: "\u02C6",
            tilde: "\u02DC",
            ensp: "\u2002",
            emsp: "\u2003",
            thinsp: "\u2009",
            zwnj: "\u200C",
            zwj: "\u200D",
            lrm: "\u200E",
            rlm: "\u200F",
            ndash: "\u2013",
            mdash: "\u2014",
            lsquo: "\u2018",
            rsquo: "\u2019",
            sbquo: "\u201A",
            ldquo: "\u201C",
            rdquo: "\u201D",
            bdquo: "\u201E",
            dagger: "\u2020",
            Dagger: "\u2021",
            bull: "\u2022",
            hellip: "\u2026",
            permil: "\u2030",
            prime: "\u2032",
            Prime: "\u2033",
            lsaquo: "\u2039",
            rsaquo: "\u203A",
            oline: "\u203E",
            euro: "\u20AC",
            trade: "\u2122",
            larr: "\u2190",
            uarr: "\u2191",
            rarr: "\u2192",
            darr: "\u2193",
            harr: "\u2194",
            crarr: "\u21B5",
            lceil: "\u2308",
            rceil: "\u2309",
            lfloor: "\u230A",
            rfloor: "\u230B",
            loz: "\u25CA",
            spades: "\u2660",
            clubs: "\u2663",
            hearts: "\u2665",
            diams: "\u2666"
          });
          exports2.entityMap = exports2.HTML_ENTITIES;
        },
        "./node_modules/@xmldom/xmldom/lib/index.js": function(module2, exports2, __webpack_require__2) {
          var dom = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/dom.js");
          exports2.DOMImplementation = dom.DOMImplementation;
          exports2.XMLSerializer = dom.XMLSerializer;
          exports2.DOMParser = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/dom-parser.js").DOMParser;
        },
        "./node_modules/@xmldom/xmldom/lib/sax.js": function(module2, exports2, __webpack_require__2) {
          var NAMESPACE = __webpack_require__2("./node_modules/@xmldom/xmldom/lib/conventions.js").NAMESPACE;
          var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
          var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
          var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
          var S_TAG = 0;
          var S_ATTR = 1;
          var S_ATTR_SPACE = 2;
          var S_EQ = 3;
          var S_ATTR_NOQUOT_VALUE = 4;
          var S_ATTR_END = 5;
          var S_TAG_SPACE = 6;
          var S_TAG_CLOSE = 7;
          function ParseError(message, locator) {
            this.message = message;
            this.locator = locator;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, ParseError);
          }
          ParseError.prototype = new Error();
          ParseError.prototype.name = ParseError.name;
          function XMLReader() {
          }
          XMLReader.prototype = {
            parse: function(source, defaultNSMap, entityMap) {
              var domBuilder = this.domBuilder;
              domBuilder.startDocument();
              _copy(defaultNSMap, defaultNSMap = {});
              parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
              domBuilder.endDocument();
            }
          };
          function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
            function fixedFromCharCode(code) {
              if (code > 65535) {
                code -= 65536;
                var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
                return String.fromCharCode(surrogate1, surrogate2);
              } else {
                return String.fromCharCode(code);
              }
            }
            function entityReplacer(a2) {
              var k = a2.slice(1, -1);
              if (Object.hasOwnProperty.call(entityMap, k)) {
                return entityMap[k];
              } else if (k.charAt(0) === "#") {
                return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
              } else {
                errorHandler.error("entity not found:" + a2);
                return a2;
              }
            }
            function appendText(end2) {
              if (end2 > start) {
                var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
                locator && position(start);
                domBuilder.characters(xt, 0, end2 - start);
                start = end2;
              }
            }
            function position(p, m) {
              while (p >= lineEnd && (m = linePattern.exec(source))) {
                lineStart = m.index;
                lineEnd = lineStart + m[0].length;
                locator.lineNumber++;
              }
              locator.columnNumber = p - lineStart + 1;
            }
            var lineStart = 0;
            var lineEnd = 0;
            var linePattern = /.*(?:\r\n?|\n)|.*$/g;
            var locator = domBuilder.locator;
            var parseStack = [{ currentNSMap: defaultNSMapCopy }];
            var closeMap = {};
            var start = 0;
            while (true) {
              try {
                var tagStart = source.indexOf("<", start);
                if (tagStart < 0) {
                  if (!source.substr(start).match(/^\s*$/)) {
                    var doc = domBuilder.doc;
                    var text = doc.createTextNode(source.substr(start));
                    doc.appendChild(text);
                    domBuilder.currentElement = text;
                  }
                  return;
                }
                if (tagStart > start) {
                  appendText(tagStart);
                }
                switch (source.charAt(tagStart + 1)) {
                  case "/":
                    var end = source.indexOf(">", tagStart + 3);
                    var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                    var config = parseStack.pop();
                    if (end < 0) {
                      tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                      errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                      end = tagStart + 1 + tagName.length;
                    } else if (tagName.match(/\s</)) {
                      tagName = tagName.replace(/[\s<].*/, "");
                      errorHandler.error("end tag name: " + tagName + " maybe not complete");
                      end = tagStart + 1 + tagName.length;
                    }
                    var localNSMap = config.localNSMap;
                    var endMatch = config.tagName == tagName;
                    var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                    if (endIgnoreCaseMach) {
                      domBuilder.endElement(config.uri, config.localName, tagName);
                      if (localNSMap) {
                        for (var prefix in localNSMap) {
                          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                            domBuilder.endPrefixMapping(prefix);
                          }
                        }
                      }
                      if (!endMatch) {
                        errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                      }
                    } else {
                      parseStack.push(config);
                    }
                    end++;
                    break;
                  case "?":
                    locator && position(tagStart);
                    end = parseInstruction(source, tagStart, domBuilder);
                    break;
                  case "!":
                    locator && position(tagStart);
                    end = parseDCC(source, tagStart, domBuilder, errorHandler);
                    break;
                  default:
                    locator && position(tagStart);
                    var el = new ElementAttributes();
                    var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                    var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                    var len = el.length;
                    if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                      el.closed = true;
                      if (!entityMap.nbsp) {
                        errorHandler.warning("unclosed xml attribute");
                      }
                    }
                    if (locator && len) {
                      var locator2 = copyLocator(locator, {});
                      for (var i = 0; i < len; i++) {
                        var a = el[i];
                        position(a.offset);
                        a.locator = copyLocator(locator, {});
                      }
                      domBuilder.locator = locator2;
                      if (appendElement(el, domBuilder, currentNSMap)) {
                        parseStack.push(el);
                      }
                      domBuilder.locator = locator;
                    } else {
                      if (appendElement(el, domBuilder, currentNSMap)) {
                        parseStack.push(el);
                      }
                    }
                    if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                      end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
                    } else {
                      end++;
                    }
                }
              } catch (e) {
                if (e instanceof ParseError) {
                  throw e;
                }
                errorHandler.error("element parse error: " + e);
                end = -1;
              }
              if (end > start) {
                start = end;
              } else {
                appendText(Math.max(tagStart, start) + 1);
              }
            }
          }
          function copyLocator(f, t) {
            t.lineNumber = f.lineNumber;
            t.columnNumber = f.columnNumber;
            return t;
          }
          function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
            function addAttribute(qname, value2, startIndex) {
              if (el.attributeNames.hasOwnProperty(qname)) {
                errorHandler.fatalError("Attribute " + qname + " redefined");
              }
              el.addValue(qname, value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer), startIndex);
            }
            var attrName;
            var value;
            var p = ++start;
            var s = S_TAG;
            while (true) {
              var c = source.charAt(p);
              switch (c) {
                case "=":
                  if (s === S_ATTR) {
                    attrName = source.slice(start, p);
                    s = S_EQ;
                  } else if (s === S_ATTR_SPACE) {
                    s = S_EQ;
                  } else {
                    throw new Error("attribute equal must after attrName");
                  }
                  break;
                case "'":
                case '"':
                  if (s === S_EQ || s === S_ATTR) {
                    if (s === S_ATTR) {
                      errorHandler.warning('attribute value must after "="');
                      attrName = source.slice(start, p);
                    }
                    start = p + 1;
                    p = source.indexOf(c, start);
                    if (p > 0) {
                      value = source.slice(start, p);
                      addAttribute(attrName, value, start - 1);
                      s = S_ATTR_END;
                    } else {
                      throw new Error("attribute value no end '" + c + "' match");
                    }
                  } else if (s == S_ATTR_NOQUOT_VALUE) {
                    value = source.slice(start, p);
                    addAttribute(attrName, value, start);
                    errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                    start = p + 1;
                    s = S_ATTR_END;
                  } else {
                    throw new Error('attribute value must after "="');
                  }
                  break;
                case "/":
                  switch (s) {
                    case S_TAG:
                      el.setTagName(source.slice(start, p));
                    case S_ATTR_END:
                    case S_TAG_SPACE:
                    case S_TAG_CLOSE:
                      s = S_TAG_CLOSE;
                      el.closed = true;
                    case S_ATTR_NOQUOT_VALUE:
                    case S_ATTR:
                    case S_ATTR_SPACE:
                      break;
                    default:
                      throw new Error("attribute invalid close char('/')");
                  }
                  break;
                case "":
                  errorHandler.error("unexpected end of input");
                  if (s == S_TAG) {
                    el.setTagName(source.slice(start, p));
                  }
                  return p;
                case ">":
                  switch (s) {
                    case S_TAG:
                      el.setTagName(source.slice(start, p));
                    case S_ATTR_END:
                    case S_TAG_SPACE:
                    case S_TAG_CLOSE:
                      break;
                    case S_ATTR_NOQUOT_VALUE:
                    case S_ATTR:
                      value = source.slice(start, p);
                      if (value.slice(-1) === "/") {
                        el.closed = true;
                        value = value.slice(0, -1);
                      }
                    case S_ATTR_SPACE:
                      if (s === S_ATTR_SPACE) {
                        value = attrName;
                      }
                      if (s == S_ATTR_NOQUOT_VALUE) {
                        errorHandler.warning('attribute "' + value + '" missed quot(")!');
                        addAttribute(attrName, value, start);
                      } else {
                        if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                          errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                        }
                        addAttribute(value, value, start);
                      }
                      break;
                    case S_EQ:
                      throw new Error("attribute value missed!!");
                  }
                  return p;
                case "\x80":
                  c = " ";
                default:
                  if (c <= " ") {
                    switch (s) {
                      case S_TAG:
                        el.setTagName(source.slice(start, p));
                        s = S_TAG_SPACE;
                        break;
                      case S_ATTR:
                        attrName = source.slice(start, p);
                        s = S_ATTR_SPACE;
                        break;
                      case S_ATTR_NOQUOT_VALUE:
                        var value = source.slice(start, p);
                        errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                        addAttribute(attrName, value, start);
                      case S_ATTR_END:
                        s = S_TAG_SPACE;
                        break;
                    }
                  } else {
                    switch (s) {
                      case S_ATTR_SPACE:
                        var tagName = el.tagName;
                        if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                          errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                        }
                        addAttribute(attrName, attrName, start);
                        start = p;
                        s = S_ATTR;
                        break;
                      case S_ATTR_END:
                        errorHandler.warning('attribute space is required"' + attrName + '"!!');
                      case S_TAG_SPACE:
                        s = S_ATTR;
                        start = p;
                        break;
                      case S_EQ:
                        s = S_ATTR_NOQUOT_VALUE;
                        start = p;
                        break;
                      case S_TAG_CLOSE:
                        throw new Error("elements closed character '/' and '>' must be connected to");
                    }
                  }
              }
              p++;
            }
          }
          function appendElement(el, domBuilder, currentNSMap) {
            var tagName = el.tagName;
            var localNSMap = null;
            var i = el.length;
            while (i--) {
              var a = el[i];
              var qName = a.qName;
              var value = a.value;
              var nsp = qName.indexOf(":");
              if (nsp > 0) {
                var prefix = a.prefix = qName.slice(0, nsp);
                var localName = qName.slice(nsp + 1);
                var nsPrefix = prefix === "xmlns" && localName;
              } else {
                localName = qName;
                prefix = null;
                nsPrefix = qName === "xmlns" && "";
              }
              a.localName = localName;
              if (nsPrefix !== false) {
                if (localNSMap == null) {
                  localNSMap = {};
                  _copy(currentNSMap, currentNSMap = {});
                }
                currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
                a.uri = NAMESPACE.XMLNS;
                domBuilder.startPrefixMapping(nsPrefix, value);
              }
            }
            var i = el.length;
            while (i--) {
              a = el[i];
              var prefix = a.prefix;
              if (prefix) {
                if (prefix === "xml") {
                  a.uri = NAMESPACE.XML;
                }
                if (prefix !== "xmlns") {
                  a.uri = currentNSMap[prefix || ""];
                }
              }
            }
            var nsp = tagName.indexOf(":");
            if (nsp > 0) {
              prefix = el.prefix = tagName.slice(0, nsp);
              localName = el.localName = tagName.slice(nsp + 1);
            } else {
              prefix = null;
              localName = el.localName = tagName;
            }
            var ns = el.uri = currentNSMap[prefix || ""];
            domBuilder.startElement(ns, localName, tagName, el);
            if (el.closed) {
              domBuilder.endElement(ns, localName, tagName);
              if (localNSMap) {
                for (prefix in localNSMap) {
                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
            } else {
              el.currentNSMap = currentNSMap;
              el.localNSMap = localNSMap;
              return true;
            }
          }
          function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
            if (/^(?:script|textarea)$/i.test(tagName)) {
              var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
              var text = source.substring(elStartEnd + 1, elEndStart);
              if (/[&<]/.test(text)) {
                if (/^script$/i.test(tagName)) {
                  domBuilder.characters(text, 0, text.length);
                  return elEndStart;
                }
                text = text.replace(/&#?\w+;/g, entityReplacer);
                domBuilder.characters(text, 0, text.length);
                return elEndStart;
              }
            }
            return elStartEnd + 1;
          }
          function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
            var pos = closeMap[tagName];
            if (pos == null) {
              pos = source.lastIndexOf("</" + tagName + ">");
              if (pos < elStartEnd) {
                pos = source.lastIndexOf("</" + tagName);
              }
              closeMap[tagName] = pos;
            }
            return pos < elStartEnd;
          }
          function _copy(source, target) {
            for (var n in source) {
              if (Object.prototype.hasOwnProperty.call(source, n)) {
                target[n] = source[n];
              }
            }
          }
          function parseDCC(source, start, domBuilder, errorHandler) {
            var next = source.charAt(start + 2);
            switch (next) {
              case "-":
                if (source.charAt(start + 3) === "-") {
                  var end = source.indexOf("-->", start + 4);
                  if (end > start) {
                    domBuilder.comment(source, start + 4, end - start - 4);
                    return end + 3;
                  } else {
                    errorHandler.error("Unclosed comment");
                    return -1;
                  }
                } else {
                  return -1;
                }
              default:
                if (source.substr(start + 3, 6) == "CDATA[") {
                  var end = source.indexOf("]]>", start + 9);
                  domBuilder.startCDATA();
                  domBuilder.characters(source, start + 9, end - start - 9);
                  domBuilder.endCDATA();
                  return end + 3;
                }
                var matchs = split(source, start);
                var len = matchs.length;
                if (len > 1 && /!doctype/i.test(matchs[0][0])) {
                  var name = matchs[1][0];
                  var pubid = false;
                  var sysid = false;
                  if (len > 3) {
                    if (/^public$/i.test(matchs[2][0])) {
                      pubid = matchs[3][0];
                      sysid = len > 4 && matchs[4][0];
                    } else if (/^system$/i.test(matchs[2][0])) {
                      sysid = matchs[3][0];
                    }
                  }
                  var lastMatch = matchs[len - 1];
                  domBuilder.startDTD(name, pubid, sysid);
                  domBuilder.endDTD();
                  return lastMatch.index + lastMatch[0].length;
                }
            }
            return -1;
          }
          function parseInstruction(source, start, domBuilder) {
            var end = source.indexOf("?>", start);
            if (end) {
              var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
              if (match) {
                var len = match[0].length;
                domBuilder.processingInstruction(match[1], match[2]);
                return end + 2;
              } else {
                return -1;
              }
            }
            return -1;
          }
          function ElementAttributes() {
            this.attributeNames = {};
          }
          ElementAttributes.prototype = {
            setTagName: function(tagName) {
              if (!tagNamePattern.test(tagName)) {
                throw new Error("invalid tagName:" + tagName);
              }
              this.tagName = tagName;
            },
            addValue: function(qName, value, offset) {
              if (!tagNamePattern.test(qName)) {
                throw new Error("invalid attribute:" + qName);
              }
              this.attributeNames[qName] = this.length;
              this[this.length++] = { qName, value, offset };
            },
            length: 0,
            getLocalName: function(i) {
              return this[i].localName;
            },
            getLocator: function(i) {
              return this[i].locator;
            },
            getQName: function(i) {
              return this[i].qName;
            },
            getURI: function(i) {
              return this[i].uri;
            },
            getValue: function(i) {
              return this[i].value;
            }
          };
          function split(source, start) {
            var match;
            var buf = [];
            var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
            reg.lastIndex = start;
            reg.exec(source);
            while (match = reg.exec(source)) {
              buf.push(match);
              if (match[1])
                return buf;
            }
          }
          exports2.XMLReader = XMLReader;
          exports2.ParseError = ParseError;
        },
        "./node_modules/process/browser.js": function(module2, exports2) {
          var process2 = module2.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process2.title = "browser";
          process2.browser = true;
          process2.env = {};
          process2.argv = [];
          process2.version = "";
          process2.versions = {};
          function noop() {
          }
          process2.on = noop;
          process2.addListener = noop;
          process2.once = noop;
          process2.off = noop;
          process2.removeListener = noop;
          process2.removeAllListeners = noop;
          process2.emit = noop;
          process2.prependListener = noop;
          process2.prependOnceListener = noop;
          process2.listeners = function(name) {
            return [];
          };
          process2.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process2.cwd = function() {
            return "/";
          };
          process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process2.umask = function() {
            return 0;
          };
        },
        "./node_modules/webpack/buildin/amd-options.js": function(module2, exports2) {
          (function(__webpack_amd_options__) {
            module2.exports = __webpack_amd_options__;
          }).call(this, {});
        },
        "./node_modules/webpack/buildin/global.js": function(module2, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module2.exports = g;
        },
        "./node_modules/webpack/buildin/module.js": function(module2, exports2) {
          module2.exports = function(module3) {
            if (!module3.webpackPolyfill) {
              module3.deprecate = function() {
              };
              module3.paths = [];
              if (!module3.children)
                module3.children = [];
              Object.defineProperty(module3, "loaded", {
                enumerable: true,
                get: function() {
                  return module3.l;
                }
              });
              Object.defineProperty(module3, "id", {
                enumerable: true,
                get: function() {
                  return module3.i;
                }
              });
              module3.webpackPolyfill = 1;
            }
            return module3;
          };
        },
        "./package.json": function(module2) {
          module2.exports = JSON.parse('{"name":"cos-js-sdk-v5","version":"1.4.14","description":"JavaScript SDK for [\u817E\u8BAF\u4E91\u5BF9\u8C61\u5B58\u50A8](https://cloud.tencent.com/product/cos)","main":"dist/cos-js-sdk-v5.js","types":"index.d.ts","scripts":{"server":"node server/sts.js","dev":"cross-env NODE_ENV=development webpack -w --mode=development","build":"cross-env NODE_ENV=production webpack --mode=production","cos-auth.min.js":"uglifyjs ./demo/common/cos-auth.js -o ./demo/common/cos-auth.min.js -c -m"},"repository":{"type":"git","url":"git+https://github.com/tencentyun/cos-js-sdk-v5.git"},"keywords":[],"author":"carsonxu","license":"ISC","bugs":{"url":"https://github.com/tencentyun/cos-js-sdk-v5/issues"},"homepage":"https://github.com/tencentyun/cos-js-sdk-v5#readme","dependencies":{"@xmldom/xmldom":"^0.8.6"},"devDependencies":{"@babel/core":"7.17.9","@babel/plugin-transform-runtime":"7.18.10","@babel/preset-env":"7.16.11","babel-loader":"8.2.5","body-parser":"^1.18.3","cross-env":"^5.2.0","express":"^4.16.4","qcloud-cos-sts":"^3.0.2","request":"^2.87.0","terser-webpack-plugin":"4.2.3","webpack":"4.46.0","webpack-cli":"4.10.0"}}');
        },
        "./src/advance.js": function(module2, exports2, __webpack_require__2) {
          var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
          var session = __webpack_require__2("./src/session.js");
          var Async = __webpack_require__2("./src/async.js");
          var EventProxy = __webpack_require__2("./src/event.js").EventProxy;
          var util = __webpack_require__2("./src/util.js");
          var Tracker = __webpack_require__2("./src/tracker.js");
          function sliceUploadFile(params, callback) {
            var self2 = this;
            var ep = new EventProxy();
            var TaskId = params.TaskId;
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var Body = params.Body;
            var ChunkSize = params.ChunkSize || params.SliceSize || self2.options.ChunkSize;
            var AsyncLimit = params.AsyncLimit;
            var StorageClass = params.StorageClass;
            var ServerSideEncryption = params.ServerSideEncryption;
            var FileSize;
            var onProgress;
            var onHashProgress = params.onHashProgress;
            var tracker = params.tracker;
            tracker && tracker.setParams({
              chunkSize: ChunkSize
            });
            ep.on("error", function(err) {
              if (!self2._isRunningTask(TaskId))
                return;
              err.UploadId = params.UploadData.UploadId || "";
              return callback(err);
            });
            ep.on("upload_complete", function(UploadCompleteData) {
              var _UploadCompleteData = util.extend({
                UploadId: params.UploadData.UploadId || ""
              }, UploadCompleteData);
              callback(null, _UploadCompleteData);
            });
            ep.on("upload_slice_complete", function(UploadData) {
              var metaHeaders = {};
              util.each(params.Headers, function(val, k) {
                var shortKey = k.toLowerCase();
                if (shortKey.indexOf("x-cos-meta-") === 0 || shortKey === "pic-operations")
                  metaHeaders[k] = val;
              });
              uploadSliceComplete.call(self2, {
                Bucket,
                Region,
                Key,
                UploadId: UploadData.UploadId,
                SliceList: UploadData.SliceList,
                Headers: metaHeaders,
                tracker
              }, function(err, data) {
                if (!self2._isRunningTask(TaskId))
                  return;
                session.removeUsing(UploadData.UploadId);
                if (err) {
                  onProgress(null, true);
                  return ep.emit("error", err);
                }
                session.removeUploadId.call(self2, UploadData.UploadId);
                onProgress({
                  loaded: FileSize,
                  total: FileSize
                }, true);
                ep.emit("upload_complete", data);
              });
            });
            ep.on("get_upload_data_finish", function(UploadData) {
              var uuid = session.getFileId(Body, params.ChunkSize, Bucket, Key);
              uuid && session.saveUploadId.call(self2, uuid, UploadData.UploadId, self2.options.UploadIdCacheLimit);
              session.setUsing(UploadData.UploadId);
              onProgress(null, true);
              uploadSliceList.call(self2, {
                TaskId,
                Bucket,
                Region,
                Key,
                Body,
                FileSize,
                SliceSize: ChunkSize,
                AsyncLimit,
                ServerSideEncryption,
                UploadData,
                Headers: params.Headers,
                onProgress,
                tracker
              }, function(err, data) {
                if (!self2._isRunningTask(TaskId))
                  return;
                if (err) {
                  onProgress(null, true);
                  return ep.emit("error", err);
                }
                ep.emit("upload_slice_complete", data);
              });
            });
            ep.on("get_file_size_finish", function() {
              onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
              if (params.UploadData.UploadId) {
                ep.emit("get_upload_data_finish", params.UploadData);
              } else {
                var _params = util.extend({
                  TaskId,
                  Bucket,
                  Region,
                  Key,
                  Headers: params.Headers,
                  StorageClass,
                  Body,
                  FileSize,
                  SliceSize: ChunkSize,
                  onHashProgress,
                  tracker
                }, params);
                getUploadIdAndPartList.call(self2, _params, function(err, UploadData) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  if (err)
                    return ep.emit("error", err);
                  params.UploadData.UploadId = UploadData.UploadId;
                  params.UploadData.PartList = UploadData.PartList;
                  ep.emit("get_upload_data_finish", params.UploadData);
                });
              }
            });
            FileSize = params.ContentLength;
            delete params.ContentLength;
            !params.Headers && (params.Headers = {});
            util.each(params.Headers, function(item, key) {
              if (key.toLowerCase() === "content-length") {
                delete params.Headers[key];
              }
            });
            (function() {
              var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
              var AutoChunkSize = 1024 * 1024;
              for (var i = 0; i < SIZE.length; i++) {
                AutoChunkSize = SIZE[i] * 1024 * 1024;
                if (FileSize / AutoChunkSize <= self2.options.MaxPartNumber)
                  break;
              }
              params.ChunkSize = params.SliceSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
            })();
            if (FileSize === 0) {
              params.Body = "";
              params.ContentLength = 0;
              params.SkipTask = true;
              self2.putObject(params, callback);
            } else {
              ep.emit("get_file_size_finish");
            }
          }
          function getUploadIdAndPartList(params, callback) {
            var TaskId = params.TaskId;
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var StorageClass = params.StorageClass;
            var self2 = this;
            var ETagMap = {};
            var FileSize = params.FileSize;
            var SliceSize = params.SliceSize;
            var SliceCount = Math.ceil(FileSize / SliceSize);
            var FinishSliceCount = 0;
            var FinishSize = 0;
            var onHashProgress = util.throttleOnProgress.call(self2, FileSize, params.onHashProgress);
            var getChunkETag = function getChunkETag2(PartNumber, callback2) {
              var start = SliceSize * (PartNumber - 1);
              var end = Math.min(start + SliceSize, FileSize);
              var ChunkSize = end - start;
              if (ETagMap[PartNumber]) {
                callback2(null, {
                  PartNumber,
                  ETag: ETagMap[PartNumber],
                  Size: ChunkSize
                });
              } else {
                util.fileSlice(params.Body, start, end, false, function(chunkItem) {
                  util.getFileMd5(chunkItem, function(err, md5) {
                    if (err)
                      return callback2(util.error(err));
                    var ETag = '"' + md5 + '"';
                    ETagMap[PartNumber] = ETag;
                    FinishSliceCount += 1;
                    FinishSize += ChunkSize;
                    onHashProgress({
                      loaded: FinishSize,
                      total: FileSize
                    });
                    callback2(null, {
                      PartNumber,
                      ETag,
                      Size: ChunkSize
                    });
                  });
                });
              }
            };
            var isAvailableUploadList = function isAvailableUploadList2(PartList, callback2) {
              var PartCount = PartList.length;
              if (PartCount === 0) {
                return callback2(null, true);
              }
              if (PartCount > SliceCount) {
                return callback2(null, false);
              }
              if (PartCount > 1) {
                var PartSliceSize = Math.max(PartList[0].Size, PartList[1].Size);
                if (PartSliceSize !== SliceSize) {
                  return callback2(null, false);
                }
              }
              var next = function next2(index) {
                if (index < PartCount) {
                  var Part = PartList[index];
                  getChunkETag(Part.PartNumber, function(err, chunk) {
                    if (chunk && chunk.ETag === Part.ETag && chunk.Size === Part.Size) {
                      next2(index + 1);
                    } else {
                      callback2(null, false);
                    }
                  });
                } else {
                  callback2(null, true);
                }
              };
              next(0);
            };
            var ep = new EventProxy();
            ep.on("error", function(errData) {
              if (!self2._isRunningTask(TaskId))
                return;
              return callback(errData);
            });
            ep.on("upload_id_available", function(UploadData) {
              var map = {};
              var list = [];
              util.each(UploadData.PartList, function(item2) {
                map[item2.PartNumber] = item2;
              });
              for (var PartNumber = 1; PartNumber <= SliceCount; PartNumber++) {
                var item = map[PartNumber];
                if (item) {
                  item.PartNumber = PartNumber;
                  item.Uploaded = true;
                } else {
                  item = {
                    PartNumber,
                    ETag: null,
                    Uploaded: false
                  };
                }
                list.push(item);
              }
              UploadData.PartList = list;
              callback(null, UploadData);
            });
            ep.on("no_available_upload_id", function() {
              if (!self2._isRunningTask(TaskId))
                return;
              var _params = util.extend({
                Bucket,
                Region,
                Key,
                Query: util.clone(params.Query),
                StorageClass,
                Body: params.Body,
                calledBySdk: "sliceUploadFile",
                tracker: params.tracker
              }, params);
              var headers = util.clone(params.Headers);
              delete headers["x-cos-mime-limit"];
              _params.Headers = headers;
              self2.multipartInit(_params, function(err, data) {
                if (!self2._isRunningTask(TaskId))
                  return;
                if (err)
                  return ep.emit("error", err);
                var UploadId = data.UploadId;
                if (!UploadId) {
                  return callback(util.error(new Error("no such upload id")));
                }
                ep.emit("upload_id_available", {
                  UploadId,
                  PartList: []
                });
              });
            });
            ep.on("has_and_check_upload_id", function(UploadIdList) {
              UploadIdList = UploadIdList.reverse();
              Async.eachLimit(UploadIdList, 1, function(UploadId, asyncCallback) {
                if (!self2._isRunningTask(TaskId))
                  return;
                if (session.using[UploadId]) {
                  asyncCallback();
                  return;
                }
                wholeMultipartListPart.call(self2, {
                  Bucket,
                  Region,
                  Key,
                  UploadId,
                  tracker: params.tracker
                }, function(err, PartListData) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  if (err) {
                    session.removeUsing(UploadId);
                    return ep.emit("error", err);
                  }
                  var PartList = PartListData.PartList;
                  PartList.forEach(function(item) {
                    item.PartNumber *= 1;
                    item.Size *= 1;
                    item.ETag = item.ETag || "";
                  });
                  isAvailableUploadList(PartList, function(err2, isAvailable) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    if (err2)
                      return ep.emit("error", err2);
                    if (isAvailable) {
                      asyncCallback({
                        UploadId,
                        PartList
                      });
                    } else {
                      asyncCallback();
                    }
                  });
                });
              }, function(AvailableUploadData) {
                if (!self2._isRunningTask(TaskId))
                  return;
                onHashProgress(null, true);
                if (AvailableUploadData && AvailableUploadData.UploadId) {
                  ep.emit("upload_id_available", AvailableUploadData);
                } else {
                  ep.emit("no_available_upload_id");
                }
              });
            });
            ep.on("seek_local_avail_upload_id", function(RemoteUploadIdList) {
              var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key);
              var LocalUploadIdList = session.getUploadIdList.call(self2, uuid);
              if (!uuid || !LocalUploadIdList) {
                ep.emit("has_and_check_upload_id", RemoteUploadIdList);
                return;
              }
              var next = function next2(index) {
                if (index >= LocalUploadIdList.length) {
                  ep.emit("has_and_check_upload_id", RemoteUploadIdList);
                  return;
                }
                var UploadId = LocalUploadIdList[index];
                if (!util.isInArray(RemoteUploadIdList, UploadId)) {
                  session.removeUploadId.call(self2, UploadId);
                  next2(index + 1);
                  return;
                }
                if (session.using[UploadId]) {
                  next2(index + 1);
                  return;
                }
                wholeMultipartListPart.call(self2, {
                  Bucket,
                  Region,
                  Key,
                  UploadId,
                  tracker: params.tracker
                }, function(err, PartListData) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  if (err) {
                    session.removeUploadId.call(self2, UploadId);
                    next2(index + 1);
                  } else {
                    ep.emit("upload_id_available", {
                      UploadId,
                      PartList: PartListData.PartList
                    });
                  }
                });
              };
              next(0);
            });
            ep.on("get_remote_upload_id_list", function() {
              wholeMultipartList.call(self2, {
                Bucket,
                Region,
                Key,
                tracker: params.tracker
              }, function(err, data) {
                if (!self2._isRunningTask(TaskId))
                  return;
                if (err)
                  return ep.emit("error", err);
                var RemoteUploadIdList = util.filter(data.UploadList, function(item) {
                  return item.Key === Key && (!StorageClass || item.StorageClass.toUpperCase() === StorageClass.toUpperCase());
                }).reverse().map(function(item) {
                  return item.UploadId || item.UploadID;
                });
                if (RemoteUploadIdList.length) {
                  ep.emit("seek_local_avail_upload_id", RemoteUploadIdList);
                } else {
                  var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key), LocalUploadIdList;
                  if (uuid && (LocalUploadIdList = session.getUploadIdList.call(self2, uuid))) {
                    util.each(LocalUploadIdList, function(UploadId) {
                      session.removeUploadId.call(self2, UploadId);
                    });
                  }
                  ep.emit("no_available_upload_id");
                }
              });
            });
            ep.emit("get_remote_upload_id_list");
          }
          function wholeMultipartList(params, callback) {
            var self2 = this;
            var UploadList = [];
            var sendParams = {
              Bucket: params.Bucket,
              Region: params.Region,
              Prefix: params.Key,
              calledBySdk: params.calledBySdk || "sliceUploadFile",
              tracker: params.tracker
            };
            var next = function next2() {
              self2.multipartList(sendParams, function(err, data) {
                if (err)
                  return callback(err);
                UploadList.push.apply(UploadList, data.Upload || []);
                if (data.IsTruncated === "true") {
                  sendParams.KeyMarker = data.NextKeyMarker;
                  sendParams.UploadIdMarker = data.NextUploadIdMarker;
                  next2();
                } else {
                  callback(null, {
                    UploadList
                  });
                }
              });
            };
            next();
          }
          function wholeMultipartListPart(params, callback) {
            var self2 = this;
            var PartList = [];
            var sendParams = {
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              UploadId: params.UploadId,
              calledBySdk: "sliceUploadFile",
              tracker: params.tracker
            };
            var next = function next2() {
              self2.multipartListPart(sendParams, function(err, data) {
                if (err)
                  return callback(err);
                PartList.push.apply(PartList, data.Part || []);
                if (data.IsTruncated === "true") {
                  sendParams.PartNumberMarker = data.NextPartNumberMarker;
                  next2();
                } else {
                  callback(null, {
                    PartList
                  });
                }
              });
            };
            next();
          }
          function uploadSliceList(params, cb) {
            var self2 = this;
            var TaskId = params.TaskId;
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var UploadData = params.UploadData;
            var FileSize = params.FileSize;
            var SliceSize = params.SliceSize;
            var ChunkParallel = Math.min(params.AsyncLimit || self2.options.ChunkParallelLimit || 1, 256);
            var Body = params.Body;
            var SliceCount = Math.ceil(FileSize / SliceSize);
            var FinishSize = 0;
            var ServerSideEncryption = params.ServerSideEncryption;
            var Headers = params.Headers;
            var needUploadSlices = util.filter(UploadData.PartList, function(SliceItem) {
              if (SliceItem["Uploaded"]) {
                FinishSize += SliceItem["PartNumber"] >= SliceCount ? FileSize % SliceSize || SliceSize : SliceSize;
              }
              return !SliceItem["Uploaded"];
            });
            var _onProgress2 = params.onProgress;
            Async.eachLimit(needUploadSlices, ChunkParallel, function(SliceItem, asyncCallback) {
              if (!self2._isRunningTask(TaskId))
                return;
              var PartNumber = SliceItem["PartNumber"];
              var currentSize = Math.min(FileSize, SliceItem["PartNumber"] * SliceSize) - (SliceItem["PartNumber"] - 1) * SliceSize;
              var preAddSize = 0;
              uploadSliceItem.call(self2, {
                TaskId,
                Bucket,
                Region,
                Key,
                SliceSize,
                FileSize,
                PartNumber,
                ServerSideEncryption,
                Body,
                UploadData,
                Headers,
                onProgress: function onProgress(data) {
                  FinishSize += data.loaded - preAddSize;
                  preAddSize = data.loaded;
                  _onProgress2({
                    loaded: FinishSize,
                    total: FileSize
                  });
                },
                tracker: params.tracker
              }, function(err, data) {
                if (!self2._isRunningTask(TaskId))
                  return;
                if (!err && !data.ETag)
                  err = 'get ETag error, please add "ETag" to CORS ExposeHeader setting.( \u83B7\u53D6ETag\u5931\u8D25\uFF0C\u8BF7\u5728CORS ExposeHeader\u8BBE\u7F6E\u4E2D\u6DFB\u52A0ETag\uFF0C\u8BF7\u53C2\u8003\u6587\u6863\uFF1Ahttps://cloud.tencent.com/document/product/436/13318 )';
                if (err) {
                  FinishSize -= preAddSize;
                } else {
                  FinishSize += currentSize - preAddSize;
                  SliceItem.ETag = data.ETag;
                }
                _onProgress2({
                  loaded: FinishSize,
                  total: FileSize
                });
                asyncCallback(err || null, data);
              });
            }, function(err) {
              if (!self2._isRunningTask(TaskId))
                return;
              if (err)
                return cb(err);
              cb(null, {
                UploadId: UploadData.UploadId,
                SliceList: UploadData.PartList
              });
            });
          }
          function uploadSliceItem(params, callback) {
            var self2 = this;
            var TaskId = params.TaskId;
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var FileSize = params.FileSize;
            var FileBody = params.Body;
            var PartNumber = params.PartNumber * 1;
            var SliceSize = params.SliceSize;
            var ServerSideEncryption = params.ServerSideEncryption;
            var UploadData = params.UploadData;
            var Headers = params.Headers || {};
            var ChunkRetryTimes = self2.options.ChunkRetryTimes + 1;
            var start = SliceSize * (PartNumber - 1);
            var ContentLength = SliceSize;
            var end = start + SliceSize;
            if (end > FileSize) {
              end = FileSize;
              ContentLength = end - start;
            }
            var headersWhiteList = ["x-cos-traffic-limit", "x-cos-mime-limit"];
            var headers = {};
            util.each(Headers, function(v, k) {
              if (headersWhiteList.indexOf(k) > -1) {
                headers[k] = v;
              }
            });
            var PartItem = UploadData.PartList[PartNumber - 1];
            Async.retry(ChunkRetryTimes, function(tryCallback) {
              if (!self2._isRunningTask(TaskId))
                return;
              util.fileSlice(FileBody, start, end, true, function(Body) {
                self2.multipartUpload({
                  TaskId,
                  Bucket,
                  Region,
                  Key,
                  ContentLength,
                  PartNumber,
                  UploadId: UploadData.UploadId,
                  ServerSideEncryption,
                  Body,
                  Headers: headers,
                  onProgress: params.onProgress,
                  calledBySdk: "sliceUploadFile",
                  tracker: params.tracker
                }, function(err, data) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  if (err)
                    return tryCallback(err);
                  PartItem.Uploaded = true;
                  return tryCallback(null, data);
                });
              });
            }, function(err, data) {
              if (!self2._isRunningTask(TaskId))
                return;
              return callback(err, data);
            });
          }
          function uploadSliceComplete(params, callback) {
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var UploadId = params.UploadId;
            var SliceList = params.SliceList;
            var self2 = this;
            var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
            var Headers = params.Headers;
            var Parts = SliceList.map(function(item) {
              return {
                PartNumber: item.PartNumber,
                ETag: item.ETag
              };
            });
            Async.retry(ChunkRetryTimes, function(tryCallback) {
              self2.multipartComplete({
                Bucket,
                Region,
                Key,
                UploadId,
                Parts,
                Headers,
                calledBySdk: "sliceUploadFile",
                tracker: params.tracker
              }, tryCallback);
            }, function(err, data) {
              callback(err, data);
            });
          }
          function abortUploadTask(params, callback) {
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var UploadId = params.UploadId;
            var Level = params.Level || "task";
            var AsyncLimit = params.AsyncLimit;
            var self2 = this;
            var ep = new EventProxy();
            ep.on("error", function(errData) {
              return callback(errData);
            });
            ep.on("get_abort_array", function(AbortArray) {
              abortUploadTaskArray.call(self2, {
                Bucket,
                Region,
                Key,
                Headers: params.Headers,
                AsyncLimit,
                AbortArray
              }, callback);
            });
            if (Level === "bucket") {
              wholeMultipartList.call(self2, {
                Bucket,
                Region,
                calledBySdk: "abortUploadTask"
              }, function(err, data) {
                if (err)
                  return callback(err);
                ep.emit("get_abort_array", data.UploadList || []);
              });
            } else if (Level === "file") {
              if (!Key)
                return callback(util.error(new Error("abort_upload_task_no_key")));
              wholeMultipartList.call(self2, {
                Bucket,
                Region,
                Key,
                calledBySdk: "abortUploadTask"
              }, function(err, data) {
                if (err)
                  return callback(err);
                ep.emit("get_abort_array", data.UploadList || []);
              });
            } else if (Level === "task") {
              if (!UploadId)
                return callback(util.error(new Error("abort_upload_task_no_id")));
              if (!Key)
                return callback(util.error(new Error("abort_upload_task_no_key")));
              ep.emit("get_abort_array", [{
                Key,
                UploadId
              }]);
            } else {
              return callback(util.error(new Error("abort_unknown_level")));
            }
          }
          function abortUploadTaskArray(params, callback) {
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var AbortArray = params.AbortArray;
            var AsyncLimit = params.AsyncLimit || 1;
            var self2 = this;
            var index = 0;
            var resultList = new Array(AbortArray.length);
            Async.eachLimit(AbortArray, AsyncLimit, function(AbortItem, nextItem) {
              var eachIndex = index;
              if (Key && Key !== AbortItem.Key) {
                resultList[eachIndex] = {
                  error: {
                    KeyNotMatch: true
                  }
                };
                nextItem(null);
                return;
              }
              var UploadId = AbortItem.UploadId || AbortItem.UploadID;
              self2.multipartAbort({
                Bucket,
                Region,
                Key: AbortItem.Key,
                Headers: params.Headers,
                UploadId
              }, function(err) {
                var task = {
                  Bucket,
                  Region,
                  Key: AbortItem.Key,
                  UploadId
                };
                resultList[eachIndex] = {
                  error: err,
                  task
                };
                nextItem(null);
              });
              index++;
            }, function(err) {
              if (err)
                return callback(err);
              var successList = [];
              var errorList = [];
              for (var i = 0, len = resultList.length; i < len; i++) {
                var item = resultList[i];
                if (item["task"]) {
                  if (item["error"]) {
                    errorList.push(item["task"]);
                  } else {
                    successList.push(item["task"]);
                  }
                }
              }
              return callback(null, {
                successList,
                errorList
              });
            });
          }
          function uploadFile(params, callback) {
            var self2 = this;
            var SliceSize = params.SliceSize === void 0 ? self2.options.SliceSize : params.SliceSize;
            var taskList = [];
            var Body = params.Body;
            var FileSize = Body.size || Body.length || 0;
            var fileInfo = {
              TaskId: ""
            };
            if (self2.options.EnableTracker) {
              var accelerate = self2.options.UseAccelerate || typeof self2.options.Domain === "string" && self2.options.Domain.includes("accelerate.");
              params.tracker = new Tracker({
                bucket: params.Bucket,
                region: params.Region,
                apiName: "uploadFile",
                fileKey: params.Key,
                fileSize: FileSize,
                accelerate,
                deepTracker: self2.options.DeepTracker,
                customId: self2.options.CustomId,
                delay: self2.options.TrackerDelay
              });
            }
            util.each(params, function(v, k) {
              if (_typeof2(v) !== "object" && typeof v !== "function") {
                fileInfo[k] = v;
              }
            });
            var _onTaskReady = params.onTaskReady;
            var onTaskReady = function onTaskReady2(tid) {
              fileInfo.TaskId = tid;
              _onTaskReady && _onTaskReady(tid);
            };
            params.onTaskReady = onTaskReady;
            var api = FileSize > SliceSize ? "sliceUploadFile" : "putObject";
            var _onFileFinish = params.onFileFinish;
            var onFileFinish = function onFileFinish2(err, data) {
              params.tracker && params.tracker.formatResult(err, data);
              _onFileFinish && _onFileFinish(err, data, fileInfo);
              callback && callback(err, data);
            };
            taskList.push({
              api,
              params,
              callback: onFileFinish
            });
            self2._addTasks(taskList);
          }
          function uploadFiles(params, callback) {
            var self2 = this;
            var SliceSize = params.SliceSize === void 0 ? self2.options.SliceSize : params.SliceSize;
            var TotalSize = 0;
            var TotalFinish = 0;
            var onTotalProgress = util.throttleOnProgress.call(self2, TotalFinish, params.onProgress);
            var unFinishCount = params.files.length;
            var _onTotalFileFinish = params.onFileFinish;
            var resultList = Array(unFinishCount);
            var onTotalFileFinish = function onTotalFileFinish2(err, data, options) {
              onTotalProgress(null, true);
              _onTotalFileFinish && _onTotalFileFinish(err, data, options);
              resultList[options.Index] = {
                options,
                error: err,
                data
              };
              if (--unFinishCount <= 0 && callback) {
                callback(null, {
                  files: resultList
                });
              }
            };
            var taskList = [];
            util.each(params.files, function(fileParams, index) {
              (function() {
                var Body = fileParams.Body;
                var FileSize = Body.size || Body.length || 0;
                var fileInfo = {
                  Index: index,
                  TaskId: ""
                };
                TotalSize += FileSize;
                if (self2.options.EnableTracker) {
                  var accelerate = self2.options.UseAccelerate || typeof self2.options.Domain === "string" && self2.options.Domain.includes("accelerate.");
                  fileParams.tracker = new Tracker({
                    bucket: fileParams.Bucket,
                    region: fileParams.Region,
                    apiName: "uploadFiles",
                    fileKey: fileParams.Key,
                    fileSize: FileSize,
                    accelerate,
                    deepTracker: self2.options.DeepTracker,
                    customId: self2.options.CustomId,
                    delay: self2.options.TrackerDelay
                  });
                }
                util.each(fileParams, function(v, k) {
                  if (_typeof2(v) !== "object" && typeof v !== "function") {
                    fileInfo[k] = v;
                  }
                });
                var _onTaskReady = fileParams.onTaskReady;
                var onTaskReady = function onTaskReady2(tid) {
                  fileInfo.TaskId = tid;
                  _onTaskReady && _onTaskReady(tid);
                };
                fileParams.onTaskReady = onTaskReady;
                var PreAddSize = 0;
                var _onProgress = fileParams.onProgress;
                var onProgress = function onProgress2(info) {
                  TotalFinish = TotalFinish - PreAddSize + info.loaded;
                  PreAddSize = info.loaded;
                  _onProgress && _onProgress(info);
                  onTotalProgress({
                    loaded: TotalFinish,
                    total: TotalSize
                  });
                };
                fileParams.onProgress = onProgress;
                var api = FileSize > SliceSize ? "sliceUploadFile" : "putObject";
                var _onFileFinish = fileParams.onFileFinish;
                var onFileFinish = function onFileFinish2(err, data) {
                  fileParams.tracker && fileParams.tracker.formatResult(err, data);
                  _onFileFinish && _onFileFinish(err, data);
                  onTotalFileFinish && onTotalFileFinish(err, data, fileInfo);
                };
                taskList.push({
                  api,
                  params: fileParams,
                  callback: onFileFinish
                });
              })();
            });
            self2._addTasks(taskList);
          }
          function sliceCopyFile(params, callback) {
            var ep = new EventProxy();
            var self2 = this;
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var CopySource = params.CopySource;
            var m = util.getSourceParams.call(this, CopySource);
            if (!m) {
              callback(util.error(new Error("CopySource format error")));
              return;
            }
            var SourceBucket = m.Bucket;
            var SourceRegion = m.Region;
            var SourceKey = decodeURIComponent(m.Key);
            var CopySliceSize = params.CopySliceSize === void 0 ? self2.options.CopySliceSize : params.CopySliceSize;
            CopySliceSize = Math.max(0, CopySliceSize);
            var ChunkSize = params.CopyChunkSize || this.options.CopyChunkSize;
            var ChunkParallel = this.options.CopyChunkParallelLimit;
            var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
            var ChunkCount = 0;
            var FinishSize = 0;
            var FileSize;
            var onProgress;
            var SourceResHeaders = {};
            var SourceHeaders = {};
            var TargetHeader = {};
            ep.on("copy_slice_complete", function(UploadData) {
              var metaHeaders = {};
              util.each(params.Headers, function(val, k) {
                if (k.toLowerCase().indexOf("x-cos-meta-") === 0)
                  metaHeaders[k] = val;
              });
              var Parts = util.map(UploadData.PartList, function(item) {
                return {
                  PartNumber: item.PartNumber,
                  ETag: item.ETag
                };
              });
              Async.retry(ChunkRetryTimes, function(tryCallback) {
                self2.multipartComplete({
                  Bucket,
                  Region,
                  Key,
                  UploadId: UploadData.UploadId,
                  Parts,
                  calledBySdk: "sliceCopyFile"
                }, tryCallback);
              }, function(err, data) {
                session.removeUsing(UploadData.UploadId);
                if (err) {
                  onProgress(null, true);
                  return callback(err);
                }
                session.removeUploadId(UploadData.UploadId);
                onProgress({
                  loaded: FileSize,
                  total: FileSize
                }, true);
                callback(null, data);
              });
            });
            ep.on("get_copy_data_finish", function(UploadData) {
              var uuid = session.getCopyFileId(CopySource, SourceResHeaders, ChunkSize, Bucket, Key);
              uuid && session.saveUploadId(uuid, UploadData.UploadId, self2.options.UploadIdCacheLimit);
              session.setUsing(UploadData.UploadId);
              var needCopySlices = util.filter(UploadData.PartList, function(SliceItem) {
                if (SliceItem["Uploaded"]) {
                  FinishSize += SliceItem["PartNumber"] >= ChunkCount ? FileSize % ChunkSize || ChunkSize : ChunkSize;
                }
                return !SliceItem["Uploaded"];
              });
              Async.eachLimit(needCopySlices, ChunkParallel, function(SliceItem, asyncCallback) {
                var PartNumber = SliceItem.PartNumber;
                var CopySourceRange = SliceItem.CopySourceRange;
                var currentSize = SliceItem.end - SliceItem.start;
                Async.retry(ChunkRetryTimes, function(tryCallback) {
                  copySliceItem.call(self2, {
                    Bucket,
                    Region,
                    Key,
                    CopySource,
                    UploadId: UploadData.UploadId,
                    PartNumber,
                    CopySourceRange
                  }, tryCallback);
                }, function(err, data) {
                  if (err)
                    return asyncCallback(err);
                  FinishSize += currentSize;
                  onProgress({
                    loaded: FinishSize,
                    total: FileSize
                  });
                  SliceItem.ETag = data.ETag;
                  asyncCallback(err || null, data);
                });
              }, function(err) {
                if (err) {
                  session.removeUsing(UploadData.UploadId);
                  onProgress(null, true);
                  return callback(err);
                }
                ep.emit("copy_slice_complete", UploadData);
              });
            });
            ep.on("get_chunk_size_finish", function() {
              var createNewUploadId = function createNewUploadId2() {
                self2.multipartInit({
                  Bucket,
                  Region,
                  Key,
                  Headers: TargetHeader
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  params.UploadId = data.UploadId;
                  ep.emit("get_copy_data_finish", {
                    UploadId: params.UploadId,
                    PartList: params.PartList
                  });
                });
              };
              var uuid = session.getCopyFileId(CopySource, SourceResHeaders, ChunkSize, Bucket, Key);
              var LocalUploadIdList = session.getUploadIdList(uuid);
              if (!uuid || !LocalUploadIdList)
                return createNewUploadId();
              var next = function next2(index) {
                if (index >= LocalUploadIdList.length)
                  return createNewUploadId();
                var UploadId = LocalUploadIdList[index];
                if (session.using[UploadId])
                  return next2(index + 1);
                wholeMultipartListPart.call(self2, {
                  Bucket,
                  Region,
                  Key,
                  UploadId
                }, function(err, PartListData) {
                  if (err) {
                    session.removeUploadId(UploadId);
                    next2(index + 1);
                  } else {
                    if (session.using[UploadId])
                      return next2(index + 1);
                    var finishETagMap = {};
                    var offset = 0;
                    util.each(PartListData.PartList, function(PartItem) {
                      var size = parseInt(PartItem.Size);
                      var end = offset + size - 1;
                      finishETagMap[PartItem.PartNumber + "|" + offset + "|" + end] = PartItem.ETag;
                      offset += size;
                    });
                    util.each(params.PartList, function(PartItem) {
                      var ETag = finishETagMap[PartItem.PartNumber + "|" + PartItem.start + "|" + PartItem.end];
                      if (ETag) {
                        PartItem.ETag = ETag;
                        PartItem.Uploaded = true;
                      }
                    });
                    ep.emit("get_copy_data_finish", {
                      UploadId,
                      PartList: params.PartList
                    });
                  }
                });
              };
              next(0);
            });
            ep.on("get_file_size_finish", function() {
              (function() {
                var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
                var AutoChunkSize = 1024 * 1024;
                for (var i = 0; i < SIZE.length; i++) {
                  AutoChunkSize = SIZE[i] * 1024 * 1024;
                  if (FileSize / AutoChunkSize <= self2.options.MaxPartNumber)
                    break;
                }
                params.ChunkSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
                ChunkCount = Math.ceil(FileSize / ChunkSize);
                var list = [];
                for (var partNumber = 1; partNumber <= ChunkCount; partNumber++) {
                  var start = (partNumber - 1) * ChunkSize;
                  var end = partNumber * ChunkSize < FileSize ? partNumber * ChunkSize - 1 : FileSize - 1;
                  var item = {
                    PartNumber: partNumber,
                    start,
                    end,
                    CopySourceRange: "bytes=" + start + "-" + end
                  };
                  list.push(item);
                }
                params.PartList = list;
              })();
              if (params.Headers["x-cos-metadata-directive"] === "Replaced") {
                TargetHeader = params.Headers;
              } else {
                TargetHeader = SourceHeaders;
              }
              TargetHeader["x-cos-storage-class"] = params.Headers["x-cos-storage-class"] || SourceHeaders["x-cos-storage-class"];
              TargetHeader = util.clearKey(TargetHeader);
              if (SourceHeaders["x-cos-storage-class"] === "ARCHIVE" || SourceHeaders["x-cos-storage-class"] === "DEEP_ARCHIVE") {
                var restoreHeader = SourceHeaders["x-cos-restore"];
                if (!restoreHeader || restoreHeader === 'ongoing-request="true"') {
                  callback(util.error(new Error("Unrestored archive object is not allowed to be copied")));
                  return;
                }
              }
              delete TargetHeader["x-cos-copy-source"];
              delete TargetHeader["x-cos-metadata-directive"];
              delete TargetHeader["x-cos-copy-source-If-Modified-Since"];
              delete TargetHeader["x-cos-copy-source-If-Unmodified-Since"];
              delete TargetHeader["x-cos-copy-source-If-Match"];
              delete TargetHeader["x-cos-copy-source-If-None-Match"];
              ep.emit("get_chunk_size_finish");
            });
            self2.headObject({
              Bucket: SourceBucket,
              Region: SourceRegion,
              Key: SourceKey
            }, function(err, data) {
              if (err) {
                if (err.statusCode && err.statusCode === 404) {
                  callback(util.error(err, {
                    ErrorStatus: SourceKey + " Not Exist"
                  }));
                } else {
                  callback(err);
                }
                return;
              }
              FileSize = params.FileSize = data.headers["content-length"];
              if (FileSize === void 0 || !FileSize) {
                callback(util.error(new Error('get Content-Length error, please add "Content-Length" to CORS ExposeHeader setting.\uFF08 \u83B7\u53D6Content-Length\u5931\u8D25\uFF0C\u8BF7\u5728CORS ExposeHeader\u8BBE\u7F6E\u4E2D\u6DFB\u52A0Content-Length\uFF0C\u8BF7\u53C2\u8003\u6587\u6863\uFF1Ahttps://cloud.tencent.com/document/product/436/13318 \uFF09')));
                return;
              }
              onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
              if (FileSize <= CopySliceSize) {
                if (!params.Headers["x-cos-metadata-directive"]) {
                  params.Headers["x-cos-metadata-directive"] = "Copy";
                }
                self2.putObjectCopy(params, function(err2, data2) {
                  if (err2) {
                    onProgress(null, true);
                    return callback(err2);
                  }
                  onProgress({
                    loaded: FileSize,
                    total: FileSize
                  }, true);
                  callback(err2, data2);
                });
              } else {
                var resHeaders = data.headers;
                SourceResHeaders = resHeaders;
                SourceHeaders = {
                  "Cache-Control": resHeaders["cache-control"],
                  "Content-Disposition": resHeaders["content-disposition"],
                  "Content-Encoding": resHeaders["content-encoding"],
                  "Content-Type": resHeaders["content-type"],
                  "Expires": resHeaders["expires"],
                  "x-cos-storage-class": resHeaders["x-cos-storage-class"]
                };
                util.each(resHeaders, function(v, k) {
                  var metaPrefix = "x-cos-meta-";
                  if (k.indexOf(metaPrefix) === 0 && k.length > metaPrefix.length) {
                    SourceHeaders[k] = v;
                  }
                });
                ep.emit("get_file_size_finish");
              }
            });
          }
          function copySliceItem(params, callback) {
            var TaskId = params.TaskId;
            var Bucket = params.Bucket;
            var Region = params.Region;
            var Key = params.Key;
            var CopySource = params.CopySource;
            var UploadId = params.UploadId;
            var PartNumber = params.PartNumber * 1;
            var CopySourceRange = params.CopySourceRange;
            var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
            var self2 = this;
            Async.retry(ChunkRetryTimes, function(tryCallback) {
              self2.uploadPartCopy({
                TaskId,
                Bucket,
                Region,
                Key,
                CopySource,
                UploadId,
                PartNumber,
                CopySourceRange
              }, function(err, data) {
                tryCallback(err || null, data);
              });
            }, function(err, data) {
              return callback(err, data);
            });
          }
          var API_MAP = {
            sliceUploadFile,
            abortUploadTask,
            uploadFile,
            uploadFiles,
            sliceCopyFile
          };
          module2.exports.init = function(COS, task) {
            task.transferToTaskMethod(API_MAP, "sliceUploadFile");
            util.each(API_MAP, function(fn, apiName) {
              COS.prototype[apiName] = util.apiWrapper(apiName, fn);
            });
          };
        },
        "./src/async.js": function(module2, exports2) {
          var eachLimit = function eachLimit2(arr, limit, iterator, callback) {
            callback = callback || function() {
            };
            if (!arr.length || limit <= 0) {
              return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;
            (function replenish() {
              if (completed >= arr.length) {
                return callback();
              }
              while (running < limit && started < arr.length) {
                started += 1;
                running += 1;
                iterator(arr[started - 1], function(err) {
                  if (err) {
                    callback(err);
                    callback = function callback2() {
                    };
                  } else {
                    completed += 1;
                    running -= 1;
                    if (completed >= arr.length) {
                      callback();
                    } else {
                      replenish();
                    }
                  }
                });
              }
            })();
          };
          var retry = function retry2(times, iterator, callback) {
            var next = function next2(index) {
              iterator(function(err, data) {
                if (err && index < times) {
                  next2(index + 1);
                } else {
                  callback(err, data);
                }
              });
            };
            if (times < 1) {
              callback();
            } else {
              next(1);
            }
          };
          var async = {
            eachLimit,
            retry
          };
          module2.exports = async;
        },
        "./src/base.js": function(module2, exports2, __webpack_require__2) {
          var REQUEST = __webpack_require__2("./lib/request.js");
          var util = __webpack_require__2("./src/util.js");
          function getService(params, callback) {
            if (typeof params === "function") {
              callback = params;
              params = {};
            }
            var protocol = this.options.Protocol || (util.isBrowser && location.protocol === "http:" ? "http:" : "https:");
            var domain = this.options.ServiceDomain;
            var appId = params.AppId || this.options.appId;
            var region = params.Region;
            if (domain) {
              domain = domain.replace(/\{\{AppId\}\}/ig, appId || "").replace(/\{\{Region\}\}/ig, region || "").replace(/\{\{.*?\}\}/ig, "");
              if (!/^[a-zA-Z]+:\/\//.test(domain)) {
                domain = protocol + "//" + domain;
              }
              if (domain.slice(-1) === "/") {
                domain = domain.slice(0, -1);
              }
            } else if (region) {
              domain = protocol + "//cos." + region + ".myqcloud.com";
            } else {
              domain = protocol + "//service.cos.myqcloud.com";
            }
            var SignHost = "";
            var standardHost = region ? "cos." + region + ".myqcloud.com" : "service.cos.myqcloud.com";
            var urlHost = domain.replace(/^https?:\/\/([^/]+)(\/.*)?$/, "$1");
            if (standardHost === urlHost)
              SignHost = standardHost;
            submitRequest.call(this, {
              Action: "name/cos:GetService",
              url: domain,
              method: "GET",
              headers: params.Headers,
              SignHost
            }, function(err, data) {
              if (err)
                return callback(err);
              var buckets = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Buckets && data.ListAllMyBucketsResult.Buckets.Bucket || [];
              buckets = util.isArray(buckets) ? buckets : [buckets];
              var owner = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Owner || {};
              callback(null, {
                Buckets: buckets,
                Owner: owner,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucket(params, callback) {
            var self2 = this;
            var xml = "";
            if (params["BucketAZConfig"]) {
              var CreateBucketConfiguration = {
                BucketAZConfig: params.BucketAZConfig
              };
              xml = util.json2xml({
                CreateBucketConfiguration
              });
            }
            submitRequest.call(this, {
              Action: "name/cos:PutBucket",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              body: xml
            }, function(err, data) {
              if (err)
                return callback(err);
              var url = getUrl({
                protocol: self2.options.Protocol,
                domain: self2.options.Domain,
                bucket: params.Bucket,
                region: params.Region,
                isLocation: true
              });
              callback(null, {
                Location: url,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function headBucket(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:HeadBucket",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              method: "HEAD"
            }, callback);
          }
          function getBucket(params, callback) {
            var reqParams = {};
            reqParams["prefix"] = params["Prefix"] || "";
            reqParams["delimiter"] = params["Delimiter"];
            reqParams["marker"] = params["Marker"];
            reqParams["max-keys"] = params["MaxKeys"];
            reqParams["encoding-type"] = params["EncodingType"];
            submitRequest.call(this, {
              Action: "name/cos:GetBucket",
              ResourceKey: reqParams["prefix"],
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              qs: reqParams
            }, function(err, data) {
              if (err)
                return callback(err);
              var ListBucketResult = data.ListBucketResult || {};
              var Contents = ListBucketResult.Contents || [];
              var CommonPrefixes = ListBucketResult.CommonPrefixes || [];
              Contents = util.isArray(Contents) ? Contents : [Contents];
              CommonPrefixes = util.isArray(CommonPrefixes) ? CommonPrefixes : [CommonPrefixes];
              var result = util.clone(ListBucketResult);
              util.extend(result, {
                Contents,
                CommonPrefixes,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function deleteBucket(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucket",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              method: "DELETE"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketAcl(params, callback) {
            var headers = params.Headers;
            var xml = "";
            if (params["AccessControlPolicy"]) {
              var AccessControlPolicy = util.clone(params["AccessControlPolicy"] || {});
              var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
              Grants = util.isArray(Grants) ? Grants : [Grants];
              delete AccessControlPolicy.Grant;
              delete AccessControlPolicy.Grants;
              AccessControlPolicy.AccessControlList = {
                Grant: Grants
              };
              xml = util.json2xml({
                AccessControlPolicy
              });
              headers["Content-Type"] = "application/xml";
              headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            }
            util.each(headers, function(val, key) {
              if (key.indexOf("x-cos-grant-") === 0) {
                headers[key] = uniqGrant(headers[key]);
              }
            });
            submitRequest.call(this, {
              Action: "name/cos:PutBucketACL",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              headers,
              action: "acl",
              body: xml
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketAcl(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketACL",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "acl"
            }, function(err, data) {
              if (err)
                return callback(err);
              var AccessControlPolicy = data.AccessControlPolicy || {};
              var Owner = AccessControlPolicy.Owner || {};
              var Grant = AccessControlPolicy.AccessControlList.Grant || [];
              Grant = util.isArray(Grant) ? Grant : [Grant];
              var result = decodeAcl(AccessControlPolicy);
              if (data.headers && data.headers["x-cos-acl"]) {
                result.ACL = data.headers["x-cos-acl"];
              }
              result = util.extend(result, {
                Owner,
                Grants: Grant,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function putBucketCors(params, callback) {
            var CORSConfiguration = params["CORSConfiguration"] || {};
            var CORSRules = CORSConfiguration["CORSRules"] || params["CORSRules"] || [];
            CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
            util.each(CORSRules, function(rule) {
              util.each(["AllowedOrigin", "AllowedHeader", "AllowedMethod", "ExposeHeader"], function(key) {
                var sKey = key + "s";
                var val = rule[sKey] || rule[key] || [];
                delete rule[sKey];
                rule[key] = util.isArray(val) ? val : [val];
              });
            });
            var Conf = {
              CORSRule: CORSRules
            };
            if (params.ResponseVary)
              Conf.ResponseVary = params.ResponseVary;
            var xml = util.json2xml({
              CORSConfiguration: Conf
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketCORS",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "cors",
              headers
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketCors(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketCORS",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "cors"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error && err.error.Code === "NoSuchCORSConfiguration") {
                  var result = {
                    CORSRules: [],
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var CORSConfiguration = data.CORSConfiguration || {};
              var CORSRules = CORSConfiguration.CORSRules || CORSConfiguration.CORSRule || [];
              CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
              var ResponseVary = CORSConfiguration.ResponseVary;
              util.each(CORSRules, function(rule) {
                util.each(["AllowedOrigin", "AllowedHeader", "AllowedMethod", "ExposeHeader"], function(key) {
                  var sKey = key + "s";
                  var val = rule[sKey] || rule[key] || [];
                  delete rule[key];
                  rule[sKey] = util.isArray(val) ? val : [val];
                });
              });
              callback(null, {
                CORSRules,
                ResponseVary,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketCors(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketCORS",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "cors"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode || err.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketLocation(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketLocation",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "location"
            }, callback);
          }
          function putBucketPolicy(params, callback) {
            var Policy = params["Policy"];
            try {
              if (typeof Policy === "string")
                Policy = JSON.parse(Policy);
            } catch (e) {
            }
            if (!Policy || typeof Policy === "string")
              return callback(util.error(new Error("Policy format error")));
            var PolicyStr = JSON.stringify(Policy);
            if (!Policy.version)
              Policy.version = "2.0";
            var headers = params.Headers;
            headers["Content-Type"] = "application/json";
            headers["Content-MD5"] = util.binaryBase64(util.md5(PolicyStr));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketPolicy",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              action: "policy",
              body: PolicyStr,
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketPolicy(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketPolicy",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "policy",
              rawBody: true
            }, function(err, data) {
              if (err) {
                if (err.statusCode && err.statusCode === 403) {
                  return callback(util.error(err, {
                    ErrorStatus: "Access Denied"
                  }));
                }
                if (err.statusCode && err.statusCode === 405) {
                  return callback(util.error(err, {
                    ErrorStatus: "Method Not Allowed"
                  }));
                }
                if (err.statusCode && err.statusCode === 404) {
                  return callback(util.error(err, {
                    ErrorStatus: "Policy Not Found"
                  }));
                }
                return callback(err);
              }
              var Policy = {};
              try {
                Policy = JSON.parse(data.body);
              } catch (e) {
              }
              callback(null, {
                Policy,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketPolicy(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketPolicy",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "policy"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode || err.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketTagging(params, callback) {
            var Tagging = params["Tagging"] || {};
            var Tags = Tagging.TagSet || Tagging.Tags || params["Tags"] || [];
            Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
            var xml = util.json2xml({
              Tagging: {
                TagSet: {
                  Tag: Tags
                }
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketTagging",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "tagging",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketTagging(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketTagging",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "tagging"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "NoSuchTagSet")) {
                  var result = {
                    Tags: [],
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var Tags = [];
              try {
                Tags = data.Tagging.TagSet.Tag || [];
              } catch (e) {
              }
              Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
              callback(null, {
                Tags,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketTagging(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketTagging",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "tagging"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketLifecycle(params, callback) {
            var LifecycleConfiguration = params["LifecycleConfiguration"] || {};
            var Rules = LifecycleConfiguration.Rules || params.Rules || [];
            Rules = util.clone(Rules);
            var xml = util.json2xml({
              LifecycleConfiguration: {
                Rule: Rules
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketLifecycle",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "lifecycle",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketLifecycle(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketLifecycle",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "lifecycle"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error && err.error.Code === "NoSuchLifecycleConfiguration") {
                  var result = {
                    Rules: [],
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var Rules = [];
              try {
                Rules = data.LifecycleConfiguration.Rule || [];
              } catch (e) {
              }
              Rules = util.clone(util.isArray(Rules) ? Rules : [Rules]);
              callback(null, {
                Rules,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketLifecycle(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketLifecycle",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "lifecycle"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketVersioning(params, callback) {
            if (!params["VersioningConfiguration"]) {
              callback(util.error(new Error("missing param VersioningConfiguration")));
              return;
            }
            var VersioningConfiguration = params["VersioningConfiguration"] || {};
            var xml = util.json2xml({
              VersioningConfiguration
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketVersioning",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "versioning",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketVersioning(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketVersioning",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "versioning"
            }, function(err, data) {
              if (!err) {
                !data.VersioningConfiguration && (data.VersioningConfiguration = {});
              }
              callback(err, data);
            });
          }
          function putBucketReplication(params, callback) {
            var ReplicationConfiguration = util.clone(params.ReplicationConfiguration);
            var xml = util.json2xml({
              ReplicationConfiguration
            });
            xml = xml.replace(/<(\/?)Rules>/ig, "<$1Rule>");
            xml = xml.replace(/<(\/?)Tags>/ig, "<$1Tag>");
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketReplication",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "replication",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketReplication(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketReplication",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "replication"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "ReplicationConfigurationnotFoundError")) {
                  var result = {
                    ReplicationConfiguration: {
                      Rules: []
                    },
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              !data.ReplicationConfiguration && (data.ReplicationConfiguration = {});
              if (data.ReplicationConfiguration.Rule) {
                data.ReplicationConfiguration.Rules = util.makeArray(data.ReplicationConfiguration.Rule);
                delete data.ReplicationConfiguration.Rule;
              }
              callback(err, data);
            });
          }
          function deleteBucketReplication(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketReplication",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "replication"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketWebsite(params, callback) {
            if (!params["WebsiteConfiguration"]) {
              callback(util.error(new Error("missing param WebsiteConfiguration")));
              return;
            }
            var WebsiteConfiguration = util.clone(params["WebsiteConfiguration"] || {});
            var RoutingRules = WebsiteConfiguration["RoutingRules"] || WebsiteConfiguration["RoutingRule"] || [];
            RoutingRules = util.isArray(RoutingRules) ? RoutingRules : [RoutingRules];
            delete WebsiteConfiguration.RoutingRule;
            delete WebsiteConfiguration.RoutingRules;
            if (RoutingRules.length)
              WebsiteConfiguration.RoutingRules = {
                RoutingRule: RoutingRules
              };
            var xml = util.json2xml({
              WebsiteConfiguration
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketWebsite",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "website",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketWebsite(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketWebsite",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              action: "website"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error.Code === "NoSuchWebsiteConfiguration") {
                  var result = {
                    WebsiteConfiguration: {},
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var WebsiteConfiguration = data.WebsiteConfiguration || {};
              if (WebsiteConfiguration["RoutingRules"]) {
                var RoutingRules = util.clone(WebsiteConfiguration["RoutingRules"].RoutingRule || []);
                RoutingRules = util.makeArray(RoutingRules);
                WebsiteConfiguration.RoutingRules = RoutingRules;
              }
              callback(null, {
                WebsiteConfiguration,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketWebsite(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketWebsite",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "website"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketReferer(params, callback) {
            if (!params["RefererConfiguration"]) {
              callback(util.error(new Error("missing param RefererConfiguration")));
              return;
            }
            var RefererConfiguration = util.clone(params["RefererConfiguration"] || {});
            var DomainList = RefererConfiguration["DomainList"] || {};
            var Domains = DomainList["Domains"] || DomainList["Domain"] || [];
            Domains = util.isArray(Domains) ? Domains : [Domains];
            if (Domains.length)
              RefererConfiguration.DomainList = {
                Domain: Domains
              };
            var xml = util.json2xml({
              RefererConfiguration
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketReferer",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "referer",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketReferer(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketReferer",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              action: "referer"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error.Code === "NoSuchRefererConfiguration") {
                  var result = {
                    WebsiteConfiguration: {},
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var RefererConfiguration = data.RefererConfiguration || {};
              if (RefererConfiguration["DomainList"]) {
                var Domains = util.makeArray(RefererConfiguration["DomainList"].Domain || []);
                RefererConfiguration.DomainList = {
                  Domains
                };
              }
              callback(null, {
                RefererConfiguration,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketDomain(params, callback) {
            var DomainConfiguration = params["DomainConfiguration"] || {};
            var DomainRule = DomainConfiguration.DomainRule || params.DomainRule || [];
            DomainRule = util.clone(DomainRule);
            var xml = util.json2xml({
              DomainConfiguration: {
                DomainRule
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketDomain",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "domain",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketDomain(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketDomain",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "domain"
            }, function(err, data) {
              if (err)
                return callback(err);
              var DomainRule = [];
              try {
                DomainRule = data.DomainConfiguration.DomainRule || [];
              } catch (e) {
              }
              DomainRule = util.clone(util.isArray(DomainRule) ? DomainRule : [DomainRule]);
              callback(null, {
                DomainRule,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketDomain(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketDomain",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "domain"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketOrigin(params, callback) {
            var OriginConfiguration = params["OriginConfiguration"] || {};
            var OriginRule = OriginConfiguration.OriginRule || params.OriginRule || [];
            OriginRule = util.clone(OriginRule);
            var xml = util.json2xml({
              OriginConfiguration: {
                OriginRule
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketOrigin",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "origin",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketOrigin(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketOrigin",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "origin"
            }, function(err, data) {
              if (err)
                return callback(err);
              var OriginRule = [];
              try {
                OriginRule = data.OriginConfiguration.OriginRule || [];
              } catch (e) {
              }
              OriginRule = util.clone(util.isArray(OriginRule) ? OriginRule : [OriginRule]);
              callback(null, {
                OriginRule,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteBucketOrigin(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketOrigin",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "origin"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketLogging(params, callback) {
            var xml = util.json2xml({
              BucketLoggingStatus: params["BucketLoggingStatus"] || ""
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketLogging",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "logging",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketLogging(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketLogging",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "logging"
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, {
                BucketLoggingStatus: data.BucketLoggingStatus,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketInventory(params, callback) {
            var InventoryConfiguration = util.clone(params["InventoryConfiguration"]);
            if (InventoryConfiguration.OptionalFields) {
              var Field = InventoryConfiguration.OptionalFields || [];
              InventoryConfiguration.OptionalFields = {
                Field
              };
            }
            if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
              var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
              if (Object.keys(Encryption).indexOf("SSECOS") > -1) {
                Encryption["SSE-COS"] = Encryption["SSECOS"];
                delete Encryption["SSECOS"];
              }
            }
            var xml = util.json2xml({
              InventoryConfiguration
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketInventory",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "inventory",
              qs: {
                id: params["Id"]
              },
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketInventory(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketInventory",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "inventory",
              qs: {
                id: params["Id"]
              }
            }, function(err, data) {
              if (err)
                return callback(err);
              var InventoryConfiguration = data["InventoryConfiguration"];
              if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
                var Field = InventoryConfiguration.OptionalFields.Field;
                if (!util.isArray(Field)) {
                  Field = [Field];
                }
                InventoryConfiguration.OptionalFields = Field;
              }
              if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
                var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
                if (Object.keys(Encryption).indexOf("SSE-COS") > -1) {
                  Encryption["SSECOS"] = Encryption["SSE-COS"];
                  delete Encryption["SSE-COS"];
                }
              }
              callback(null, {
                InventoryConfiguration,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function listBucketInventory(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:ListBucketInventory",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "inventory",
              qs: {
                "continuation-token": params["ContinuationToken"]
              }
            }, function(err, data) {
              if (err)
                return callback(err);
              var ListInventoryConfigurationResult = data["ListInventoryConfigurationResult"];
              var InventoryConfigurations = ListInventoryConfigurationResult.InventoryConfiguration || [];
              InventoryConfigurations = util.isArray(InventoryConfigurations) ? InventoryConfigurations : [InventoryConfigurations];
              delete ListInventoryConfigurationResult["InventoryConfiguration"];
              util.each(InventoryConfigurations, function(InventoryConfiguration) {
                if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
                  var Field = InventoryConfiguration.OptionalFields.Field;
                  if (!util.isArray(Field)) {
                    Field = [Field];
                  }
                  InventoryConfiguration.OptionalFields = Field;
                }
                if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
                  var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
                  if (Object.keys(Encryption).indexOf("SSE-COS") > -1) {
                    Encryption["SSECOS"] = Encryption["SSE-COS"];
                    delete Encryption["SSE-COS"];
                  }
                }
              });
              ListInventoryConfigurationResult.InventoryConfigurations = InventoryConfigurations;
              util.extend(ListInventoryConfigurationResult, {
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, ListInventoryConfigurationResult);
            });
          }
          function deleteBucketInventory(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketInventory",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "inventory",
              qs: {
                id: params["Id"]
              }
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putBucketAccelerate(params, callback) {
            if (!params["AccelerateConfiguration"]) {
              callback(util.error(new Error("missing param AccelerateConfiguration")));
              return;
            }
            var configuration = {
              AccelerateConfiguration: params.AccelerateConfiguration || {}
            };
            var xml = util.json2xml(configuration);
            var headers = {};
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketAccelerate",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "accelerate",
              headers
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketAccelerate(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketAccelerate",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              action: "accelerate"
            }, function(err, data) {
              if (!err) {
                !data.AccelerateConfiguration && (data.AccelerateConfiguration = {});
              }
              callback(err, data);
            });
          }
          function putBucketEncryption(params, callback) {
            var conf = params.ServerSideEncryptionConfiguration || {};
            var Rules = conf.Rule || conf.Rules || [];
            var xml = util.json2xml({
              ServerSideEncryptionConfiguration: {
                Rule: Rules
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutBucketEncryption",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "encryption",
              headers
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getBucketEncryption(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetBucketEncryption",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "encryption"
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.code === "NoSuchEncryptionConfiguration") {
                  var result = {
                    EncryptionConfiguration: {
                      Rules: []
                    },
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var Rules = util.makeArray(data.EncryptionConfiguration && data.EncryptionConfiguration.Rule || []);
              data.EncryptionConfiguration = {
                Rules
              };
              callback(err, data);
            });
          }
          function deleteBucketEncryption(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteBucketReplication",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "encryption"
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function headObject(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:HeadObject",
              method: "HEAD",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              VersionId: params.VersionId,
              headers: params.Headers
            }, function(err, data) {
              if (err) {
                var statusCode = err.statusCode;
                if (params.Headers["If-Modified-Since"] && statusCode && statusCode === 304) {
                  return callback(null, {
                    NotModified: true,
                    statusCode
                  });
                }
                return callback(err);
              }
              data.ETag = util.attr(data.headers, "etag", "");
              callback(null, data);
            });
          }
          function listObjectVersions(params, callback) {
            var reqParams = {};
            reqParams["prefix"] = params["Prefix"] || "";
            reqParams["delimiter"] = params["Delimiter"];
            reqParams["key-marker"] = params["KeyMarker"];
            reqParams["version-id-marker"] = params["VersionIdMarker"];
            reqParams["max-keys"] = params["MaxKeys"];
            reqParams["encoding-type"] = params["EncodingType"];
            submitRequest.call(this, {
              Action: "name/cos:GetBucketObjectVersions",
              ResourceKey: reqParams["prefix"],
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              qs: reqParams,
              action: "versions"
            }, function(err, data) {
              if (err)
                return callback(err);
              var ListVersionsResult = data.ListVersionsResult || {};
              var DeleteMarkers = ListVersionsResult.DeleteMarker || [];
              DeleteMarkers = util.isArray(DeleteMarkers) ? DeleteMarkers : [DeleteMarkers];
              var Versions = ListVersionsResult.Version || [];
              Versions = util.isArray(Versions) ? Versions : [Versions];
              var result = util.clone(ListVersionsResult);
              delete result.DeleteMarker;
              delete result.Version;
              util.extend(result, {
                DeleteMarkers,
                Versions,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function getObject(params, callback) {
            var reqParams = params.Query || {};
            var reqParamsStr = params.QueryString || "";
            var onProgress = util.throttleOnProgress.call(this, 0, params.onProgress);
            var tracker = params.tracker;
            tracker && tracker.setParams({
              signStartTime: new Date().getTime()
            });
            reqParams["response-content-type"] = params["ResponseContentType"];
            reqParams["response-content-language"] = params["ResponseContentLanguage"];
            reqParams["response-expires"] = params["ResponseExpires"];
            reqParams["response-cache-control"] = params["ResponseCacheControl"];
            reqParams["response-content-disposition"] = params["ResponseContentDisposition"];
            reqParams["response-content-encoding"] = params["ResponseContentEncoding"];
            submitRequest.call(this, {
              Action: "name/cos:GetObject",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              VersionId: params.VersionId,
              DataType: params.DataType,
              headers: params.Headers,
              qs: reqParams,
              qsStr: reqParamsStr,
              rawBody: true,
              onDownloadProgress: onProgress,
              tracker
            }, function(err, data) {
              onProgress(null, true);
              if (err) {
                var statusCode = err.statusCode;
                if (params.Headers["If-Modified-Since"] && statusCode && statusCode === 304) {
                  return callback(null, {
                    NotModified: true
                  });
                }
                return callback(err);
              }
              callback(null, {
                Body: data.body,
                ETag: util.attr(data.headers, "etag", ""),
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putObject(params, callback) {
            var self2 = this;
            var FileSize = params.ContentLength;
            var onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
            var headers = params.Headers;
            if (!headers["Cache-Control"] && !headers["cache-control"])
              headers["Cache-Control"] = "";
            if (!headers["Content-Type"] && !headers["content-type"])
              headers["Content-Type"] = params.Body && params.Body.type || "";
            var needCalcMd5 = params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5 || self2.options.UploadCheckContentMd5;
            var tracker = params.tracker;
            needCalcMd5 && tracker && tracker.setParams({
              md5StartTime: new Date().getTime()
            });
            util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
              if (md5) {
                tracker && tracker.setParams({
                  md5EndTime: new Date().getTime()
                });
                if (self2.options.UploadCheckContentMd5)
                  headers["Content-MD5"] = util.binaryBase64(md5);
                if (params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5)
                  headers["x-cos-meta-md5"] = md5;
              }
              if (params.ContentLength !== void 0)
                headers["Content-Length"] = params.ContentLength;
              onProgress(null, true);
              submitRequest.call(self2, {
                Action: "name/cos:PutObject",
                TaskId: params.TaskId,
                method: "PUT",
                Bucket: params.Bucket,
                Region: params.Region,
                Key: params.Key,
                headers: params.Headers,
                qs: params.Query,
                body: params.Body,
                onProgress,
                tracker
              }, function(err, data) {
                if (err) {
                  onProgress(null, true);
                  return callback(err);
                }
                onProgress({
                  loaded: FileSize,
                  total: FileSize
                }, true);
                var url = getUrl({
                  ForcePathStyle: self2.options.ForcePathStyle,
                  protocol: self2.options.Protocol,
                  domain: self2.options.Domain,
                  bucket: params.Bucket,
                  region: !self2.options.UseAccelerate ? params.Region : "accelerate",
                  object: params.Key
                });
                url = url.substr(url.indexOf("://") + 3);
                data.Location = url;
                data.ETag = util.attr(data.headers, "etag", "");
                callback(null, data);
              });
            }, params.onHashProgress);
          }
          function deleteObject(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteObject",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              VersionId: params.VersionId,
              action: params.Recursive ? "recursive" : ""
            }, function(err, data) {
              if (err) {
                var statusCode = err.statusCode;
                if (statusCode && statusCode === 404) {
                  return callback(null, {
                    BucketNotFound: true,
                    statusCode
                  });
                } else {
                  return callback(err);
                }
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getObjectAcl(params, callback) {
            var reqParams = {};
            if (params.VersionId) {
              reqParams.versionId = params.VersionId;
            }
            submitRequest.call(this, {
              Action: "name/cos:GetObjectACL",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              qs: reqParams,
              action: "acl"
            }, function(err, data) {
              if (err)
                return callback(err);
              var AccessControlPolicy = data.AccessControlPolicy || {};
              var Owner = AccessControlPolicy.Owner || {};
              var Grant = AccessControlPolicy.AccessControlList && AccessControlPolicy.AccessControlList.Grant || [];
              Grant = util.isArray(Grant) ? Grant : [Grant];
              var result = decodeAcl(AccessControlPolicy);
              delete result.GrantWrite;
              if (data.headers && data.headers["x-cos-acl"]) {
                result.ACL = data.headers["x-cos-acl"];
              }
              result = util.extend(result, {
                Owner,
                Grants: Grant,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function putObjectAcl(params, callback) {
            var headers = params.Headers;
            var xml = "";
            if (params["AccessControlPolicy"]) {
              var AccessControlPolicy = util.clone(params["AccessControlPolicy"] || {});
              var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
              Grants = util.isArray(Grants) ? Grants : [Grants];
              delete AccessControlPolicy.Grant;
              delete AccessControlPolicy.Grants;
              AccessControlPolicy.AccessControlList = {
                Grant: Grants
              };
              xml = util.json2xml({
                AccessControlPolicy
              });
              headers["Content-Type"] = "application/xml";
              headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            }
            util.each(headers, function(val, key) {
              if (key.indexOf("x-cos-grant-") === 0) {
                headers[key] = uniqGrant(headers[key]);
              }
            });
            submitRequest.call(this, {
              Action: "name/cos:PutObjectACL",
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              action: "acl",
              headers,
              body: xml
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function optionsObject(params, callback) {
            var headers = params.Headers;
            headers["Origin"] = params["Origin"];
            headers["Access-Control-Request-Method"] = params["AccessControlRequestMethod"];
            headers["Access-Control-Request-Headers"] = params["AccessControlRequestHeaders"];
            submitRequest.call(this, {
              Action: "name/cos:OptionsObject",
              method: "OPTIONS",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers
            }, function(err, data) {
              if (err) {
                if (err.statusCode && err.statusCode === 403) {
                  return callback(null, {
                    OptionsForbidden: true,
                    statusCode: err.statusCode
                  });
                }
                return callback(err);
              }
              var headers2 = data.headers || {};
              callback(null, {
                AccessControlAllowOrigin: headers2["access-control-allow-origin"],
                AccessControlAllowMethods: headers2["access-control-allow-methods"],
                AccessControlAllowHeaders: headers2["access-control-allow-headers"],
                AccessControlExposeHeaders: headers2["access-control-expose-headers"],
                AccessControlMaxAge: headers2["access-control-max-age"],
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function putObjectCopy(params, callback) {
            var self2 = this;
            var headers = params.Headers;
            if (!headers["Cache-Control"] && !headers["cache-control"])
              headers["Cache-Control"] = "";
            var CopySource = params.CopySource || "";
            var m = util.getSourceParams.call(this, CopySource);
            if (!m) {
              callback(util.error(new Error("CopySource format error")));
              return;
            }
            var SourceBucket = m.Bucket;
            var SourceRegion = m.Region;
            var SourceKey = decodeURIComponent(m.Key);
            submitRequest.call(this, {
              Scope: [{
                action: "name/cos:GetObject",
                bucket: SourceBucket,
                region: SourceRegion,
                prefix: SourceKey
              }, {
                action: "name/cos:PutObject",
                bucket: params.Bucket,
                region: params.Region,
                prefix: params.Key
              }],
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              VersionId: params.VersionId,
              headers: params.Headers
            }, function(err, data) {
              if (err)
                return callback(err);
              var result = util.clone(data.CopyObjectResult || {});
              var url = getUrl({
                ForcePathStyle: self2.options.ForcePathStyle,
                protocol: self2.options.Protocol,
                domain: self2.options.Domain,
                bucket: params.Bucket,
                region: params.Region,
                object: params.Key,
                isLocation: true
              });
              util.extend(result, {
                Location: url,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function uploadPartCopy(params, callback) {
            var CopySource = params.CopySource || "";
            var m = util.getSourceParams.call(this, CopySource);
            if (!m) {
              callback(util.error(new Error("CopySource format error")));
              return;
            }
            var SourceBucket = m.Bucket;
            var SourceRegion = m.Region;
            var SourceKey = decodeURIComponent(m.Key);
            submitRequest.call(this, {
              Scope: [{
                action: "name/cos:GetObject",
                bucket: SourceBucket,
                region: SourceRegion,
                prefix: SourceKey
              }, {
                action: "name/cos:PutObject",
                bucket: params.Bucket,
                region: params.Region,
                prefix: params.Key
              }],
              method: "PUT",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              VersionId: params.VersionId,
              qs: {
                partNumber: params["PartNumber"],
                uploadId: params["UploadId"]
              },
              headers: params.Headers
            }, function(err, data) {
              if (err)
                return callback(err);
              var result = util.clone(data.CopyPartResult || {});
              util.extend(result, {
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function deleteMultipleObject(params, callback) {
            var Objects = params.Objects || [];
            var Quiet = params.Quiet;
            Objects = util.isArray(Objects) ? Objects : [Objects];
            var xml = util.json2xml({
              Delete: {
                Object: Objects,
                Quiet: Quiet || false
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            var Scope = util.map(Objects, function(v) {
              return {
                action: "name/cos:DeleteObject",
                bucket: params.Bucket,
                region: params.Region,
                prefix: v.Key
              };
            });
            submitRequest.call(this, {
              Scope,
              method: "POST",
              Bucket: params.Bucket,
              Region: params.Region,
              body: xml,
              action: "delete",
              headers
            }, function(err, data) {
              if (err)
                return callback(err);
              var DeleteResult = data.DeleteResult || {};
              var Deleted = DeleteResult.Deleted || [];
              var Errors = DeleteResult.Error || [];
              Deleted = util.isArray(Deleted) ? Deleted : [Deleted];
              Errors = util.isArray(Errors) ? Errors : [Errors];
              var result = util.clone(DeleteResult);
              util.extend(result, {
                Error: Errors,
                Deleted,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function restoreObject(params, callback) {
            var headers = params.Headers;
            if (!params["RestoreRequest"]) {
              callback(util.error(new Error("missing param RestoreRequest")));
              return;
            }
            var RestoreRequest = params.RestoreRequest || {};
            var xml = util.json2xml({
              RestoreRequest
            });
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:RestoreObject",
              method: "POST",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              VersionId: params.VersionId,
              body: xml,
              action: "restore",
              headers
            }, callback);
          }
          function putObjectTagging(params, callback) {
            var Tagging = params["Tagging"] || {};
            var Tags = Tagging.TagSet || Tagging.Tags || params["Tags"] || [];
            Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
            var xml = util.json2xml({
              Tagging: {
                TagSet: {
                  Tag: Tags
                }
              }
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:PutObjectTagging",
              method: "PUT",
              Bucket: params.Bucket,
              Key: params.Key,
              Region: params.Region,
              body: xml,
              action: "tagging",
              headers,
              VersionId: params.VersionId
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function getObjectTagging(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:GetObjectTagging",
              method: "GET",
              Key: params.Key,
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              action: "tagging",
              VersionId: params.VersionId
            }, function(err, data) {
              if (err) {
                if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "NoSuchTagSet")) {
                  var result = {
                    Tags: [],
                    statusCode: err.statusCode
                  };
                  err.headers && (result.headers = err.headers);
                  callback(null, result);
                } else {
                  callback(err);
                }
                return;
              }
              var Tags = [];
              try {
                Tags = data.Tagging.TagSet.Tag || [];
              } catch (e) {
              }
              Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
              callback(null, {
                Tags,
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function deleteObjectTagging(params, callback) {
            submitRequest.call(this, {
              Action: "name/cos:DeleteObjectTagging",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              action: "tagging",
              VersionId: params.VersionId
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function selectObjectContent(params, callback) {
            var SelectType = params["SelectType"];
            if (!SelectType)
              return callback(util.error(new Error("missing param SelectType")));
            var SelectRequest = params["SelectRequest"] || {};
            var xml = util.json2xml({
              SelectRequest
            });
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:GetObject",
              method: "POST",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              action: "select",
              qs: {
                "select-type": params["SelectType"]
              },
              VersionId: params.VersionId,
              body: xml,
              DataType: "arraybuffer",
              rawBody: true
            }, function(err, data) {
              if (err && err.statusCode === 204) {
                return callback(null, {
                  statusCode: err.statusCode
                });
              } else if (err) {
                return callback(err);
              }
              var result = util.parseSelectPayload(data.body);
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers,
                Body: result.body,
                Payload: result.payload
              });
            });
          }
          function multipartInit(params, callback) {
            var self2 = this;
            var headers = params.Headers;
            var tracker = params.tracker;
            if (!headers["Cache-Control"] && !headers["cache-control"])
              headers["Cache-Control"] = "";
            if (!headers["Content-Type"] && !headers["content-type"])
              headers["Content-Type"] = params.Body && params.Body.type || "";
            var needCalcMd5 = params.Body && (params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5);
            needCalcMd5 && tracker && tracker.setParams({
              md5StartTime: new Date().getTime()
            });
            util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
              if (md5)
                params.Headers["x-cos-meta-md5"] = md5;
              needCalcMd5 && tracker && tracker.setParams({
                md5EndTime: new Date().getTime()
              });
              submitRequest.call(self2, {
                Action: "name/cos:InitiateMultipartUpload",
                method: "POST",
                Bucket: params.Bucket,
                Region: params.Region,
                Key: params.Key,
                action: "uploads",
                headers: params.Headers,
                qs: params.Query,
                tracker
              }, function(err, data) {
                if (err) {
                  tracker && tracker.parent && tracker.parent.setParams({
                    errorNode: "multipartInit"
                  });
                  return callback(err);
                }
                data = util.clone(data || {});
                if (data && data.InitiateMultipartUploadResult) {
                  return callback(null, util.extend(data.InitiateMultipartUploadResult, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  }));
                }
                callback(null, data);
              });
            }, params.onHashProgress);
          }
          function multipartUpload(params, callback) {
            var self2 = this;
            util.getFileSize("multipartUpload", params, function() {
              var tracker = params.tracker;
              var needCalcMd5 = self2.options.UploadCheckContentMd5;
              needCalcMd5 && tracker && tracker.setParams({
                md5StartTime: new Date().getTime()
              });
              util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
                if (md5)
                  params.Headers["Content-MD5"] = util.binaryBase64(md5);
                needCalcMd5 && tracker && tracker.setParams({
                  md5EndTime: new Date().getTime()
                });
                tracker && tracker.setParams({
                  partNumber: params.PartNumber
                });
                submitRequest.call(self2, {
                  Action: "name/cos:UploadPart",
                  TaskId: params.TaskId,
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  qs: {
                    partNumber: params["PartNumber"],
                    uploadId: params["UploadId"]
                  },
                  headers: params.Headers,
                  onProgress: params.onProgress,
                  body: params.Body || null,
                  tracker
                }, function(err, data) {
                  if (err) {
                    tracker && tracker.parent && tracker.parent.setParams({
                      errorNode: "multipartUpload"
                    });
                    return callback(err);
                  }
                  callback(null, {
                    ETag: util.attr(data.headers, "etag", ""),
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              });
            });
          }
          function multipartComplete(params, callback) {
            var self2 = this;
            var UploadId = params.UploadId;
            var Parts = params["Parts"];
            var tracker = params.tracker;
            for (var i = 0, len = Parts.length; i < len; i++) {
              if (Parts[i]["ETag"] && Parts[i]["ETag"].indexOf('"') === 0) {
                continue;
              }
              Parts[i]["ETag"] = '"' + Parts[i]["ETag"] + '"';
            }
            var xml = util.json2xml({
              CompleteMultipartUpload: {
                Part: Parts
              }
            });
            xml = xml.replace(/\n\s*/g, "");
            var headers = params.Headers;
            headers["Content-Type"] = "application/xml";
            headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
            submitRequest.call(this, {
              Action: "name/cos:CompleteMultipartUpload",
              method: "POST",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              qs: {
                uploadId: UploadId
              },
              body: xml,
              headers,
              tracker
            }, function(err, data) {
              if (err) {
                tracker && tracker.parent && tracker.parent.setParams({
                  errorNode: "multipartComplete"
                });
                return callback(err);
              }
              var url = getUrl({
                ForcePathStyle: self2.options.ForcePathStyle,
                protocol: self2.options.Protocol,
                domain: self2.options.Domain,
                bucket: params.Bucket,
                region: params.Region,
                object: params.Key,
                isLocation: true
              });
              var res = data.CompleteMultipartUploadResult || {};
              if (res.ProcessResults) {
                if (res && res.ProcessResults) {
                  res.UploadResult = {
                    OriginalInfo: {
                      Key: res.Key,
                      Location: url,
                      ETag: res.ETag,
                      ImageInfo: res.ImageInfo
                    },
                    ProcessResults: res.ProcessResults
                  };
                  delete res.ImageInfo;
                  delete res.ProcessResults;
                }
              }
              var result = util.extend(res, {
                Location: url,
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function multipartList(params, callback) {
            var reqParams = {};
            reqParams["delimiter"] = params["Delimiter"];
            reqParams["encoding-type"] = params["EncodingType"];
            reqParams["prefix"] = params["Prefix"] || "";
            reqParams["max-uploads"] = params["MaxUploads"];
            reqParams["key-marker"] = params["KeyMarker"];
            reqParams["upload-id-marker"] = params["UploadIdMarker"];
            reqParams = util.clearKey(reqParams);
            var tracker = params.tracker;
            tracker && tracker.setParams({
              signStartTime: new Date().getTime()
            });
            submitRequest.call(this, {
              Action: "name/cos:ListMultipartUploads",
              ResourceKey: reqParams["prefix"],
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              headers: params.Headers,
              qs: reqParams,
              action: "uploads",
              tracker
            }, function(err, data) {
              if (err) {
                tracker && tracker.parent && tracker.parent.setParams({
                  errorNode: "multipartList"
                });
                return callback(err);
              }
              if (data && data.ListMultipartUploadsResult) {
                var Upload = data.ListMultipartUploadsResult.Upload || [];
                Upload = util.isArray(Upload) ? Upload : [Upload];
                data.ListMultipartUploadsResult.Upload = Upload;
              }
              var result = util.clone(data.ListMultipartUploadsResult || {});
              util.extend(result, {
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function multipartListPart(params, callback) {
            var reqParams = {};
            var tracker = params.tracker;
            reqParams["uploadId"] = params["UploadId"];
            reqParams["encoding-type"] = params["EncodingType"];
            reqParams["max-parts"] = params["MaxParts"];
            reqParams["part-number-marker"] = params["PartNumberMarker"];
            submitRequest.call(this, {
              Action: "name/cos:ListParts",
              method: "GET",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              qs: reqParams
            }, function(err, data) {
              if (err) {
                tracker && tracker.parent && tracker.parent.setParams({
                  errorNode: "multipartListPart"
                });
                return callback(err);
              }
              var ListPartsResult = data.ListPartsResult || {};
              var Part = ListPartsResult.Part || [];
              Part = util.isArray(Part) ? Part : [Part];
              ListPartsResult.Part = Part;
              var result = util.clone(ListPartsResult);
              util.extend(result, {
                statusCode: data.statusCode,
                headers: data.headers
              });
              callback(null, result);
            });
          }
          function multipartAbort(params, callback) {
            var reqParams = {};
            reqParams["uploadId"] = params["UploadId"];
            submitRequest.call(this, {
              Action: "name/cos:AbortMultipartUpload",
              method: "DELETE",
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              headers: params.Headers,
              qs: reqParams
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, {
                statusCode: data.statusCode,
                headers: data.headers
              });
            });
          }
          function request(params, callback) {
            submitRequest.call(this, {
              method: params.Method,
              Bucket: params.Bucket,
              Region: params.Region,
              Key: params.Key,
              action: params.Action,
              headers: params.Headers,
              qs: params.Query,
              body: params.Body,
              Url: params.Url,
              rawBody: params.RawBody,
              DataType: params.DataType
            }, function(err, data) {
              if (err)
                return callback(err);
              if (data && data.body) {
                data.Body = data.body;
                delete data.body;
              }
              callback(err, data);
            });
          }
          function appendObject(params, callback) {
            var headers = params.Headers;
            if (!headers["Cache-Control"] && !headers["cache-control"])
              headers["Cache-Control"] = "";
            if (!headers["Content-Type"] && !headers["content-type"])
              headers["Content-Type"] = params.Body && params.Body.type || "";
            submitRequest.call(this, {
              Action: "name/cos:AppendObject",
              method: "POST",
              Bucket: params.Bucket,
              Region: params.Region,
              action: "append",
              Key: params.Key,
              body: params.Body,
              qs: {
                position: params.Position
              },
              headers: params.Headers
            }, function(err, data) {
              if (err)
                return callback(err);
              callback(null, data);
            });
          }
          function getAuth(params) {
            var self2 = this;
            return util.getAuth({
              SecretId: params.SecretId || this.options.SecretId || "",
              SecretKey: params.SecretKey || this.options.SecretKey || "",
              Bucket: params.Bucket,
              Region: params.Region,
              Method: params.Method,
              Key: params.Key,
              Query: params.Query,
              Headers: params.Headers,
              Expires: params.Expires,
              UseRawKey: self2.options.UseRawKey,
              SystemClockOffset: self2.options.SystemClockOffset
            });
          }
          function getObjectUrl(params, callback) {
            var self2 = this;
            var useAccelerate = params.UseAccelerate === void 0 ? self2.options.UseAccelerate : params.UseAccelerate;
            var url = getUrl({
              ForcePathStyle: self2.options.ForcePathStyle,
              protocol: params.Protocol || self2.options.Protocol,
              domain: params.Domain || self2.options.Domain,
              bucket: params.Bucket,
              region: useAccelerate ? "accelerate" : params.Region,
              object: params.Key
            });
            var queryParamsStr = "";
            if (params.Query) {
              queryParamsStr += util.obj2str(params.Query);
            }
            if (params.QueryString) {
              queryParamsStr += (queryParamsStr ? "&" : "") + params.QueryString;
            }
            var syncUrl = url;
            if (params.Sign !== void 0 && !params.Sign) {
              queryParamsStr && (syncUrl += "?" + queryParamsStr);
              callback(null, {
                Url: syncUrl
              });
              return syncUrl;
            }
            var SignHost = getSignHost.call(this, {
              Bucket: params.Bucket,
              Region: params.Region,
              UseAccelerate: params.UseAccelerate,
              Url: url
            });
            var AuthData = getAuthorizationAsync.call(this, {
              Action: (params.Method || "").toUpperCase() === "PUT" ? "name/cos:PutObject" : "name/cos:GetObject",
              Bucket: params.Bucket || "",
              Region: params.Region || "",
              Method: params.Method || "get",
              Key: params.Key,
              Expires: params.Expires,
              Headers: params.Headers,
              Query: params.Query,
              SignHost,
              ForceSignHost: params.ForceSignHost === false ? false : self2.options.ForceSignHost
            }, function(err, AuthData2) {
              if (!callback)
                return;
              if (err) {
                callback(err);
                return;
              }
              var replaceUrlParamList = function replaceUrlParamList2(url2) {
                var urlParams = url2.match(/q-url-param-list.*?(?=&)/g)[0];
                var encodedParams = "q-url-param-list=" + encodeURIComponent(urlParams.replace(/q-url-param-list=/, "")).toLowerCase();
                var reg = new RegExp(urlParams, "g");
                var replacedUrl = url2.replace(reg, encodedParams);
                return replacedUrl;
              };
              var signUrl = url;
              signUrl += "?" + (AuthData2.Authorization.indexOf("q-signature") > -1 ? replaceUrlParamList(AuthData2.Authorization) : "sign=" + encodeURIComponent(AuthData2.Authorization));
              AuthData2.SecurityToken && (signUrl += "&x-cos-security-token=" + AuthData2.SecurityToken);
              AuthData2.ClientIP && (signUrl += "&clientIP=" + AuthData2.ClientIP);
              AuthData2.ClientUA && (signUrl += "&clientUA=" + AuthData2.ClientUA);
              AuthData2.Token && (signUrl += "&token=" + AuthData2.Token);
              queryParamsStr && (signUrl += "&" + queryParamsStr);
              setTimeout(function() {
                callback(null, {
                  Url: signUrl
                });
              });
            });
            if (AuthData) {
              syncUrl += "?" + AuthData.Authorization + (AuthData.SecurityToken ? "&x-cos-security-token=" + AuthData.SecurityToken : "");
              queryParamsStr && (syncUrl += "&" + queryParamsStr);
            } else {
              queryParamsStr && (syncUrl += "?" + queryParamsStr);
            }
            return syncUrl;
          }
          function decodeAcl(AccessControlPolicy) {
            var result = {
              GrantFullControl: [],
              GrantWrite: [],
              GrantRead: [],
              GrantReadAcp: [],
              GrantWriteAcp: [],
              ACL: ""
            };
            var GrantMap = {
              "FULL_CONTROL": "GrantFullControl",
              "WRITE": "GrantWrite",
              "READ": "GrantRead",
              "READ_ACP": "GrantReadAcp",
              "WRITE_ACP": "GrantWriteAcp"
            };
            var AccessControlList = AccessControlPolicy && AccessControlPolicy.AccessControlList || {};
            var Grant = AccessControlList.Grant;
            if (Grant) {
              Grant = util.isArray(Grant) ? Grant : [Grant];
            }
            var PublicAcl = {
              READ: 0,
              WRITE: 0,
              FULL_CONTROL: 0
            };
            Grant && Grant.length && util.each(Grant, function(item) {
              if (item.Grantee.ID === "qcs::cam::anyone:anyone" || item.Grantee.URI === "http://cam.qcloud.com/groups/global/AllUsers") {
                PublicAcl[item.Permission] = 1;
              } else if (item.Grantee.ID !== AccessControlPolicy.Owner.ID) {
                result[GrantMap[item.Permission]].push('id="' + item.Grantee.ID + '"');
              }
            });
            if (PublicAcl.FULL_CONTROL || PublicAcl.WRITE && PublicAcl.READ) {
              result.ACL = "public-read-write";
            } else if (PublicAcl.READ) {
              result.ACL = "public-read";
            } else {
              result.ACL = "private";
            }
            util.each(GrantMap, function(item) {
              result[item] = uniqGrant(result[item].join(","));
            });
            return result;
          }
          function uniqGrant(str) {
            var arr = str.split(",");
            var exist = {};
            var i, item;
            for (i = 0; i < arr.length; ) {
              item = arr[i].trim();
              if (exist[item]) {
                arr.splice(i, 1);
              } else {
                exist[item] = true;
                arr[i] = item;
                i++;
              }
            }
            return arr.join(",");
          }
          function getUrl(params) {
            var region = params.region || "";
            var longBucket = params.bucket || "";
            var shortBucket = longBucket.substr(0, longBucket.lastIndexOf("-"));
            var appId = longBucket.substr(longBucket.lastIndexOf("-") + 1);
            var domain = params.domain;
            var object = params.object;
            if (typeof domain === "function") {
              domain = domain({
                Bucket: longBucket,
                Region: region
              });
            }
            if (["http", "https"].includes(params.protocol)) {
              params.protocol = params.protocol + ":";
            }
            var protocol = params.protocol || (util.isBrowser && location.protocol === "http:" ? "http:" : "https:");
            if (!domain) {
              if (["cn-south", "cn-south-2", "cn-north", "cn-east", "cn-southwest", "sg"].indexOf(region) > -1) {
                domain = "{Region}.myqcloud.com";
              } else {
                domain = "cos.{Region}.myqcloud.com";
              }
              if (!params.ForcePathStyle) {
                domain = "{Bucket}." + domain;
              }
            }
            domain = domain.replace(/\{\{AppId\}\}/ig, appId).replace(/\{\{Bucket\}\}/ig, shortBucket).replace(/\{\{Region\}\}/ig, region).replace(/\{\{.*?\}\}/ig, "");
            domain = domain.replace(/\{AppId\}/ig, appId).replace(/\{BucketName\}/ig, shortBucket).replace(/\{Bucket\}/ig, longBucket).replace(/\{Region\}/ig, region).replace(/\{.*?\}/ig, "");
            if (!/^[a-zA-Z]+:\/\//.test(domain)) {
              domain = protocol + "//" + domain;
            }
            if (domain.slice(-1) === "/") {
              domain = domain.slice(0, -1);
            }
            var url = domain;
            if (params.ForcePathStyle) {
              url += "/" + longBucket;
            }
            url += "/";
            if (object) {
              url += util.camSafeUrlEncode(object).replace(/%2F/g, "/");
            }
            if (params.isLocation) {
              url = url.replace(/^https?:\/\//, "");
            }
            return url;
          }
          var getSignHost = function getSignHost2(opt) {
            if (!opt.Bucket || !opt.Region)
              return "";
            var useAccelerate = opt.UseAccelerate === void 0 ? this.options.UseAccelerate : opt.UseAccelerate;
            var url = opt.Url || getUrl({
              ForcePathStyle: this.options.ForcePathStyle,
              protocol: this.options.Protocol,
              domain: this.options.Domain,
              bucket: opt.Bucket,
              region: useAccelerate ? "accelerate" : opt.Region
            });
            var urlHost = url.replace(/^https?:\/\/([^/]+)(\/.*)?$/, "$1");
            var standardHostReg = new RegExp("^([a-z\\d-]+-\\d+\\.)?(cos|cosv6|ci|pic)\\.([a-z\\d-]+)\\.myqcloud\\.com$");
            if (standardHostReg.test(urlHost))
              return urlHost;
            return "";
          };
          function getAuthorizationAsync(params, callback) {
            var headers = util.clone(params.Headers);
            var headerHost = "";
            util.each(headers, function(v, k) {
              (v === "" || ["content-type", "cache-control", "expires"].indexOf(k.toLowerCase()) > -1) && delete headers[k];
              if (k.toLowerCase() === "host")
                headerHost = v;
            });
            var forceSignHost = params.ForceSignHost === false ? false : true;
            if (!headerHost && params.SignHost && forceSignHost)
              headers.Host = params.SignHost;
            var cbDone = false;
            var cb = function cb2(err, AuthData) {
              if (cbDone)
                return;
              cbDone = true;
              if (AuthData && AuthData.XCosSecurityToken && !AuthData.SecurityToken) {
                AuthData = util.clone(AuthData);
                AuthData.SecurityToken = AuthData.XCosSecurityToken;
                delete AuthData.XCosSecurityToken;
              }
              callback && callback(err, AuthData);
            };
            var self2 = this;
            var Bucket = params.Bucket || "";
            var Region = params.Region || "";
            var KeyName = params.Key || "";
            if (self2.options.ForcePathStyle && Bucket) {
              KeyName = Bucket + "/" + KeyName;
            }
            var Pathname = "/" + KeyName;
            var StsData = {};
            var Scope = params.Scope;
            if (!Scope) {
              var Action = params.Action || "";
              var ResourceKey = params.ResourceKey || params.Key || "";
              Scope = params.Scope || [{
                action: Action,
                bucket: Bucket,
                region: Region,
                prefix: ResourceKey
              }];
            }
            var ScopeKey = util.md5(JSON.stringify(Scope));
            self2._StsCache = self2._StsCache || [];
            (function() {
              var i, AuthData;
              for (i = self2._StsCache.length - 1; i >= 0; i--) {
                AuthData = self2._StsCache[i];
                var compareTime = Math.round(util.getSkewTime(self2.options.SystemClockOffset) / 1e3) + 30;
                if (AuthData.StartTime && compareTime < AuthData.StartTime || compareTime >= AuthData.ExpiredTime) {
                  self2._StsCache.splice(i, 1);
                  continue;
                }
                if (!AuthData.ScopeLimit || AuthData.ScopeLimit && AuthData.ScopeKey === ScopeKey) {
                  StsData = AuthData;
                  break;
                }
              }
            })();
            var calcAuthByTmpKey = function calcAuthByTmpKey2() {
              var KeyTime = "";
              if (StsData.StartTime && params.Expires)
                KeyTime = StsData.StartTime + ";" + (StsData.StartTime + params.Expires * 1);
              else if (StsData.StartTime && StsData.ExpiredTime)
                KeyTime = StsData.StartTime + ";" + StsData.ExpiredTime;
              var Authorization = util.getAuth({
                SecretId: StsData.TmpSecretId,
                SecretKey: StsData.TmpSecretKey,
                Method: params.Method,
                Pathname,
                Query: params.Query,
                Headers: headers,
                Expires: params.Expires,
                UseRawKey: self2.options.UseRawKey,
                SystemClockOffset: self2.options.SystemClockOffset,
                KeyTime,
                ForceSignHost: forceSignHost
              });
              var AuthData = {
                Authorization,
                SecurityToken: StsData.SecurityToken || StsData.XCosSecurityToken || "",
                Token: StsData.Token || "",
                ClientIP: StsData.ClientIP || "",
                ClientUA: StsData.ClientUA || ""
              };
              cb(null, AuthData);
            };
            var checkAuthError = function checkAuthError2(AuthData) {
              if (AuthData.Authorization) {
                var formatAllow = false;
                var auth = AuthData.Authorization;
                if (auth) {
                  if (auth.indexOf(" ") > -1) {
                    formatAllow = false;
                  } else if (auth.indexOf("q-sign-algorithm=") > -1 && auth.indexOf("q-ak=") > -1 && auth.indexOf("q-sign-time=") > -1 && auth.indexOf("q-key-time=") > -1 && auth.indexOf("q-url-param-list=") > -1) {
                    formatAllow = true;
                  } else {
                    try {
                      auth = atob(auth);
                      if (auth.indexOf("a=") > -1 && auth.indexOf("k=") > -1 && auth.indexOf("t=") > -1 && auth.indexOf("r=") > -1 && auth.indexOf("b=") > -1) {
                        formatAllow = true;
                      }
                    } catch (e) {
                    }
                  }
                }
                if (!formatAllow)
                  return util.error(new Error("getAuthorization callback params format error"));
              } else {
                if (!AuthData.TmpSecretId)
                  return util.error(new Error('getAuthorization callback params missing "TmpSecretId"'));
                if (!AuthData.TmpSecretKey)
                  return util.error(new Error('getAuthorization callback params missing "TmpSecretKey"'));
                if (!AuthData.SecurityToken && !AuthData.XCosSecurityToken)
                  return util.error(new Error('getAuthorization callback params missing "SecurityToken"'));
                if (!AuthData.ExpiredTime)
                  return util.error(new Error('getAuthorization callback params missing "ExpiredTime"'));
                if (AuthData.ExpiredTime && AuthData.ExpiredTime.toString().length !== 10)
                  return util.error(new Error('getAuthorization callback params "ExpiredTime" should be 10 digits'));
                if (AuthData.StartTime && AuthData.StartTime.toString().length !== 10)
                  return util.error(new Error('getAuthorization callback params "StartTime" should be 10 StartTime'));
              }
              return false;
            };
            if (StsData.ExpiredTime && StsData.ExpiredTime - util.getSkewTime(self2.options.SystemClockOffset) / 1e3 > 60) {
              calcAuthByTmpKey();
            } else if (self2.options.getAuthorization) {
              self2.options.getAuthorization.call(self2, {
                Bucket,
                Region,
                Method: params.Method,
                Key: KeyName,
                Pathname,
                Query: params.Query,
                Headers: headers,
                Scope,
                SystemClockOffset: self2.options.SystemClockOffset,
                ForceSignHost: forceSignHost
              }, function(AuthData) {
                if (typeof AuthData === "string")
                  AuthData = {
                    Authorization: AuthData
                  };
                var AuthError = checkAuthError(AuthData);
                if (AuthError)
                  return cb(AuthError);
                if (AuthData.Authorization) {
                  cb(null, AuthData);
                } else {
                  StsData = AuthData || {};
                  StsData.Scope = Scope;
                  StsData.ScopeKey = ScopeKey;
                  self2._StsCache.push(StsData);
                  calcAuthByTmpKey();
                }
              });
            } else if (self2.options.getSTS) {
              self2.options.getSTS.call(self2, {
                Bucket,
                Region
              }, function(data) {
                StsData = data || {};
                StsData.Scope = Scope;
                StsData.ScopeKey = ScopeKey;
                if (!StsData.TmpSecretId)
                  StsData.TmpSecretId = StsData.SecretId;
                if (!StsData.TmpSecretKey)
                  StsData.TmpSecretKey = StsData.SecretKey;
                var AuthError = checkAuthError(StsData);
                if (AuthError)
                  return cb(AuthError);
                self2._StsCache.push(StsData);
                calcAuthByTmpKey();
              });
            } else {
              return function() {
                var Authorization = util.getAuth({
                  SecretId: params.SecretId || self2.options.SecretId,
                  SecretKey: params.SecretKey || self2.options.SecretKey,
                  Method: params.Method,
                  Pathname,
                  Query: params.Query,
                  Headers: headers,
                  Expires: params.Expires,
                  UseRawKey: self2.options.UseRawKey,
                  SystemClockOffset: self2.options.SystemClockOffset,
                  ForceSignHost: forceSignHost
                });
                var AuthData = {
                  Authorization,
                  SecurityToken: self2.options.SecurityToken || self2.options.XCosSecurityToken
                };
                cb(null, AuthData);
                return AuthData;
              }();
            }
            return "";
          }
          function allowRetry(err) {
            var allowRetry2 = false;
            var isTimeError = false;
            var serverDate = err.headers && (err.headers.date || err.headers.Date) || err.error && err.error.ServerTime;
            try {
              var errorCode = err.error.Code;
              var errorMessage = err.error.Message;
              if (errorCode === "RequestTimeTooSkewed" || errorCode === "AccessDenied" && errorMessage === "Request has expired") {
                isTimeError = true;
              }
            } catch (e) {
            }
            if (err) {
              if (isTimeError && serverDate) {
                var serverTime = Date.parse(serverDate);
                if (this.options.CorrectClockSkew && Math.abs(util.getSkewTime(this.options.SystemClockOffset) - serverTime) >= 3e4) {
                  console.error("error: Local time is too skewed.");
                  this.options.SystemClockOffset = serverTime - Date.now();
                  allowRetry2 = true;
                }
              } else if (Math.floor(err.statusCode / 100) === 5) {
                allowRetry2 = true;
              }
            }
            return allowRetry2;
          }
          function submitRequest(params, callback) {
            var self2 = this;
            !params.headers && (params.headers = {});
            !params.qs && (params.qs = {});
            params.VersionId && (params.qs.versionId = params.VersionId);
            params.qs = util.clearKey(params.qs);
            params.headers && (params.headers = util.clearKey(params.headers));
            params.qs && (params.qs = util.clearKey(params.qs));
            var Query = util.clone(params.qs);
            params.action && (Query[params.action] = "");
            var paramsUrl = params.url || params.Url;
            var SignHost = params.SignHost || getSignHost.call(this, {
              Bucket: params.Bucket,
              Region: params.Region,
              Url: paramsUrl
            });
            var tracker = params.tracker;
            var next = function next2(tryTimes) {
              var oldClockOffset = self2.options.SystemClockOffset;
              tracker && tracker.setParams({
                signStartTime: new Date().getTime(),
                retryTimes: tryTimes - 1
              });
              getAuthorizationAsync.call(self2, {
                Bucket: params.Bucket || "",
                Region: params.Region || "",
                Method: params.method,
                Key: params.Key,
                Query,
                Headers: params.headers,
                SignHost,
                Action: params.Action,
                ResourceKey: params.ResourceKey,
                Scope: params.Scope,
                ForceSignHost: self2.options.ForceSignHost
              }, function(err, AuthData) {
                if (err) {
                  callback(err);
                  return;
                }
                tracker && tracker.setParams({
                  signEndTime: new Date().getTime(),
                  httpStartTime: new Date().getTime()
                });
                params.AuthData = AuthData;
                _submitRequest.call(self2, params, function(err2, data) {
                  tracker && tracker.setParams({
                    httpEndTime: new Date().getTime()
                  });
                  if (err2 && tryTimes < 2 && (oldClockOffset !== self2.options.SystemClockOffset || allowRetry.call(self2, err2))) {
                    if (params.headers) {
                      delete params.headers.Authorization;
                      delete params.headers["token"];
                      delete params.headers["clientIP"];
                      delete params.headers["clientUA"];
                      params.headers["x-cos-security-token"] && delete params.headers["x-cos-security-token"];
                      params.headers["x-ci-security-token"] && delete params.headers["x-ci-security-token"];
                    }
                    next2(tryTimes + 1);
                  } else {
                    callback(err2, data);
                  }
                });
              });
            };
            next(1);
          }
          function _submitRequest(params, callback) {
            var self2 = this;
            var TaskId = params.TaskId;
            if (TaskId && !self2._isRunningTask(TaskId))
              return;
            var bucket = params.Bucket;
            var region = params.Region;
            var object = params.Key;
            var method2 = params.method || "GET";
            var url = params.Url || params.url;
            var body = params.body;
            var rawBody = params.rawBody;
            if (self2.options.UseAccelerate) {
              region = "accelerate";
            }
            url = url || getUrl({
              ForcePathStyle: self2.options.ForcePathStyle,
              protocol: self2.options.Protocol,
              domain: self2.options.Domain,
              bucket,
              region,
              object
            });
            if (params.action) {
              url = url + "?" + (util.isIOS_QQ ? "".concat(params.action, "=") : params.action);
            }
            if (params.qsStr) {
              if (url.indexOf("?") > -1) {
                url = url + "&" + params.qsStr;
              } else {
                url = url + "?" + params.qsStr;
              }
            }
            var opt = {
              method: method2,
              url,
              headers: params.headers,
              qs: params.qs,
              body
            };
            var token = "x-cos-security-token";
            if (util.isCIHost(url)) {
              token = "x-ci-security-token";
            }
            opt.headers.Authorization = params.AuthData.Authorization;
            params.AuthData.Token && (opt.headers["token"] = params.AuthData.Token);
            params.AuthData.ClientIP && (opt.headers["clientIP"] = params.AuthData.ClientIP);
            params.AuthData.ClientUA && (opt.headers["clientUA"] = params.AuthData.ClientUA);
            params.AuthData.SecurityToken && (opt.headers[token] = params.AuthData.SecurityToken);
            opt.headers && (opt.headers = util.clearKey(opt.headers));
            opt = util.clearKey(opt);
            if (params.onProgress && typeof params.onProgress === "function") {
              var contentLength = body && (body.size || body.length) || 0;
              opt.onProgress = function(e) {
                if (TaskId && !self2._isRunningTask(TaskId))
                  return;
                var loaded = e ? e.loaded : 0;
                params.onProgress({
                  loaded,
                  total: contentLength
                });
              };
            }
            if (params.onDownloadProgress) {
              opt.onDownloadProgress = params.onDownloadProgress;
            }
            if (params.DataType) {
              opt.dataType = params.DataType;
            }
            if (this.options.Timeout) {
              opt.timeout = this.options.Timeout;
            }
            self2.options.ForcePathStyle && (opt.pathStyle = self2.options.ForcePathStyle);
            self2.emit("before-send", opt);
            var useAccelerate = opt.url.includes("accelerate.");
            var queryString = opt.qs ? Object.keys(opt.qs).map(function(key) {
              return "".concat(key, "=").concat(opt.qs[key]);
            }).join("&") : "";
            var fullUrl = queryString ? opt.url + "?" + queryString : opt.url;
            params.tracker && params.tracker.setParams({
              reqUrl: fullUrl,
              accelerate: useAccelerate ? "Y" : "N"
            });
            params.tracker && params.tracker.parent && params.tracker.parent.setParams({
              reqUrl: fullUrl,
              accelerate: useAccelerate ? "Y" : "N"
            });
            var sender = (self2.options.Request || REQUEST)(opt, function(r) {
              if (r && r.error === "abort")
                return;
              var receive = {
                options: opt,
                error: r && r.error,
                statusCode: r && r.statusCode || 0,
                statusMessage: r && r.statusMessage || "",
                headers: r && r.headers || {},
                body: r && r.body
              };
              self2.emit("after-receive", receive);
              var err = receive.error;
              var body2 = receive.body;
              var response = {
                statusCode: receive.statusCode,
                statusMessage: receive.statusMessage,
                headers: receive.headers
              };
              var hasReturned;
              var cb = function cb2(err2, data) {
                TaskId && self2.off("inner-kill-task", killTask);
                if (hasReturned)
                  return;
                hasReturned = true;
                var attrs = {};
                response && response.statusCode && (attrs.statusCode = response.statusCode);
                response && response.headers && (attrs.headers = response.headers);
                if (err2) {
                  err2 = util.extend(err2 || {}, attrs);
                  callback(err2, null);
                } else {
                  data = util.extend(data || {}, attrs);
                  callback(null, data);
                }
                sender = null;
              };
              if (err)
                return cb(util.error(err));
              var statusCode = response.statusCode;
              var statusSuccess = Math.floor(statusCode / 100) === 2;
              if (rawBody && statusSuccess)
                return cb(null, {
                  body: body2
                });
              var json;
              try {
                json = body2 && body2.indexOf("<") > -1 && body2.indexOf(">") > -1 && util.xml2json(body2) || {};
              } catch (e) {
                json = {};
              }
              var xmlError = json && json.Error;
              if (statusSuccess) {
                cb(null, json);
              } else if (xmlError) {
                cb(util.error(new Error(xmlError.Message), {
                  code: xmlError.Code,
                  error: xmlError
                }));
              } else if (statusCode) {
                cb(util.error(new Error(response.statusMessage), {
                  code: "" + statusCode
                }));
              } else if (statusCode) {
                cb(util.error(new Error("statusCode error")));
              }
            });
            var killTask = function killTask2(data) {
              if (data.TaskId === TaskId) {
                sender && sender.abort && sender.abort();
                self2.off("inner-kill-task", killTask2);
              }
            };
            TaskId && self2.on("inner-kill-task", killTask);
          }
          var API_MAP = {
            getService,
            putBucket,
            headBucket,
            getBucket,
            deleteBucket,
            putBucketAcl,
            getBucketAcl,
            putBucketCors,
            getBucketCors,
            deleteBucketCors,
            getBucketLocation,
            getBucketPolicy,
            putBucketPolicy,
            deleteBucketPolicy,
            putBucketTagging,
            getBucketTagging,
            deleteBucketTagging,
            putBucketLifecycle,
            getBucketLifecycle,
            deleteBucketLifecycle,
            putBucketVersioning,
            getBucketVersioning,
            putBucketReplication,
            getBucketReplication,
            deleteBucketReplication,
            putBucketWebsite,
            getBucketWebsite,
            deleteBucketWebsite,
            putBucketReferer,
            getBucketReferer,
            putBucketDomain,
            getBucketDomain,
            deleteBucketDomain,
            putBucketOrigin,
            getBucketOrigin,
            deleteBucketOrigin,
            putBucketLogging,
            getBucketLogging,
            putBucketInventory,
            getBucketInventory,
            listBucketInventory,
            deleteBucketInventory,
            putBucketAccelerate,
            getBucketAccelerate,
            putBucketEncryption,
            getBucketEncryption,
            deleteBucketEncryption,
            getObject,
            headObject,
            listObjectVersions,
            putObject,
            deleteObject,
            getObjectAcl,
            putObjectAcl,
            optionsObject,
            putObjectCopy,
            deleteMultipleObject,
            restoreObject,
            putObjectTagging,
            getObjectTagging,
            deleteObjectTagging,
            selectObjectContent,
            appendObject,
            uploadPartCopy,
            multipartInit,
            multipartUpload,
            multipartComplete,
            multipartList,
            multipartListPart,
            multipartAbort,
            request,
            getObjectUrl,
            getAuth
          };
          function warnOldApi(apiName, fn, proto) {
            util.each(["Cors", "Acl"], function(suffix) {
              if (apiName.slice(-suffix.length) === suffix) {
                var oldName = apiName.slice(0, -suffix.length) + suffix.toUpperCase();
                var apiFn = util.apiWrapper(apiName, fn);
                var warned = false;
                proto[oldName] = function() {
                  !warned && console.warn("warning: cos." + oldName + " has been deprecated. Please Use cos." + apiName + " instead.");
                  warned = true;
                  apiFn.apply(this, arguments);
                };
              }
            });
          }
          module2.exports.init = function(COS, task) {
            task.transferToTaskMethod(API_MAP, "putObject");
            util.each(API_MAP, function(fn, apiName) {
              COS.prototype[apiName] = util.apiWrapper(apiName, fn);
              warnOldApi(apiName, fn, COS.prototype);
            });
          };
        },
        "./src/cos.js": function(module2, exports2, __webpack_require__2) {
          "use strict";
          var util = __webpack_require__2("./src/util.js");
          var event = __webpack_require__2("./src/event.js");
          var task = __webpack_require__2("./src/task.js");
          var base = __webpack_require__2("./src/base.js");
          var advance = __webpack_require__2("./src/advance.js");
          var pkg = __webpack_require__2("./package.json");
          var defaultOptions = {
            AppId: "",
            SecretId: "",
            SecretKey: "",
            SecurityToken: "",
            ChunkRetryTimes: 2,
            FileParallelLimit: 3,
            ChunkParallelLimit: 3,
            ChunkSize: 1024 * 1024,
            SliceSize: 1024 * 1024,
            CopyChunkParallelLimit: 20,
            CopyChunkSize: 1024 * 1024 * 10,
            CopySliceSize: 1024 * 1024 * 10,
            MaxPartNumber: 1e4,
            ProgressInterval: 1e3,
            Domain: "",
            ServiceDomain: "",
            Protocol: "",
            CompatibilityMode: false,
            ForcePathStyle: false,
            UseRawKey: false,
            Timeout: 0,
            CorrectClockSkew: true,
            SystemClockOffset: 0,
            UploadCheckContentMd5: false,
            UploadQueueSize: 1e4,
            UploadAddMetaMd5: false,
            UploadIdCacheLimit: 50,
            UseAccelerate: false,
            ForceSignHost: true,
            EnableTracker: false,
            DeepTracker: false,
            TrackerDelay: 5e3,
            CustomId: ""
          };
          var COS = function COS2(options) {
            this.options = util.extend(util.clone(defaultOptions), options || {});
            this.options.FileParallelLimit = Math.max(1, this.options.FileParallelLimit);
            this.options.ChunkParallelLimit = Math.max(1, this.options.ChunkParallelLimit);
            this.options.ChunkRetryTimes = Math.max(0, this.options.ChunkRetryTimes);
            this.options.ChunkSize = Math.max(1024 * 1024, this.options.ChunkSize);
            this.options.CopyChunkParallelLimit = Math.max(1, this.options.CopyChunkParallelLimit);
            this.options.CopyChunkSize = Math.max(1024 * 1024, this.options.CopyChunkSize);
            this.options.CopySliceSize = Math.max(0, this.options.CopySliceSize);
            this.options.MaxPartNumber = Math.max(1024, Math.min(1e4, this.options.MaxPartNumber));
            this.options.Timeout = Math.max(0, this.options.Timeout);
            if (this.options.AppId) {
              console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: "test-1250000000").');
            }
            if (this.options.SecretId && this.options.SecretId.indexOf(" ") > -1) {
              console.error("error: SecretId\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
              console.error("error: SecretId format is incorrect. Please check");
            }
            if (this.options.SecretKey && this.options.SecretKey.indexOf(" ") > -1) {
              console.error("error: SecretKey\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
              console.error("error: SecretKey format is incorrect. Please check");
            }
            if (util.isNode()) {
              console.warn("warning: cos-js-sdk-v5 \u4E0D\u652F\u6301 nodejs \u73AF\u5883\u4F7F\u7528\uFF0C\u8BF7\u6539\u7528 cos-nodejs-sdk-v5\uFF0C\u53C2\u8003\u6587\u6863\uFF1A https://cloud.tencent.com/document/product/436/8629");
              console.warn("warning: cos-js-sdk-v5 does not support nodejs environment. Please use cos-nodejs-sdk-v5 instead. See: https://cloud.tencent.com/document/product/436/8629");
            }
            event.init(this);
            task.init(this);
          };
          base.init(COS, task);
          advance.init(COS, task);
          COS.util = {
            md5: util.md5,
            xml2json: util.xml2json,
            json2xml: util.json2xml
          };
          COS.getAuthorization = util.getAuth;
          COS.version = pkg.version;
          module2.exports = COS;
        },
        "./src/event.js": function(module2, exports2) {
          var initEvent = function initEvent2(cos) {
            var listeners = {};
            var getList = function getList2(action) {
              !listeners[action] && (listeners[action] = []);
              return listeners[action];
            };
            cos.on = function(action, callback) {
              if (action === "task-list-update") {
                console.warn('warning: Event "' + action + '" has been deprecated. Please use "list-update" instead.');
              }
              getList(action).push(callback);
            };
            cos.off = function(action, callback) {
              var list = getList(action);
              for (var i = list.length - 1; i >= 0; i--) {
                callback === list[i] && list.splice(i, 1);
              }
            };
            cos.emit = function(action, data) {
              var list = getList(action).map(function(cb) {
                return cb;
              });
              for (var i = 0; i < list.length; i++) {
                list[i](data);
              }
            };
          };
          var EventProxy = function EventProxy2() {
            initEvent(this);
          };
          module2.exports.init = initEvent;
          module2.exports.EventProxy = EventProxy;
        },
        "./src/session.js": function(module2, exports2, __webpack_require__2) {
          var util = __webpack_require__2("./src/util.js");
          var cacheKey = "cos_sdk_upload_cache";
          var expires = 30 * 24 * 3600;
          var cache;
          var timer;
          var getCache = function getCache2() {
            try {
              var val = JSON.parse(localStorage.getItem(cacheKey));
            } catch (e) {
            }
            if (!val)
              val = [];
            cache = val;
          };
          var setCache = function setCache2() {
            try {
              if (cache.length)
                localStorage.setItem(cacheKey, JSON.stringify(cache));
              else
                localStorage.removeItem(cacheKey);
            } catch (e) {
            }
          };
          var init = function init2() {
            if (cache)
              return;
            getCache.call(this);
            var changed = false;
            var now = Math.round(Date.now() / 1e3);
            for (var i = cache.length - 1; i >= 0; i--) {
              var mtime = cache[i][2];
              if (!mtime || mtime + expires < now) {
                cache.splice(i, 1);
                changed = true;
              }
            }
            changed && setCache();
          };
          var save = function save2() {
            if (timer)
              return;
            timer = setTimeout(function() {
              setCache();
              timer = null;
            }, 400);
          };
          var mod = {
            using: {},
            setUsing: function setUsing(uuid) {
              mod.using[uuid] = true;
            },
            removeUsing: function removeUsing(uuid) {
              delete mod.using[uuid];
            },
            getFileId: function getFileId(file, ChunkSize, Bucket, Key) {
              if (file.name && file.size && file.lastModifiedDate && ChunkSize) {
                return util.md5([file.name, file.size, file.lastModifiedDate, ChunkSize, Bucket, Key].join("::"));
              } else {
                return null;
              }
            },
            getCopyFileId: function getCopyFileId(copySource, sourceHeaders, ChunkSize, Bucket, Key) {
              var size = sourceHeaders["content-length"];
              var etag = sourceHeaders.etag || "";
              var lastModified = sourceHeaders["last-modified"];
              if (copySource && ChunkSize) {
                return util.md5([copySource, size, etag, lastModified, ChunkSize, Bucket, Key].join("::"));
              } else {
                return null;
              }
            },
            getUploadIdList: function getUploadIdList(uuid) {
              if (!uuid)
                return null;
              init.call(this);
              var list = [];
              for (var i = 0; i < cache.length; i++) {
                if (cache[i][0] === uuid)
                  list.push(cache[i][1]);
              }
              return list.length ? list : null;
            },
            saveUploadId: function saveUploadId(uuid, UploadId, limit) {
              init.call(this);
              if (!uuid)
                return;
              for (var i = cache.length - 1; i >= 0; i--) {
                var item = cache[i];
                if (item[0] === uuid && item[1] === UploadId) {
                  cache.splice(i, 1);
                }
              }
              cache.unshift([uuid, UploadId, Math.round(Date.now() / 1e3)]);
              if (cache.length > limit)
                cache.splice(limit);
              save();
            },
            removeUploadId: function removeUploadId(UploadId) {
              init.call(this);
              delete mod.using[UploadId];
              for (var i = cache.length - 1; i >= 0; i--) {
                if (cache[i][1] === UploadId)
                  cache.splice(i, 1);
              }
              save();
            }
          };
          module2.exports = mod;
        },
        "./src/task.js": function(module2, exports2, __webpack_require__2) {
          var session = __webpack_require__2("./src/session.js");
          var util = __webpack_require__2("./src/util.js");
          var originApiMap = {};
          var transferToTaskMethod = function transferToTaskMethod2(apiMap, apiName) {
            originApiMap[apiName] = apiMap[apiName];
            apiMap[apiName] = function(params, callback) {
              if (params.SkipTask) {
                originApiMap[apiName].call(this, params, callback);
              } else {
                this._addTask(apiName, params, callback);
              }
            };
          };
          var initTask = function initTask2(cos) {
            var queue = [];
            var tasks = {};
            var uploadingFileCount = 0;
            var nextUploadIndex = 0;
            var formatTask = function formatTask2(task) {
              var t = {
                id: task.id,
                Bucket: task.Bucket,
                Region: task.Region,
                Key: task.Key,
                FilePath: task.FilePath,
                state: task.state,
                loaded: task.loaded,
                size: task.size,
                speed: task.speed,
                percent: task.percent,
                hashPercent: task.hashPercent,
                error: task.error
              };
              if (task.FilePath)
                t.FilePath = task.FilePath;
              if (task._custom)
                t._custom = task._custom;
              return t;
            };
            var emitListUpdate = function() {
              var timer;
              var emit = function emit2() {
                timer = 0;
                cos.emit("task-list-update", {
                  list: util.map(queue, formatTask)
                });
                cos.emit("list-update", {
                  list: util.map(queue, formatTask)
                });
              };
              return function() {
                if (!timer)
                  timer = setTimeout(emit);
              };
            }();
            var clearQueue = function clearQueue2() {
              if (queue.length <= cos.options.UploadQueueSize)
                return;
              for (var i = 0; i < nextUploadIndex && i < queue.length && queue.length > cos.options.UploadQueueSize; ) {
                var isActive = queue[i].state === "waiting" || queue[i].state === "checking" || queue[i].state === "uploading";
                if (!queue[i] || !isActive) {
                  tasks[queue[i].id] && delete tasks[queue[i].id];
                  queue.splice(i, 1);
                  nextUploadIndex--;
                } else {
                  i++;
                }
              }
              emitListUpdate();
            };
            var startNextTask = function startNextTask2() {
              if (uploadingFileCount >= cos.options.FileParallelLimit)
                return;
              while (queue[nextUploadIndex] && queue[nextUploadIndex].state !== "waiting") {
                nextUploadIndex++;
              }
              if (nextUploadIndex >= queue.length)
                return;
              var task = queue[nextUploadIndex];
              nextUploadIndex++;
              uploadingFileCount++;
              task.state = "checking";
              task.params.onTaskStart && task.params.onTaskStart(formatTask(task));
              !task.params.UploadData && (task.params.UploadData = {});
              var apiParams = util.formatParams(task.api, task.params);
              originApiMap[task.api].call(cos, apiParams, function(err, data) {
                if (!cos._isRunningTask(task.id))
                  return;
                if (task.state === "checking" || task.state === "uploading") {
                  task.state = err ? "error" : "success";
                  err && (task.error = err);
                  uploadingFileCount--;
                  emitListUpdate();
                  startNextTask2();
                  task.callback && task.callback(err, data);
                  if (task.state === "success") {
                    if (task.params) {
                      delete task.params.UploadData;
                      delete task.params.Body;
                      delete task.params;
                    }
                    delete task.callback;
                  }
                }
                clearQueue();
              });
              emitListUpdate();
              setTimeout(startNextTask2);
            };
            var killTask = function killTask2(id, switchToState) {
              var task = tasks[id];
              if (!task)
                return;
              var waiting = task && task.state === "waiting";
              var running = task && (task.state === "checking" || task.state === "uploading");
              if (switchToState === "canceled" && task.state !== "canceled" || switchToState === "paused" && waiting || switchToState === "paused" && running) {
                if (switchToState === "paused" && task.params.Body && typeof task.params.Body.pipe === "function") {
                  console.error("stream not support pause");
                  return;
                }
                task.state = switchToState;
                cos.emit("inner-kill-task", {
                  TaskId: id,
                  toState: switchToState
                });
                try {
                  var UploadId = task && task.params && task.params.UploadData.UploadId;
                } catch (e) {
                }
                if (switchToState === "canceled" && UploadId)
                  session.removeUsing(UploadId);
                emitListUpdate();
                if (running) {
                  uploadingFileCount--;
                  startNextTask();
                }
                if (switchToState === "canceled") {
                  if (task.params) {
                    delete task.params.UploadData;
                    delete task.params.Body;
                    delete task.params;
                  }
                  delete task.callback;
                }
              }
              clearQueue();
            };
            cos._addTasks = function(taskList) {
              util.each(taskList, function(task) {
                cos._addTask(task.api, task.params, task.callback, true);
              });
              emitListUpdate();
            };
            var isTaskReadyWarning = true;
            cos._addTask = function(api, params, callback, ignoreAddEvent) {
              params = util.formatParams(api, params);
              var id = util.uuid();
              params.TaskId = id;
              params.onTaskReady && params.onTaskReady(id);
              if (params.TaskReady) {
                params.TaskReady(id);
                isTaskReadyWarning && console.warn('warning: Param "TaskReady" has been deprecated. Please use "onTaskReady" instead.');
                isTaskReadyWarning = false;
              }
              var task = {
                params,
                callback,
                api,
                index: queue.length,
                id,
                Bucket: params.Bucket,
                Region: params.Region,
                Key: params.Key,
                FilePath: params.FilePath || "",
                state: "waiting",
                loaded: 0,
                size: 0,
                speed: 0,
                percent: 0,
                hashPercent: 0,
                error: null,
                _custom: params._custom
              };
              var onHashProgress = params.onHashProgress;
              params.onHashProgress = function(info) {
                if (!cos._isRunningTask(task.id))
                  return;
                task.hashPercent = info.percent;
                onHashProgress && onHashProgress(info);
                emitListUpdate();
              };
              var onProgress = params.onProgress;
              params.onProgress = function(info) {
                if (!cos._isRunningTask(task.id))
                  return;
                task.state === "checking" && (task.state = "uploading");
                task.loaded = info.loaded;
                task.speed = info.speed;
                task.percent = info.percent;
                onProgress && onProgress(info);
                emitListUpdate();
              };
              util.getFileSize(api, params, function(err, size) {
                if (err)
                  return callback(util.error(err));
                tasks[id] = task;
                queue.push(task);
                task.size = size;
                !ignoreAddEvent && emitListUpdate();
                startNextTask();
                clearQueue();
              });
              return id;
            };
            cos._isRunningTask = function(id) {
              var task = tasks[id];
              return !!(task && (task.state === "checking" || task.state === "uploading"));
            };
            cos.getTaskList = function() {
              return util.map(queue, formatTask);
            };
            cos.cancelTask = function(id) {
              killTask(id, "canceled");
            };
            cos.pauseTask = function(id) {
              killTask(id, "paused");
            };
            cos.restartTask = function(id) {
              var task = tasks[id];
              if (task && (task.state === "paused" || task.state === "error")) {
                task.state = "waiting";
                emitListUpdate();
                nextUploadIndex = Math.min(nextUploadIndex, task.index);
                startNextTask();
              }
            };
            cos.isUploadRunning = function() {
              return uploadingFileCount || nextUploadIndex < queue.length;
            };
          };
          module2.exports.transferToTaskMethod = transferToTaskMethod;
          module2.exports.init = initTask;
        },
        "./src/tracker.js": function(module2, exports2, __webpack_require__2) {
          var _classCallCheck = __webpack_require__2("./node_modules/@babel/runtime/helpers/classCallCheck.js");
          var _createClass = __webpack_require__2("./node_modules/@babel/runtime/helpers/createClass.js");
          var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
          var pkg = __webpack_require__2("./package.json");
          var beacon = null;
          var getBeacon = function getBeacon2(delay) {
            if (!beacon) {
              var BeaconAction = __webpack_require__2("./lib/beacon.min.js");
              beacon = new BeaconAction({
                appkey: "0AND0VEVB24UBGDU",
                versionCode: pkg.version,
                channelID: "js_sdk",
                openid: "openid",
                unionid: "unid",
                strictMode: false,
                delay,
                sessionDuration: 60 * 1e3
              });
            }
            return beacon;
          };
          var utils = {
            getUid: function getUid() {
              var S4 = function S42() {
                return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
              };
              return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
            },
            getNetType: function getNetType() {
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object") {
                var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                return (connection === null || connection === void 0 ? void 0 : connection.type) || (connection === null || connection === void 0 ? void 0 : connection.effectiveType) || "unknown";
              }
              return "unknown";
            },
            getOsType: function getOsType() {
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                return "unknown os";
              }
              var agent = navigator.userAgent.toLowerCase();
              var isMac = /macintosh|mac os x/i.test(navigator.userAgent);
              if (agent.indexOf("win32") >= 0 || agent.indexOf("wow32") >= 0) {
                return "win32";
              }
              if (agent.indexOf("win64") >= 0 || agent.indexOf("wow64") >= 0) {
                return "win64";
              }
              if (isMac) {
                return "mac";
              }
              return "unknown os";
            },
            isMobile: function isMobile2() {
              var exp = /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i;
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object" && navigator.userAgent.match(exp)) {
                return true;
              }
              return false;
            },
            isAndroid: function isAndroid2() {
              var exp = /(Android|Adr|Linux)/i;
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object" && navigator.userAgent.match(exp)) {
                return true;
              }
              return false;
            },
            isIOS: function isIOS2() {
              var exp = /(iPhone|iPod|iPad|iOS)/i;
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object" && navigator.userAgent.match(exp)) {
                return true;
              }
              return false;
            },
            isOtherMobile: function isOtherMobile() {
              return isMobile && !isAndroid && !isIOS;
            },
            getDeviceName: function getDeviceName() {
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                return "unknown device";
              }
              var explorer = navigator.userAgent.toLowerCase();
              if (explorer.includes("app/tencent_wemeet")) {
                return "tencent_wemeet";
              }
              if (explorer.indexOf("maxthon") >= 0) {
                var match = explorer.match(/maxthon\/([\d.]+)/);
                var ver = match && match[1] || "";
                return "\u50B2\u6E38\u6D4F\u89C8\u5668 ".concat(ver).trim();
              }
              if (explorer.indexOf("qqbrowser") >= 0) {
                var _match = explorer.match(/qqbrowser\/([\d.]+)/);
                var _ver = _match && _match[1] || "";
                return "QQ\u6D4F\u89C8\u5668 ".concat(_ver).trim();
              }
              if (explorer.indexOf("se 2.x") >= 0) {
                return "\u641C\u72D7\u6D4F\u89C8\u5668";
              }
              if (explorer.indexOf("wxwork") >= 0) {
                return "\u5FAE\u4FE1\u5185\u7F6E\u6D4F\u89C8\u5668";
              }
              if (explorer.indexOf("msie") >= 0) {
                var _match2 = explorer.match(/msie ([\d.]+)/);
                var _ver2 = _match2 && _match2[1] || "";
                return "IE ".concat(_ver2).trim();
              }
              if (explorer.indexOf("firefox") >= 0) {
                var _match3 = explorer.match(/firefox\/([\d.]+)/);
                var _ver3 = _match3 && _match3[1] || "";
                return "Firefox ".concat(_ver3).trim();
              }
              if (explorer.indexOf("chrome") >= 0) {
                var _match4 = explorer.match(/chrome\/([\d.]+)/);
                var _ver4 = _match4 && _match4[1] || "";
                return "Chrome ".concat(_ver4).trim();
              }
              if (explorer.indexOf("opera") >= 0) {
                var _match5 = explorer.match(/opera.([\d.]+)/);
                var _ver5 = _match5 && _match5[1] || "";
                return "Opera ".concat(_ver5).trim();
              }
              if (explorer.indexOf("safari") >= 0) {
                var _match6 = explorer.match(/version\/([\d.]+)/);
                var _ver6 = _match6 && _match6[1] || "";
                return "Safari ".concat(_ver6).trim();
              }
              if (explorer.indexOf("edge") >= 0) {
                var _match7 = explorer.match(/edge\/([\d.]+)/);
                var _ver7 = _match7 && _match7[1] || "";
                return "edge ".concat(_ver7).trim();
              }
              return explorer.substr(0, 200);
            }
          };
          var constant = {
            isMobile: utils.isMobile(),
            isBrowser: !utils.isMobile(),
            mobileOsType: utils.isAndroid() ? "android" : utils.isIOS ? "ios" : "other_mobile",
            pcOsType: utils.getOsType()
          };
          var deviceInfo = {
            deviceType: constant.isMobile ? "mobile" : constant.isBrowser ? "browser" : "unknown",
            devicePlatform: constant.isMobile ? constant.mobileOsType : constant.pcOsType,
            deviceName: utils.getDeviceName()
          };
          var sliceUploadMethods = ["multipartInit", "multipartUpload", "multipartComplete", "multipartList", "multipartListPart", "multipartAbort"];
          var uploadApi = ["putObject", "postObject", "appendObject", "sliceUploadFile", "uploadFile", "uploadFiles"].concat(sliceUploadMethods);
          var downloadApi = ["getObject"];
          function getEventCode(apiName) {
            if (uploadApi.includes(apiName)) {
              return "cos_upload";
            }
            if (downloadApi.includes(apiName)) {
              return "cos_download";
            }
            return "base_service";
          }
          function camel2underline(key) {
            return key.replace(/([A-Z])/g, "_$1").toLowerCase();
          }
          function formatParams(params) {
            var formattedParams = {};
            var allReporterKeys = ["tracePlatform", "cossdkVersion", "region", "networkType", "host", "accelerate", "requestPath", "size", "httpMd5", "httpSign", "httpFull", "name", "result", "tookTime", "errorNode", "errorCode", "errorMessage", "errorRequestId", "errorStatusCode", "errorServiceName", "errorType", "traceId", "bucket", "appid", "partNumber", "retryTimes", "reqUrl", "customId", "fullError", "deviceType", "devicePlatform", "deviceName"];
            var successKeys = ["tracePlatform", "cossdkVersion", "region", "bucket", "appid", "networkType", "host", "accelerate", "requestPath", "partNumber", "size", "name", "result", "tookTime", "errorRequestId", "retryTimes", "reqUrl", "customId", "deviceType", "devicePlatform", "deviceName"];
            var reporterKeys = params.result === "Success" ? successKeys : allReporterKeys;
            for (var key in params) {
              if (!reporterKeys.includes(key))
                continue;
              var formattedKey = camel2underline(key);
              formattedParams[formattedKey] = params[key];
            }
            return formattedParams;
          }
          var Tracker = function() {
            "use strict";
            function Tracker2(opt) {
              _classCallCheck(this, Tracker2);
              var parent = opt.parent, traceId = opt.traceId, bucket = opt.bucket, region = opt.region, apiName = opt.apiName, fileKey = opt.fileKey, fileSize = opt.fileSize, accelerate = opt.accelerate, customId = opt.customId, delay = opt.delay, deepTracker = opt.deepTracker;
              var appid = bucket && bucket.substr(bucket.lastIndexOf("-") + 1) || "";
              this.parent = parent;
              this.deepTracker = deepTracker;
              this.delay = delay;
              this.params = {
                cossdkVersion: pkg.version,
                region,
                networkType: "",
                host: "",
                accelerate: accelerate ? "Y" : "N",
                requestPath: fileKey || "",
                size: fileSize || -1,
                httpMd5: 0,
                httpSign: 0,
                httpFull: 0,
                name: apiName || "",
                result: "",
                tookTime: 0,
                errorNode: "",
                errorCode: "",
                errorMessage: "",
                errorRequestId: "",
                errorStatusCode: 0,
                errorServiceName: "",
                tracePlatform: "cos-js-sdk-v5",
                traceId: traceId || utils.getUid(),
                bucket,
                appid,
                partNumber: 0,
                retryTimes: 0,
                reqUrl: "",
                customId: customId || "",
                deviceType: deviceInfo.deviceType,
                devicePlatform: deviceInfo.devicePlatform,
                deviceName: deviceInfo.deviceName,
                md5StartTime: 0,
                md5EndTime: 0,
                signStartTime: 0,
                signEndTime: 0,
                httpStartTime: 0,
                httpEndTime: 0,
                startTime: new Date().getTime(),
                endTime: 0
              };
              this.beacon = getBeacon(delay);
            }
            _createClass(Tracker2, [{
              key: "formatResult",
              value: function formatResult(err, data) {
                var _err$error, _err$error2, _err$error3, _err$error4, _err$error5, _err$error6;
                var now = new Date().getTime();
                var tookTime = now - this.params.startTime;
                var networkType = utils.getNetType();
                var errorCode = err ? (err === null || err === void 0 ? void 0 : err.code) || (err === null || err === void 0 ? void 0 : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.code) || (err === null || err === void 0 ? void 0 : (_err$error2 = err.error) === null || _err$error2 === void 0 ? void 0 : _err$error2.Code) : "";
                var errorMessage = err ? (err === null || err === void 0 ? void 0 : err.message) || (err === null || err === void 0 ? void 0 : (_err$error3 = err.error) === null || _err$error3 === void 0 ? void 0 : _err$error3.message) || (err === null || err === void 0 ? void 0 : (_err$error4 = err.error) === null || _err$error4 === void 0 ? void 0 : _err$error4.Message) : "";
                var errorServiceName = err ? (err === null || err === void 0 ? void 0 : err.resource) || (err === null || err === void 0 ? void 0 : (_err$error5 = err.error) === null || _err$error5 === void 0 ? void 0 : _err$error5.resource) || (err === null || err === void 0 ? void 0 : (_err$error6 = err.error) === null || _err$error6 === void 0 ? void 0 : _err$error6.Resource) : "";
                var errorStatusCode = err ? err === null || err === void 0 ? void 0 : err.statusCode : data.statusCode;
                var requestId = err ? (err === null || err === void 0 ? void 0 : err.headers) && (err === null || err === void 0 ? void 0 : err.headers["x-cos-request-id"]) : (data === null || data === void 0 ? void 0 : data.headers) && (data === null || data === void 0 ? void 0 : data.headers["x-cos-request-id"]);
                var errorType = err ? requestId ? "Server" : "Client" : "";
                Object.assign(this.params, {
                  tookTime,
                  networkType,
                  httpMd5: this.params.md5EndTime - this.params.md5StartTime,
                  httpSign: this.params.signEndTime - this.params.signStartTime,
                  httpFull: this.params.httpEndTime - this.params.httpStartTime,
                  result: err ? "Fail" : "Success",
                  errorType,
                  errorCode,
                  errorStatusCode,
                  errorMessage,
                  errorServiceName,
                  errorRequestId: requestId
                });
                if (err && (!errorCode || !errorMessage)) {
                  this.params.fullError = err ? JSON.stringify(err) : "";
                }
                if (this.params.name === "getObject") {
                  this.params.size = data ? data.headers && data.headers["content-length"] : -1;
                }
                if (this.params.reqUrl) {
                  try {
                    var execRes = /^http(s)?:\/\/(.*?)\//.exec(this.params.reqUrl);
                    this.params.host = execRes[2];
                  } catch (e) {
                    this.params.host = this.params.reqUrl;
                  }
                }
                this.sendEvents();
              }
            }, {
              key: "setParams",
              value: function setParams(params) {
                Object.assign(this.params, params);
              }
            }, {
              key: "sendEvents",
              value: function sendEvents() {
                if (sliceUploadMethods.includes(this.params.name) && !this.deepTracker) {
                  return;
                }
                var eventCode = getEventCode(this.params.name);
                var formattedParams = formatParams(this.params);
                if (!this.beacon) {
                  this.beacon = getBeacon(this.delay || 5e3);
                }
                if (this.delay === 0) {
                  this.beacon && this.beacon.onDirectUserAction(eventCode, formattedParams);
                } else {
                  this.beacon && this.beacon.onUserAction(eventCode, formattedParams);
                }
              }
            }, {
              key: "generateSubTracker",
              value: function generateSubTracker(subParams) {
                Object.assign(subParams, {
                  parent: this,
                  deepTracker: this.deepTracker,
                  traceId: this.params.traceId,
                  bucket: this.params.bucket,
                  region: this.params.region,
                  fileKey: this.params.requestPath,
                  customId: this.params.customId,
                  delay: this.delay
                });
                return new Tracker2(subParams);
              }
            }]);
            return Tracker2;
          }();
          module2.exports = Tracker;
        },
        "./src/util.js": function(module2, exports2, __webpack_require__2) {
          "use strict";
          (function(process2) {
            var _typeof2 = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js");
            var md5 = __webpack_require__2("./lib/md5.js");
            var CryptoJS = __webpack_require__2("./lib/crypto.js");
            var xml2json = __webpack_require__2("./lib/xml2json.js");
            var json2xml = __webpack_require__2("./lib/json2xml.js");
            var Tracker = __webpack_require__2("./src/tracker.js");
            function camSafeUrlEncode(str) {
              return encodeURIComponent(str).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
            }
            function getObjectKeys(obj, forKey) {
              var list = [];
              for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                  list.push(forKey ? camSafeUrlEncode(key).toLowerCase() : key);
                }
              }
              return list.sort(function(a, b) {
                a = a.toLowerCase();
                b = b.toLowerCase();
                return a === b ? 0 : a > b ? 1 : -1;
              });
            }
            ;
            var obj2str = function obj2str2(obj, lowerCaseKey) {
              var i, key, val;
              var list = [];
              var keyList = getObjectKeys(obj);
              for (i = 0; i < keyList.length; i++) {
                key = keyList[i];
                val = obj[key] === void 0 || obj[key] === null ? "" : "" + obj[key];
                key = lowerCaseKey ? camSafeUrlEncode(key).toLowerCase() : camSafeUrlEncode(key);
                val = camSafeUrlEncode(val) || "";
                list.push(key + "=" + val);
              }
              return list.join("&");
            };
            var signHeaders = ["content-disposition", "content-encoding", "content-length", "content-md5", "expect", "host", "if-match", "if-modified-since", "if-none-match", "if-unmodified-since", "origin", "range", "response-cache-control", "response-content-disposition", "response-content-encoding", "response-content-language", "response-content-type", "response-expires", "transfer-encoding", "versionid"];
            var getSignHeaderObj = function getSignHeaderObj2(headers) {
              var signHeaderObj = {};
              for (var i in headers) {
                var key = i.toLowerCase();
                if (key.indexOf("x-cos-") > -1 || signHeaders.indexOf(key) > -1) {
                  signHeaderObj[i] = headers[i];
                }
              }
              return signHeaderObj;
            };
            var getAuth = function getAuth2(opt) {
              opt = opt || {};
              var SecretId = opt.SecretId;
              var SecretKey = opt.SecretKey;
              var KeyTime = opt.KeyTime;
              var method2 = (opt.method || opt.Method || "get").toLowerCase();
              var queryParams = clone(opt.Query || opt.params || {});
              var headers = getSignHeaderObj(clone(opt.Headers || opt.headers || {}));
              var Key = opt.Key || "";
              var pathname;
              if (opt.UseRawKey) {
                pathname = opt.Pathname || opt.pathname || "/" + Key;
              } else {
                pathname = opt.Pathname || opt.pathname || Key;
                pathname.indexOf("/") !== 0 && (pathname = "/" + pathname);
              }
              var forceSignHost = opt.ForceSignHost === false ? false : true;
              if (!headers.Host && !headers.host && opt.Bucket && opt.Region && forceSignHost)
                headers.Host = opt.Bucket + ".cos." + opt.Region + ".myqcloud.com";
              if (!SecretId)
                throw new Error("missing param SecretId");
              if (!SecretKey)
                throw new Error("missing param SecretKey");
              var now = Math.round(getSkewTime(opt.SystemClockOffset) / 1e3) - 1;
              var exp = now;
              var Expires = opt.Expires || opt.expires;
              if (Expires === void 0) {
                exp += 900;
              } else {
                exp += Expires * 1 || 0;
              }
              var qSignAlgorithm = "sha1";
              var qAk = SecretId;
              var qSignTime = KeyTime || now + ";" + exp;
              var qKeyTime = KeyTime || now + ";" + exp;
              var qHeaderList = getObjectKeys(headers, true).join(";").toLowerCase();
              var qUrlParamList = getObjectKeys(queryParams, true).join(";").toLowerCase();
              var signKey = CryptoJS.HmacSHA1(qKeyTime, SecretKey).toString();
              var formatString = [method2, pathname, util.obj2str(queryParams, true), util.obj2str(headers, true), ""].join("\n");
              var stringToSign = ["sha1", qSignTime, CryptoJS.SHA1(formatString).toString(), ""].join("\n");
              var qSignature = CryptoJS.HmacSHA1(stringToSign, signKey).toString();
              var authorization = ["q-sign-algorithm=" + qSignAlgorithm, "q-ak=" + qAk, "q-sign-time=" + qSignTime, "q-key-time=" + qKeyTime, "q-header-list=" + qHeaderList, "q-url-param-list=" + qUrlParamList, "q-signature=" + qSignature].join("&");
              return authorization;
            };
            var readIntBE = function readIntBE2(chunk, size, offset) {
              var bytes = size / 8;
              var buf = chunk.slice(offset, offset + bytes);
              new Uint8Array(buf).reverse();
              return new {
                8: Uint8Array,
                16: Uint16Array,
                32: Uint32Array
              }[size](buf)[0];
            };
            var buf2str = function buf2str2(chunk, start, end, isUtf8) {
              var buf = chunk.slice(start, end);
              var str = "";
              new Uint8Array(buf).forEach(function(charCode) {
                str += String.fromCharCode(charCode);
              });
              if (isUtf8)
                str = decodeURIComponent(escape(str));
              return str;
            };
            var parseSelectPayload = function parseSelectPayload2(chunk) {
              var header = {};
              var body = buf2str(chunk);
              var result = {
                records: []
              };
              while (chunk.byteLength) {
                var totalLength = readIntBE(chunk, 32, 0);
                var headerLength = readIntBE(chunk, 32, 4);
                var payloadRestLength = totalLength - headerLength - 16;
                var offset = 0;
                var content;
                chunk = chunk.slice(12);
                while (offset < headerLength) {
                  var headerNameLength = readIntBE(chunk, 8, offset);
                  var headerName = buf2str(chunk, offset + 1, offset + 1 + headerNameLength);
                  var headerValueLength = readIntBE(chunk, 16, offset + headerNameLength + 2);
                  var headerValue = buf2str(chunk, offset + headerNameLength + 4, offset + headerNameLength + 4 + headerValueLength);
                  header[headerName] = headerValue;
                  offset += headerNameLength + 4 + headerValueLength;
                }
                if (header[":event-type"] === "Records") {
                  content = buf2str(chunk, offset, offset + payloadRestLength, true);
                  result.records.push(content);
                } else if (header[":event-type"] === "Stats") {
                  content = buf2str(chunk, offset, offset + payloadRestLength, true);
                  result.stats = util.xml2json(content).Stats;
                } else if (header[":event-type"] === "error") {
                  var errCode = header[":error-code"];
                  var errMessage = header[":error-message"];
                  var err = new Error(errMessage);
                  err.message = errMessage;
                  err.name = err.code = errCode;
                  result.error = err;
                } else if (["Progress", "Continuation", "End"].includes(header[":event-type"])) {
                }
                chunk = chunk.slice(offset + payloadRestLength + 4);
              }
              return {
                payload: result.records.join(""),
                body
              };
            };
            var getSourceParams = function getSourceParams2(source) {
              var parser = this.options.CopySourceParser;
              if (parser)
                return parser(source);
              var m = source.match(/^([^.]+-\d+)\.cos(v6|-cdc|-cdz|-internal)?\.([^.]+)\.((myqcloud\.com)|(tencentcos\.cn))\/(.+)$/);
              if (!m)
                return null;
              return {
                Bucket: m[1],
                Region: m[3],
                Key: m[7]
              };
            };
            var noop = function noop2() {
            };
            var clearKey = function clearKey2(obj) {
              var retObj = {};
              for (var key in obj) {
                if (obj.hasOwnProperty(key) && obj[key] !== void 0 && obj[key] !== null) {
                  retObj[key] = obj[key];
                }
              }
              return retObj;
            };
            var readAsBinaryString = function readAsBinaryString2(blob, callback) {
              var readFun;
              var fr = new FileReader();
              if (FileReader.prototype.readAsBinaryString) {
                readFun = FileReader.prototype.readAsBinaryString;
                fr.onload = function() {
                  callback(this.result);
                };
              } else if (FileReader.prototype.readAsArrayBuffer) {
                readFun = function readFun2(fileData) {
                  var binary = "";
                  var pt = this;
                  var reader = new FileReader();
                  reader.onload = function(e) {
                    var bytes = new Uint8Array(reader.result);
                    var length = bytes.byteLength;
                    for (var i = 0; i < length; i++) {
                      binary += String.fromCharCode(bytes[i]);
                    }
                    callback(binary);
                  };
                  reader.readAsArrayBuffer(fileData);
                };
              } else {
                console.error("FileReader not support readAsBinaryString");
              }
              readFun.call(fr, blob);
            };
            var fileSliceNeedCopy = function() {
              var compareVersion = function compareVersion2(a, b) {
                a = a.split(".");
                b = b.split(".");
                for (var i = 0; i < b.length; i++) {
                  if (a[i] !== b[i]) {
                    return parseInt(a[i]) > parseInt(b[i]) ? 1 : -1;
                  }
                }
                return 0;
              };
              var check = function check2(ua) {
                if (!ua)
                  return false;
                var ChromeVersion = (ua.match(/Chrome\/([.\d]+)/) || [])[1];
                var QBCoreVersion = (ua.match(/QBCore\/([.\d]+)/) || [])[1];
                var QQBrowserVersion = (ua.match(/QQBrowser\/([.\d]+)/) || [])[1];
                var need = ChromeVersion && compareVersion(ChromeVersion, "53.0.2785.116") < 0 && QBCoreVersion && compareVersion(QBCoreVersion, "3.53.991.400") < 0 && QQBrowserVersion && compareVersion(QQBrowserVersion, "9.0.2524.400") <= 0 || false;
                return need;
              };
              return check(typeof navigator !== "undefined" && navigator.userAgent);
            }();
            var fileSlice = function fileSlice2(file, start, end, isUseToUpload, callback) {
              var blob;
              if (file.slice) {
                blob = file.slice(start, end);
              } else if (file.mozSlice) {
                blob = file.mozSlice(start, end);
              } else if (file.webkitSlice) {
                blob = file.webkitSlice(start, end);
              }
              if (isUseToUpload && fileSliceNeedCopy) {
                var reader = new FileReader();
                reader.onload = function(e) {
                  blob = null;
                  callback(new Blob([reader.result]));
                };
                reader.readAsArrayBuffer(blob);
              } else {
                callback(blob);
              }
            };
            var getBodyMd5 = function getBodyMd52(UploadCheckContentMd5, Body, callback, onProgress) {
              callback = callback || noop;
              if (UploadCheckContentMd5) {
                if (typeof Body === "string") {
                  callback(util.md5(Body, true));
                } else if (Blob && Body instanceof Blob) {
                  util.getFileMd5(Body, function(err, md52) {
                    callback(md52);
                  }, onProgress);
                } else {
                  callback();
                }
              } else {
                callback();
              }
            };
            var md5ChunkSize = 1024 * 1024;
            var getFileMd5 = function getFileMd52(blob, callback, onProgress) {
              var size = blob.size;
              var loaded = 0;
              var md5ctx = md5.getCtx();
              var next = function next2(start) {
                if (start >= size) {
                  var hash = md5ctx.digest("hex");
                  callback(null, hash);
                  return;
                }
                var end = Math.min(size, start + md5ChunkSize);
                util.fileSlice(blob, start, end, false, function(chunk) {
                  readAsBinaryString(chunk, function(content) {
                    chunk = null;
                    md5ctx = md5ctx.update(content, true);
                    loaded += content.length;
                    content = null;
                    if (onProgress)
                      onProgress({
                        loaded,
                        total: size,
                        percent: Math.round(loaded / size * 1e4) / 1e4
                      });
                    next2(start + md5ChunkSize);
                  });
                });
              };
              next(0);
            };
            function clone(obj) {
              return map(obj, function(v) {
                return _typeof2(v) === "object" && v !== null ? clone(v) : v;
              });
            }
            function attr(obj, name, defaultValue) {
              return obj && name in obj ? obj[name] : defaultValue;
            }
            function extend(target, source) {
              each(source, function(val, key) {
                target[key] = source[key];
              });
              return target;
            }
            function isArray(arr) {
              return arr instanceof Array;
            }
            function isInArray(arr, item) {
              var flag = false;
              for (var i = 0; i < arr.length; i++) {
                if (item === arr[i]) {
                  flag = true;
                  break;
                }
              }
              return flag;
            }
            function makeArray(arr) {
              return isArray(arr) ? arr : [arr];
            }
            function each(obj, fn) {
              for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                  fn(obj[i], i);
                }
              }
            }
            function map(obj, fn) {
              var o = isArray(obj) ? [] : {};
              for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                  o[i] = fn(obj[i], i);
                }
              }
              return o;
            }
            function filter(obj, fn) {
              var iaArr = isArray(obj);
              var o = iaArr ? [] : {};
              for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                  if (fn(obj[i], i)) {
                    if (iaArr) {
                      o.push(obj[i]);
                    } else {
                      o[i] = obj[i];
                    }
                  }
                }
              }
              return o;
            }
            var binaryBase64 = function binaryBase642(str) {
              var i, len, char, res = "";
              for (i = 0, len = str.length / 2; i < len; i++) {
                char = parseInt(str[i * 2] + str[i * 2 + 1], 16);
                res += String.fromCharCode(char);
              }
              return btoa(res);
            };
            var uuid = function uuid2() {
              var S4 = function S42() {
                return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
              };
              return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
            };
            var hasMissingParams = function hasMissingParams2(apiName, params) {
              var Bucket = params.Bucket;
              var Region = params.Region;
              var Key = params.Key;
              var Domain = this.options.Domain;
              var checkBucket = !Domain || typeof Domain === "string" && Domain.indexOf("{Bucket}") > -1;
              var checkRegion = !Domain || typeof Domain === "string" && Domain.indexOf("{Region}") > -1;
              if (apiName.indexOf("Bucket") > -1 || apiName === "deleteMultipleObject" || apiName === "multipartList" || apiName === "listObjectVersions") {
                if (checkBucket && !Bucket)
                  return "Bucket";
                if (checkRegion && !Region)
                  return "Region";
              } else if (apiName.indexOf("Object") > -1 || apiName.indexOf("multipart") > -1 || apiName === "sliceUploadFile" || apiName === "abortUploadTask") {
                if (checkBucket && !Bucket)
                  return "Bucket";
                if (checkRegion && !Region)
                  return "Region";
                if (!Key)
                  return "Key";
              }
              return false;
            };
            var formatParams = function formatParams2(apiName, params) {
              params = extend({}, params);
              if (apiName !== "getAuth" && apiName !== "getV4Auth" && apiName !== "getObjectUrl") {
                var Headers = params.Headers || {};
                if (params && _typeof2(params) === "object") {
                  (function() {
                    for (var key in params) {
                      if (params.hasOwnProperty(key) && key.indexOf("x-cos-") > -1) {
                        Headers[key] = params[key];
                      }
                    }
                  })();
                  var headerMap = {
                    "x-cos-mfa": "MFA",
                    "Content-MD5": "ContentMD5",
                    "Content-Length": "ContentLength",
                    "Content-Type": "ContentType",
                    "Expect": "Expect",
                    "Expires": "Expires",
                    "Cache-Control": "CacheControl",
                    "Content-Disposition": "ContentDisposition",
                    "Content-Encoding": "ContentEncoding",
                    "Range": "Range",
                    "If-Modified-Since": "IfModifiedSince",
                    "If-Unmodified-Since": "IfUnmodifiedSince",
                    "If-Match": "IfMatch",
                    "If-None-Match": "IfNoneMatch",
                    "x-cos-copy-source": "CopySource",
                    "x-cos-copy-source-Range": "CopySourceRange",
                    "x-cos-metadata-directive": "MetadataDirective",
                    "x-cos-copy-source-If-Modified-Since": "CopySourceIfModifiedSince",
                    "x-cos-copy-source-If-Unmodified-Since": "CopySourceIfUnmodifiedSince",
                    "x-cos-copy-source-If-Match": "CopySourceIfMatch",
                    "x-cos-copy-source-If-None-Match": "CopySourceIfNoneMatch",
                    "x-cos-acl": "ACL",
                    "x-cos-grant-read": "GrantRead",
                    "x-cos-grant-write": "GrantWrite",
                    "x-cos-grant-full-control": "GrantFullControl",
                    "x-cos-grant-read-acp": "GrantReadAcp",
                    "x-cos-grant-write-acp": "GrantWriteAcp",
                    "x-cos-storage-class": "StorageClass",
                    "x-cos-traffic-limit": "TrafficLimit",
                    "x-cos-mime-limit": "MimeLimit",
                    "x-cos-server-side-encryption-customer-algorithm": "SSECustomerAlgorithm",
                    "x-cos-server-side-encryption-customer-key": "SSECustomerKey",
                    "x-cos-server-side-encryption-customer-key-MD5": "SSECustomerKeyMD5",
                    "x-cos-server-side-encryption": "ServerSideEncryption",
                    "x-cos-server-side-encryption-cos-kms-key-id": "SSEKMSKeyId",
                    "x-cos-server-side-encryption-context": "SSEContext",
                    "Pic-Operations": "PicOperations"
                  };
                  util.each(headerMap, function(paramKey, headerKey) {
                    if (params[paramKey] !== void 0) {
                      Headers[headerKey] = params[paramKey];
                    }
                  });
                  params.Headers = clearKey(Headers);
                }
              }
              return params;
            };
            var apiWrapper = function apiWrapper2(apiName, apiFn) {
              return function(params, callback) {
                var self2 = this;
                if (typeof params === "function") {
                  callback = params;
                  params = {};
                }
                params = formatParams(apiName, params);
                var tracker;
                if (self2.options.EnableTracker) {
                  if (params.calledBySdk === "sliceUploadFile") {
                    tracker = params.tracker && params.tracker.generateSubTracker({
                      apiName
                    });
                  } else if (["uploadFile", "uploadFiles"].includes(apiName)) {
                    tracker = null;
                  } else {
                    var fileSize = -1;
                    if (params.Body) {
                      fileSize = typeof params.Body === "string" ? params.Body.length : params.Body.size || params.Body.byteLength || -1;
                    }
                    tracker = new Tracker({
                      bucket: params.Bucket,
                      region: params.Region,
                      apiName,
                      fileKey: params.Key,
                      fileSize,
                      deepTracker: self2.options.DeepTracker,
                      customId: self2.options.CustomId,
                      delay: self2.options.TrackerDelay
                    });
                  }
                }
                params.tracker = tracker;
                var formatResult = function formatResult2(result) {
                  if (result && result.headers) {
                    result.headers["x-cos-request-id"] && (result.RequestId = result.headers["x-cos-request-id"]);
                    result.headers["x-ci-request-id"] && (result.RequestId = result.headers["x-ci-request-id"]);
                    result.headers["x-cos-version-id"] && (result.VersionId = result.headers["x-cos-version-id"]);
                    result.headers["x-cos-delete-marker"] && (result.DeleteMarker = result.headers["x-cos-delete-marker"]);
                  }
                  return result;
                };
                var _callback = function _callback2(err, data) {
                  tracker && tracker.formatResult(err, data);
                  callback && callback(formatResult(err), formatResult(data));
                };
                var checkParams = function checkParams2() {
                  if (apiName !== "getService" && apiName !== "abortUploadTask") {
                    var missingResult = hasMissingParams.call(self2, apiName, params);
                    if (missingResult) {
                      return "missing param " + missingResult;
                    }
                    if (params.Region) {
                      if (self2.options.CompatibilityMode) {
                        if (!/^([a-z\d-.]+)$/.test(params.Region)) {
                          return "Region format error.";
                        }
                      } else {
                        if (params.Region.indexOf("cos.") > -1) {
                          return 'param Region should not be start with "cos."';
                        } else if (!/^([a-z\d-]+)$/.test(params.Region)) {
                          return "Region format error.";
                        }
                      }
                      if (!self2.options.CompatibilityMode && params.Region.indexOf("-") === -1 && params.Region !== "yfb" && params.Region !== "default" && params.Region !== "accelerate") {
                        console.warn("warning: param Region format error, find help here: https://cloud.tencent.com/document/product/436/6224");
                      }
                    }
                    if (params.Bucket) {
                      if (!/^([a-z\d-]+)-(\d+)$/.test(params.Bucket)) {
                        if (params.AppId) {
                          params.Bucket = params.Bucket + "-" + params.AppId;
                        } else if (self2.options.AppId) {
                          params.Bucket = params.Bucket + "-" + self2.options.AppId;
                        } else {
                          return 'Bucket should format as "test-1250000000".';
                        }
                      }
                      if (params.AppId) {
                        console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g Bucket:"test-1250000000" ).');
                        delete params.AppId;
                      }
                    }
                    if (!self2.options.UseRawKey && params.Key && params.Key.substr(0, 1) === "/") {
                      params.Key = params.Key.substr(1);
                    }
                  }
                };
                var errMsg = checkParams();
                var isSync = ["getAuth", "getObjectUrl"].includes(apiName);
                if (typeof Promise === "function" && !isSync && !callback) {
                  return new Promise(function(resolve, reject) {
                    callback = function callback2(err, data) {
                      err ? reject(err) : resolve(data);
                    };
                    if (errMsg)
                      return _callback(util.error(new Error(errMsg)));
                    apiFn.call(self2, params, _callback);
                  });
                } else {
                  if (errMsg)
                    return _callback(util.error(new Error(errMsg)));
                  var res = apiFn.call(self2, params, _callback);
                  if (isSync)
                    return res;
                }
              };
            };
            var throttleOnProgress = function throttleOnProgress2(total, onProgress) {
              var self2 = this;
              var size0 = 0;
              var size1 = 0;
              var time0 = Date.now();
              var time1;
              var timer;
              function update() {
                timer = 0;
                if (onProgress && typeof onProgress === "function") {
                  time1 = Date.now();
                  var speed = Math.max(0, Math.round((size1 - size0) / ((time1 - time0) / 1e3) * 100) / 100) || 0;
                  var percent;
                  if (size1 === 0 && total === 0) {
                    percent = 1;
                  } else {
                    percent = Math.floor(size1 / total * 100) / 100 || 0;
                  }
                  time0 = time1;
                  size0 = size1;
                  try {
                    onProgress({
                      loaded: size1,
                      total,
                      speed,
                      percent
                    });
                  } catch (e) {
                  }
                }
              }
              return function(info, immediately) {
                if (info) {
                  size1 = info.loaded;
                  total = info.total;
                }
                if (immediately) {
                  clearTimeout(timer);
                  update();
                } else {
                  if (timer)
                    return;
                  timer = setTimeout(update, self2.options.ProgressInterval);
                }
              };
            };
            var getFileSize = function getFileSize2(api, params, callback) {
              var size;
              if (typeof params.Body === "string") {
                params.Body = new Blob([params.Body], {
                  type: "text/plain"
                });
              } else if (params.Body instanceof ArrayBuffer) {
                params.Body = new Blob([params.Body]);
              }
              if (params.Body && (params.Body instanceof Blob || params.Body.toString() === "[object File]" || params.Body.toString() === "[object Blob]")) {
                size = params.Body.size;
              } else {
                callback(util.error(new Error("params body format error, Only allow File|Blob|String.")));
                return;
              }
              params.ContentLength = size;
              callback(null, size);
            };
            var getSkewTime = function getSkewTime2(offset) {
              return Date.now() + (offset || 0);
            };
            var error = function error2(err, opt) {
              var sourceErr = err;
              err.message = err.message || null;
              if (typeof opt === "string") {
                err.error = opt;
                err.message = opt;
              } else if (_typeof2(opt) === "object" && opt !== null) {
                extend(err, opt);
                if (opt.code || opt.name)
                  err.code = opt.code || opt.name;
                if (opt.message)
                  err.message = opt.message;
                if (opt.stack)
                  err.stack = opt.stack;
              }
              if (typeof Object.defineProperty === "function") {
                Object.defineProperty(err, "name", {
                  writable: true,
                  enumerable: false
                });
                Object.defineProperty(err, "message", {
                  enumerable: true
                });
              }
              err.name = opt && opt.name || err.name || err.code || "Error";
              if (!err.code)
                err.code = err.name;
              if (!err.error)
                err.error = clone(sourceErr);
              return err;
            };
            var isWebWorker = function isWebWorker2() {
              return (typeof globalThis === "undefined" ? "undefined" : _typeof2(globalThis)) === "object" && (globalThis.constructor.name === "DedicatedWorkerGlobalScope" || globalThis.FileReaderSync);
            };
            var isNode = function isNode2() {
              return (typeof window === "undefined" ? "undefined" : _typeof2(window)) !== "object" && (typeof process2 === "undefined" ? "undefined" : _typeof2(process2)) === "object" && true && !isWebWorker();
            };
            var isCIHost = function isCIHost2(url) {
              return /^https?:\/\/([^/]+\.)?ci\.[^/]+/.test(url);
            };
            var isIOS2 = function() {
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                return false;
              }
              var u = navigator.userAgent;
              var isIOS3 = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
              return isIOS3;
            }();
            var isQQ = function() {
              if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                return false;
              }
              return /\sQQ/i.test(navigator.userAgent);
            }();
            var util = {
              noop,
              formatParams,
              apiWrapper,
              xml2json,
              json2xml,
              md5,
              clearKey,
              fileSlice,
              getBodyMd5,
              getFileMd5,
              binaryBase64,
              extend,
              isArray,
              isInArray,
              makeArray,
              each,
              map,
              filter,
              clone,
              attr,
              uuid,
              camSafeUrlEncode,
              throttleOnProgress,
              getFileSize,
              getSkewTime,
              error,
              obj2str,
              getAuth,
              parseSelectPayload,
              getSourceParams,
              isBrowser: true,
              isNode,
              isCIHost,
              isIOS_QQ: isIOS2 && isQQ
            };
            module2.exports = util;
          }).call(this, __webpack_require__2("./node_modules/process/browser.js"));
        }
      });
    });
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (typeof module2 !== "undefined") {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve, reject, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method2) {
      defaults.headers[method2] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      defaults.headers[method2] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method2) {
        delete config.headers[method2];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/package.json
var require_package = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/package.json"(exports2, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.4",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://axios-http.com",
      devDependencies: {
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.3.0",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^23.0.0",
        "grunt-karma": "^4.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^4.0.2",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^6.3.2",
        "karma-chrome-launcher": "^3.1.0",
        "karma-firefox-launcher": "^2.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^4.3.6",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.8",
        "karma-webpack": "^4.0.2",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^8.2.1",
        sinon: "^4.5.0",
        "terser-webpack-plugin": "^4.2.3",
        typescript: "^4.0.5",
        "url-search-params": "^0.10.0",
        webpack: "^4.44.2",
        "webpack-dev-server": "^3.11.0"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.14.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var pkg = require_package();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      isOlderVersion,
      assertOptions,
      validators
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
      Axios.prototype[method2] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method2,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      Axios.prototype[method2] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method2,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/vod-js-sdk-v6/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/vod-js-sdk-v6/node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/vod-js-sdk-v6/lib/src/util.js
var require_util = __commonJS({
  "node_modules/vod-js-sdk-v6/lib/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HOST = void 0;
    function isFile(v) {
      return Object.prototype.toString.call(v) == "[object File]";
    }
    function isFunction(v) {
      return typeof v === "function";
    }
    function isString(v) {
      return typeof v === "string";
    }
    function noop() {
    }
    function delay(ms) {
      return new Promise(function(resolve) {
        setTimeout(function() {
          resolve();
        }, ms);
      });
    }
    function getUnix() {
      return Math.floor(Date.now() / 1e3);
    }
    var CLIENT_ERROR_CODE;
    (function(CLIENT_ERROR_CODE2) {
      CLIENT_ERROR_CODE2[CLIENT_ERROR_CODE2["UPLOAD_FAIL"] = 1] = "UPLOAD_FAIL";
    })(CLIENT_ERROR_CODE || (CLIENT_ERROR_CODE = {}));
    var HOST;
    (function(HOST2) {
      HOST2["MAIN"] = "vod2.qcloud.com";
      HOST2["BACKUP"] = "vod2.dnsv1.com";
    })(HOST = exports2.HOST || (exports2.HOST = {}));
    exports2.default = {
      isFile,
      isFunction,
      isString,
      noop,
      delay,
      getUnix,
      isTest: false,
      isDev: true,
      CLIENT_ERROR_CODE
    };
  }
});

// node_modules/vod-js-sdk-v6/lib/package.json
var require_package2 = __commonJS({
  "node_modules/vod-js-sdk-v6/lib/package.json"(exports2, module2) {
    module2.exports = {
      name: "vod-js-sdk-v6",
      version: "1.4.16",
      description: "tencent cloud vod js sdk v6",
      main: "lib/src/tc_vod.js",
      unpkg: "dist/vod-js-sdk-v6.js",
      typings: "lib/src/tc_vod.d.ts",
      scripts: {
        test: "cross-env NODE_ENV=test mocha -r espower-typescript/guess -r jsdom-global/register -r test/env test/**/*.test.ts",
        cover: "cross-env NODE_ENV=test nyc mocha -r espower-typescript/guess -r jsdom-global/register -r test/env test/**/*.test.ts",
        dev: "webpack --config webpack.dev.config.js --watch",
        dist: "webpack --config webpack.config.js",
        build: "npm run test && npm run dist && npm run compile",
        compile: "tsc -p tsconfig.json",
        prepublish: "npm run build",
        lint: "tsc --noEmit && eslint 'src/**/*.{js,ts,tsx}' --quiet --fix"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/tencentyun/vod-js-sdk-v6.git"
      },
      keywords: [
        "tencentcloud",
        "sdk",
        "vod"
      ],
      author: "alsotang <alsotang@gmail.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/tencentyun/vod-js-sdk-v6/issues"
      },
      homepage: "https://github.com/tencentyun/vod-js-sdk-v6#readme",
      dependencies: {
        axios: "^0.21.1",
        "cos-js-sdk-v5": "^1.3.7",
        eventemitter3: "^4.0.7",
        "js-sha1": "^0.6.0",
        uuid: "^3.3.2"
      },
      devDependencies: {
        "@types/mocha": "^5.2.5",
        "@types/semver": "^6.0.0",
        "@types/sha1": "^1.1.1",
        "@types/uuid": "^3.4.4",
        "@typescript-eslint/eslint-plugin": "^1.9.0",
        "@typescript-eslint/parser": "^1.9.0",
        "cross-env": "^6.0.3",
        eslint: "^5.16.0",
        "eslint-config-prettier": "^4.3.0",
        "eslint-plugin-prettier": "^3.1.0",
        "espower-typescript": "^9.0.1",
        jsdom: "^13.1.0",
        "jsdom-global": "^3.0.2",
        mm: "^2.4.1",
        mocha: "^5.2.0",
        nyc: "^13.1.0",
        "power-assert": "^1.6.1",
        prettier: "^1.17.1",
        semver: "^6.1.1",
        "ts-loader": "^5.3.3",
        typescript: "^3.5.3",
        webpack: "^4.28.1",
        "webpack-cli": "^3.3.12"
      },
      nyc: {
        extension: [
          ".ts",
          ".tsx"
        ],
        include: [
          "src"
        ],
        reporter: [
          "html"
        ],
        all: true
      }
    };
  }
});

// node_modules/vod-js-sdk-v6/lib/src/vod_reporter.js
var require_vod_reporter = __commonJS({
  "node_modules/vod-js-sdk-v6/lib/src/vod_reporter.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VodReporter = exports2.VodReportEvent = void 0;
    var uploader_1 = require_uploader();
    var pkg = require_package2();
    var util_1 = require_util();
    var VodReportEvent;
    (function(VodReportEvent2) {
      VodReportEvent2["report_apply"] = "report_apply";
      VodReportEvent2["report_cos_upload"] = "report_cos_upload";
      VodReportEvent2["report_commit"] = "report_commit";
      VodReportEvent2["report_done"] = "report_done";
    })(VodReportEvent = exports2.VodReportEvent || (exports2.VodReportEvent = {}));
    var ReqType;
    (function(ReqType2) {
      ReqType2[ReqType2["apply"] = 10001] = "apply";
      ReqType2[ReqType2["cos_upload"] = 20001] = "cos_upload";
      ReqType2[ReqType2["commit"] = 10002] = "commit";
      ReqType2[ReqType2["done"] = 40001] = "done";
    })(ReqType || (ReqType = {}));
    var VodReporter = function() {
      function VodReporter2(uploader, options) {
        this.baseReportData = {
          version: pkg.version,
          platform: 3e3,
          device: navigator.userAgent
        };
        this.reportUrl = "https://vodreport.qcloud.com/ugcupload_new";
        this.uploader = uploader;
        this.options = options;
        this.init();
      }
      VodReporter2.prototype.init = function() {
        this.uploader.on(VodReportEvent.report_apply, this.onApply.bind(this));
        this.uploader.on(VodReportEvent.report_cos_upload, this.onCosUpload.bind(this));
        this.uploader.on(VodReportEvent.report_commit, this.onCommit.bind(this));
        this.uploader.on(VodReportEvent.report_done, this.onDone.bind(this));
      };
      VodReporter2.prototype.onApply = function(reportObj) {
        try {
          var uploader = this.uploader;
          if (!uploader.videoFile) {
            return;
          }
          Object.assign(this.baseReportData, {
            appId: uploader.appId,
            fileSize: uploader.videoFile.size,
            fileName: uploader.videoFile.name,
            fileType: uploader.videoFile.type,
            vodSessionKey: uploader.vodSessionKey,
            reqKey: uploader.reqKey,
            reportId: uploader.reportId
          });
          var customReportData = {
            reqType: ReqType.apply,
            errCode: 0,
            vodErrCode: 0,
            errMsg: "",
            reqTimeCost: Number(new Date()) - Number(reportObj.requestStartTime),
            reqTime: Number(reportObj.requestStartTime)
          };
          if (reportObj.err) {
            customReportData.errCode = 1;
            customReportData.vodErrCode = reportObj.err.code;
            customReportData.errMsg = reportObj.err.message;
          }
          if (reportObj.data) {
            this.baseReportData.cosRegion = reportObj.data.storageRegionV5;
          }
          this.report(customReportData);
        } catch (e) {
          console.error("onApply", e);
          if (util_1.default.isTest) {
            throw e;
          }
        }
      };
      VodReporter2.prototype.onCosUpload = function(reportObj) {
        try {
          var customReportData = {
            reqType: ReqType.cos_upload,
            errCode: 0,
            cosErrCode: "",
            errMsg: "",
            reqTimeCost: Number(new Date()) - Number(reportObj.requestStartTime),
            reqTime: Number(reportObj.requestStartTime)
          };
          if (reportObj.err) {
            customReportData.errCode = 1;
            customReportData.cosErrCode = reportObj.err.error ? reportObj.err.error.Code : reportObj.err;
            if (reportObj.err && reportObj.err.error === "error") {
              customReportData.cosErrCode = "cors error";
            }
            customReportData.errMsg = JSON.stringify(reportObj.err);
          }
          this.report(customReportData);
        } catch (e) {
          console.error("onCosUpload", e);
          if (util_1.default.isTest) {
            throw e;
          }
        }
      };
      VodReporter2.prototype.onCommit = function(reportObj) {
        try {
          var customReportData = {
            reqType: ReqType.commit,
            errCode: 0,
            vodErrCode: 0,
            errMsg: "",
            reqTimeCost: Number(new Date()) - Number(reportObj.requestStartTime),
            reqTime: Number(reportObj.requestStartTime)
          };
          if (reportObj.err) {
            customReportData.errCode = 1;
            customReportData.vodErrCode = reportObj.err.code;
            customReportData.errMsg = reportObj.err.message;
          }
          if (reportObj.data) {
            this.baseReportData.fileId = reportObj.data.fileId;
          }
          this.report(customReportData);
        } catch (e) {
          console.error("onCommit", e);
          if (util_1.default.isTest) {
            throw e;
          }
        }
      };
      VodReporter2.prototype.onDone = function(reportObj) {
        try {
          var customReportData = {
            reqType: ReqType.done,
            errCode: reportObj.err && reportObj.err.code,
            reqTimeCost: Number(new Date()) - Number(reportObj.requestStartTime),
            reqTime: Number(reportObj.requestStartTime)
          };
          this.report(customReportData);
        } catch (e) {
          console.error("onDone", e);
          if (util_1.default.isTest) {
            throw e;
          }
        }
      };
      VodReporter2.prototype.report = function(reportData) {
        reportData = __assign(__assign({}, this.baseReportData), reportData);
        this.send(reportData);
      };
      VodReporter2.prototype.send = function(reportData) {
        if (util_1.default.isDev || util_1.default.isTest) {
          console.log("send reportData", reportData);
          return;
        }
        uploader_1.vodAxios.post(this.reportUrl, reportData, {
          withCredentials: false
        });
      };
      return VodReporter2;
    }();
    exports2.VodReporter = VodReporter;
  }
});

// node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/uuid/lib/rng-browser.js"(exports2, module2) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module2.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module2.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0)
            r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/v4.js"(exports2, module2) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// node_modules/vod-js-sdk-v6/lib/src/uploader.js
var require_uploader = __commonJS({
  "node_modules/vod-js-sdk-v6/lib/src/uploader.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploaderEvent = exports2.vodAxios = void 0;
    var sha1 = require_sha1();
    var COS = require_cos_js_sdk_v5();
    var eventemitter3_1 = require_eventemitter3();
    var axios_1 = require_axios2();
    var util_1 = require_util();
    var vod_reporter_1 = require_vod_reporter();
    var uuidv4 = require_v4();
    exports2.vodAxios = axios_1.default.create();
    exports2.vodAxios.interceptors.response.use(function(response) {
      return response;
    }, function(error) {
      if (isNaN(error.code)) {
        error.code = 500;
      }
      return Promise.reject(error);
    });
    var UploaderEvent;
    (function(UploaderEvent2) {
      UploaderEvent2["video_progress"] = "video_progress";
      UploaderEvent2["media_progress"] = "media_progress";
      UploaderEvent2["video_upload"] = "video_upload";
      UploaderEvent2["media_upload"] = "media_upload";
      UploaderEvent2["cover_progress"] = "cover_progress";
      UploaderEvent2["cover_upload"] = "cover_upload";
    })(UploaderEvent = exports2.UploaderEvent || (exports2.UploaderEvent = {}));
    var Uploader = function(_super) {
      __extends(Uploader2, _super);
      function Uploader2(params) {
        var _this = _super.call(this) || this;
        _this.sessionName = "";
        _this.vodSessionKey = "";
        _this.appId = 0;
        _this.reqKey = uuidv4();
        _this.reportId = "";
        _this.enableResume = true;
        _this.applyRequestTimeout = 5e3;
        _this.applyRequestRetryCount = 3;
        _this.commitRequestTimeout = 5e3;
        _this.commitRequestRetryCount = 3;
        _this.retryDelay = 1e3;
        _this.validateInitParams(params);
        _this.videoFile = params.mediaFile || params.videoFile;
        _this.getSignature = params.getSignature;
        _this.cosStrategy = _this.getCosStrategy(params);
        _this.enableResume = params.enableResume;
        _this.videoName = params.mediaName || params.videoName;
        _this.coverFile = params.coverFile;
        _this.fileId = params.fileId;
        _this.applyRequestTimeout = params.applyRequestTimeout || _this.applyRequestTimeout;
        _this.commitRequestTimeout = params.commitRequestTimeout || _this.commitRequestTimeout;
        _this.retryDelay = params.retryDelay || _this.retryDelay;
        _this.appId = params.appId || _this.appId;
        _this.reportId = params.reportId || _this.reportId;
        _this.cosAuthTime = 0;
        _this.genFileInfo();
        return _this;
      }
      Uploader2.prototype.getCosStrategy = function(params) {
        var sourceData = {
          FileParallelLimit: params.fileParallelLimit,
          ChunkParallelLimit: params.chunkParallelLimit || 6,
          ChunkRetryTimes: params.chunkRetryTimes,
          ChunkSize: params.chunkSize || 1048576 * 8,
          SliceSize: params.sliceSize,
          CopyChunkParallelLimit: params.copyChunkParallelLimit,
          CopyChunkSize: params.copyChunkSize,
          CopySliceSize: params.copySliceSize,
          ProgressInterval: params.progressInterval
        };
        var cosStrategy = Object.keys(sourceData).filter(function(key) {
          return sourceData[key] !== void 0;
        }).reduce(function(acc, key) {
          var _a;
          return __assign(__assign({}, acc), (_a = {}, _a[key] = sourceData[key], _a));
        }, {});
        return cosStrategy;
      };
      Uploader2.prototype.setStorage = function(name, value) {
        if (!name) {
          return;
        }
        var cname = "webugc_" + sha1(name);
        try {
          localStorage.setItem(cname, value);
        } catch (e) {
        }
      };
      Uploader2.prototype.getStorage = function(name) {
        if (!name) {
          return;
        }
        var cname = "webugc_" + sha1(name);
        var result = null;
        try {
          result = localStorage.getItem(cname);
        } catch (e) {
        }
        return result;
      };
      Uploader2.prototype.delStorage = function(name) {
        if (!name) {
          return;
        }
        var cname = "webugc_" + sha1(name);
        try {
          localStorage.removeItem(cname);
        } catch (e) {
        }
      };
      Uploader2.prototype.validateInitParams = function(params) {
        if (!util_1.default.isFunction(params.getSignature)) {
          throw new Error("getSignature must be a function");
        }
        if (params.videoFile && !util_1.default.isFile(params.videoFile)) {
          throw new Error("videoFile must be a File");
        }
      };
      Uploader2.prototype.genFileInfo = function() {
        var videoFile = this.videoFile;
        if (videoFile) {
          var lastDotIndex = videoFile.name.lastIndexOf(".");
          var videoName = "";
          if (this.videoName) {
            if (!util_1.default.isString(this.videoName)) {
              throw new Error("mediaName must be a string");
            } else if (/[:*?<>\"\\/|]/g.test(this.videoName)) {
              throw new Error('Cant use these chars in filename: \\ / : * ? " < > |');
            } else {
              videoName = this.videoName;
            }
          } else {
            videoName = videoFile.name.substring(0, lastDotIndex);
          }
          this.videoInfo = {
            name: videoName,
            type: videoFile.name.substring(lastDotIndex + 1).toLowerCase(),
            size: videoFile.size
          };
          this.sessionName += videoFile.name + "_" + videoFile.size + ";";
        }
        var coverFile = this.coverFile;
        if (coverFile) {
          var coverName = coverFile.name;
          var coverLastDotIndex = coverName.lastIndexOf(".");
          this.coverInfo = {
            name: coverName.substring(0, coverLastDotIndex),
            type: coverName.substring(coverLastDotIndex + 1).toLowerCase(),
            size: coverFile.size
          };
          this.sessionName += coverFile.name + "_" + coverFile.size + ";";
        }
      };
      Uploader2.prototype.applyUploadUGC = function(retryCount) {
        if (retryCount === void 0) {
          retryCount = 0;
        }
        return __awaiter(this, void 0, void 0, function() {
          function whenError(err2) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (err2.code === 500) {
                      Uploader2.host = Uploader2.host === util_1.HOST.MAIN ? util_1.HOST.BACKUP : util_1.HOST.MAIN;
                    }
                    self2.emit(vod_reporter_1.VodReportEvent.report_apply, {
                      err: err2,
                      requestStartTime
                    });
                    self2.delStorage(self2.sessionName);
                    if (self2.applyRequestRetryCount == retryCount) {
                      if (err2) {
                        throw err2;
                      }
                      throw new Error("apply upload failed");
                    }
                    return [4, util_1.default.delay(self2.retryDelay)];
                  case 1:
                    _a.sent();
                    return [2, self2.applyUploadUGC(retryCount + 1)];
                }
              });
            });
          }
          var self2, signature, sendParams, videoInfo, coverInfo, vodSessionKey, requestStartTime, response, e_1, applyResult, applyData, vodSessionKey_1, err;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                self2 = this;
                return [4, this.getSignature()];
              case 1:
                signature = _a.sent();
                videoInfo = this.videoInfo;
                coverInfo = this.coverInfo;
                vodSessionKey = this.vodSessionKey || this.enableResume && this.getStorage(this.sessionName);
                if (vodSessionKey) {
                  sendParams = {
                    signature,
                    vodSessionKey
                  };
                } else if (videoInfo) {
                  sendParams = {
                    signature,
                    videoName: videoInfo.name,
                    videoType: videoInfo.type,
                    videoSize: videoInfo.size
                  };
                  if (coverInfo) {
                    sendParams.coverName = coverInfo.name;
                    sendParams.coverType = coverInfo.type;
                    sendParams.coverSize = coverInfo.size;
                  }
                } else if (this.fileId && coverInfo) {
                  sendParams = {
                    signature,
                    fileId: this.fileId,
                    coverName: coverInfo.name,
                    coverType: coverInfo.type,
                    coverSize: coverInfo.size
                  };
                } else {
                  throw "Wrong params, please check and try again";
                }
                sendParams.uploadFromWeb = true;
                requestStartTime = new Date();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, exports2.vodAxios.post("https://" + Uploader2.host + "/v3/index.php?Action=ApplyUploadUGC", sendParams, {
                  timeout: this.applyRequestTimeout,
                  withCredentials: false
                })];
              case 3:
                response = _a.sent();
                return [3, 5];
              case 4:
                e_1 = _a.sent();
                return [2, whenError(e_1)];
              case 5:
                applyResult = response.data;
                if (applyResult.code == 0) {
                  applyData = applyResult.data;
                  vodSessionKey_1 = applyData.vodSessionKey;
                  this.setStorage(this.sessionName, vodSessionKey_1);
                  this.vodSessionKey = vodSessionKey_1;
                  this.appId = applyData.appId;
                  this.emit(vod_reporter_1.VodReportEvent.report_apply, {
                    data: applyData,
                    requestStartTime
                  });
                  return [2, applyData];
                } else {
                  err = new Error(applyResult.message);
                  err.code = applyResult.code;
                  return [2, whenError(err)];
                }
                return [2];
            }
          });
        });
      };
      Uploader2.prototype.uploadToCos = function(applyData) {
        return __awaiter(this, void 0, void 0, function() {
          var self2, cosParam, cos, uploadCosParams, cosVideoParam, cosCoverParam, requestStartTime, uploadPromises;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                self2 = this;
                cosParam = {
                  bucket: applyData.storageBucket + "-" + applyData.storageAppId,
                  region: applyData.storageRegionV5
                };
                cos = new COS(Object.assign({
                  getAuthorization: function(options, callback) {
                    return __awaiter(this, void 0, void 0, function() {
                      var currentTimeStamp, safeExpireTime;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            currentTimeStamp = util_1.default.getUnix();
                            safeExpireTime = (applyData.tempCertificate.expiredTime - applyData.timestamp) * 0.9;
                            if (!(self2.cosAuthTime === 0))
                              return [3, 1];
                            self2.cosAuthTime = currentTimeStamp;
                            return [3, 3];
                          case 1:
                            if (!(self2.cosAuthTime && currentTimeStamp - self2.cosAuthTime >= safeExpireTime))
                              return [3, 3];
                            return [4, self2.applyUploadUGC()];
                          case 2:
                            applyData = _a2.sent();
                            self2.cosAuthTime = util_1.default.getUnix();
                            _a2.label = 3;
                          case 3:
                            callback({
                              TmpSecretId: applyData.tempCertificate.secretId,
                              TmpSecretKey: applyData.tempCertificate.secretKey,
                              XCosSecurityToken: applyData.tempCertificate.token,
                              StartTime: applyData.timestamp,
                              ExpiredTime: applyData.tempCertificate.expiredTime
                            });
                            return [2];
                        }
                      });
                    });
                  }
                }, this.cosStrategy));
                this.cos = cos;
                uploadCosParams = [];
                if (this.videoFile) {
                  cosVideoParam = __assign(__assign({}, cosParam), { file: this.videoFile, key: applyData.video.storagePath, onProgress: function(data) {
                    self2.emit(UploaderEvent.video_progress, data);
                    self2.emit(UploaderEvent.media_progress, data);
                  }, onUpload: function(data) {
                    self2.emit(UploaderEvent.video_upload, data);
                    self2.emit(UploaderEvent.media_upload, data);
                  }, onTaskReady: function(taskId) {
                    self2.taskId = taskId;
                  } });
                  uploadCosParams.push(cosVideoParam);
                }
                if (this.coverFile) {
                  cosCoverParam = __assign(__assign({}, cosParam), { file: this.coverFile, key: applyData.cover.storagePath, onProgress: function(data) {
                    self2.emit(UploaderEvent.cover_progress, data);
                  }, onUpload: function(data) {
                    self2.emit(UploaderEvent.cover_upload, data);
                  }, onTaskReady: util_1.default.noop });
                  uploadCosParams.push(cosCoverParam);
                }
                requestStartTime = new Date();
                uploadPromises = uploadCosParams.map(function(uploadCosParam) {
                  return new Promise(function(resolve, reject) {
                    cos.sliceUploadFile({
                      Bucket: uploadCosParam.bucket,
                      Region: uploadCosParam.region,
                      Key: uploadCosParam.key,
                      Body: uploadCosParam.file,
                      onTaskReady: uploadCosParam.onTaskReady,
                      onProgress: uploadCosParam.onProgress
                    }, function(err, data) {
                      if (uploadCosParam.file === self2.videoFile) {
                        self2.emit(vod_reporter_1.VodReportEvent.report_cos_upload, {
                          err,
                          requestStartTime
                        });
                      }
                      if (!err) {
                        uploadCosParam.onUpload(data);
                        return resolve();
                      }
                      self2.delStorage(self2.sessionName);
                      if (JSON.stringify(err) === '{"error":"error","headers":{}}') {
                        return reject(new Error("cors error"));
                      }
                      reject(err);
                    });
                  });
                });
                return [4, Promise.all(uploadPromises)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Uploader2.prototype.commitUploadUGC = function(retryCount) {
        if (retryCount === void 0) {
          retryCount = 0;
        }
        return __awaiter(this, void 0, void 0, function() {
          function whenError(err2) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (err2.code === 500) {
                      Uploader2.host = Uploader2.host === util_1.HOST.MAIN ? util_1.HOST.BACKUP : util_1.HOST.MAIN;
                    }
                    self2.emit(vod_reporter_1.VodReportEvent.report_commit, {
                      err: err2,
                      requestStartTime
                    });
                    if (self2.commitRequestRetryCount == retryCount) {
                      if (err2) {
                        throw err2;
                      }
                      throw new Error("commit upload failed");
                    }
                    return [4, util_1.default.delay(self2.retryDelay)];
                  case 1:
                    _a.sent();
                    return [2, self2.commitUploadUGC(retryCount + 1)];
                }
              });
            });
          }
          var self2, signature, vodSessionKey, requestStartTime, response, e_2, commitResult, err;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                self2 = this;
                return [4, this.getSignature()];
              case 1:
                signature = _a.sent();
                this.delStorage(this.sessionName);
                vodSessionKey = this.vodSessionKey;
                requestStartTime = new Date();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, exports2.vodAxios.post("https://" + Uploader2.host + "/v3/index.php?Action=CommitUploadUGC", {
                  signature,
                  vodSessionKey
                }, {
                  timeout: this.commitRequestTimeout,
                  withCredentials: false
                })];
              case 3:
                response = _a.sent();
                return [3, 5];
              case 4:
                e_2 = _a.sent();
                return [2, whenError(e_2)];
              case 5:
                commitResult = response.data;
                if (commitResult.code == 0) {
                  this.emit(vod_reporter_1.VodReportEvent.report_commit, {
                    data: commitResult.data,
                    requestStartTime
                  });
                  return [2, commitResult.data];
                } else {
                  err = new Error(commitResult.message);
                  err.code = commitResult.code;
                  return [2, whenError(err)];
                }
                return [2];
            }
          });
        });
      };
      Uploader2.prototype.start = function() {
        var _this = this;
        var requestStartTime = new Date();
        this.donePromise = this._start().then(function(doneResult) {
          _this.emit(vod_reporter_1.VodReportEvent.report_done, {
            err: { code: 0 },
            requestStartTime
          });
          return doneResult;
        }).catch(function(err) {
          _this.emit(vod_reporter_1.VodReportEvent.report_done, {
            err: {
              code: err && err.code || util_1.default.CLIENT_ERROR_CODE.UPLOAD_FAIL
            },
            requestStartTime
          });
          throw err;
        });
      };
      Uploader2.prototype._start = function() {
        return __awaiter(this, void 0, void 0, function() {
          var applyData;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.applyUploadUGC()];
              case 1:
                applyData = _a.sent();
                return [4, this.uploadToCos(applyData)];
              case 2:
                _a.sent();
                return [4, this.commitUploadUGC()];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      };
      Uploader2.prototype.done = function() {
        return this.donePromise;
      };
      Uploader2.prototype.cancel = function() {
        this.cos.cancelTask(this.taskId);
      };
      Uploader2.host = util_1.HOST.MAIN;
      return Uploader2;
    }(eventemitter3_1.EventEmitter);
    exports2.default = Uploader;
  }
});

// node_modules/vod-js-sdk-v6/lib/src/tc_vod.js
var require_tc_vod = __commonJS({
  "node_modules/vod-js-sdk-v6/lib/src/tc_vod.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uploader_1 = require_uploader();
    var vod_reporter_1 = require_vod_reporter();
    var TcVod = function() {
      function TcVod2(params) {
        this.allowReport = true;
        this.enableResume = true;
        this.getSignature = params.getSignature;
        if (params.allowReport !== void 0) {
          this.allowReport = params.allowReport;
        }
        if (params.enableResume !== void 0) {
          this.enableResume = params.enableResume;
        }
        this.appId = params.appId;
        this.reportId = params.reportId;
      }
      TcVod2.prototype.upload = function(params) {
        var uploaderParams = __assign({ getSignature: this.getSignature, appId: this.appId, reportId: this.reportId, enableResume: this.enableResume }, params);
        var uploader = new uploader_1.default(uploaderParams);
        if (this.allowReport) {
          this.initReporter(uploader);
        }
        uploader.start();
        return uploader;
      };
      TcVod2.prototype.initReporter = function(uploader) {
        new vod_reporter_1.VodReporter(uploader);
      };
      return TcVod2;
    }();
    exports2.default = TcVod;
  }
});

// dep:vod-js-sdk-v6
var vod_js_sdk_v6_default = require_tc_vod();
export {
  vod_js_sdk_v6_default as default
};
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
//# sourceMappingURL=vod-js-sdk-v6.js.map
